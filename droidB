#!/usr/bin/env bash

# droidB - Advanced Android & Samsung Device Management Tool with Universal Debloater
# Version: 0.2.0
# Author: 0xbv1 | 0xb0rn3
# GitHub: https://github.com/0xb0rn3/droidB
# License: MIT

set -uo pipefail 

VERSION="0.2.0 Latest | Stable"
SCRIPT_NAME="droidB"
INSTALL_DIR="/usr/local/bin"

# Color definitions
BLUE='\033[94m'
GREEN='\033[92m'
RED='\033[91m'
YELLOW='\033[93m'
MAGENTA='\033[95m'
CYAN='\033[96m'
WHITE='\033[97m'
BOLD='\033[1m'
ENDC='\033[0m'

# Global variables
SERIAL=""
ADB=""
FASTBOOT=""
DEVICE_INFO=""
DEBLOAT_LIST_FILE="/tmp/droidb_debloat_list.txt"
SAMSUNG_VENDOR_ID="04e8"
ODIN4_INSTALLED=false
HEIMDALL_INSTALLED=false

# Embedded debloat list
create_embedded_debloat_list() {
    cat > "$DEBLOAT_LIST_FILE" << 'EOF'
# Amazon Bloatware
com.amazon.fv
com.amazon.kindle
com.amazon.mp3
com.amazon.mShop.android
com.amazon.venezia

# Android System Bloat
com.android.apps.tag
com.android.backupconfirm
com.android.bips
com.android.bookmarkprovider
com.android.chrome
com.android.dreams.basic
com.android.dreams.phototable
com.android.email
com.android.exchange
com.android.hotwordenrollment.okgoogle
com.android.hotwordenrollment.xgoogle
com.android.printspooler
com.android.providers.calendar
com.android.providers.partnerbookmarks
com.android.providers.userdictionary
com.android.wallpapercropper
com.android.wallpaper.livepicker

# Audible
com.audible.application

# Bloatware Apps
com.blurb.checkout
com.cequint.ecid
com.cnn.mobile.android.phone.edgepanel

# ANT+ Services
com.dsi.ant.plugins.antplus
com.dsi.ant.server
com.dsi.ant.service.socket

# Game Services
com.enhance.gameservice

# Facebook Bloatware
com.facebook.appmanager
com.facebook.katana
com.facebook.services
com.facebook.system

# Flipboard
com.flipboard.app
com.flipboard.boxer.app

# Google Bloatware
com.google.android.apps.books
com.google.android.apps.docs
com.google.android.apps.magazines
com.google.android.apps.maps
com.google.android.apps.photos
com.google.android.apps.tachyon
com.google.android.apps.youtube.music
com.google.android.feedback
com.google.android.gm
com.google.android.googlequicksearchbox
com.google.android.talk
com.google.android.tts
com.google.android.videos
com.google.android.youtube
com.google.ar.core

# Office Apps
com.hancom.office.editor.hidden
com.infraware.polarisoffice5

# Social Media
com.imdb.mobile
com.linkedin.android

# Microsoft Apps
com.microsoft.appmanager
com.microsoft.office.excel
com.microsoft.office.officehubrow
com.microsoft.office.outlook
com.microsoft.office.powerpoint
com.microsoft.office.word
com.microsoft.skydrive

# Streaming Services
com.netflix.mediaclient

# Keyboard
com.nuance.swype.input
com.touchtype.swiftkey

# Samsung Services
com.samsung.android.app.sbrowseredge
com.samsung.android.app.tips
com.samsung.android.tvplus
com.samsung.android.calendar
com.samsung.android.email.provider
com.samsung.android.messaging

# Bixby
com.samsung.android.bixby.agent
com.samsung.android.bixby.service
com.samsung.android.bixby.wakeup
com.samsung.android.bixbyvision.framework

# More Samsung Bloat
com.samsung.android.game.gamehome
com.samsung.android.game.gametools
com.samsung.android.game.gos
com.samsung.android.samsungpass
com.samsung.android.spay
com.samsung.android.voc

# Other Bloatware
com.skype.raider
com.spotify.music
com.tripadvisor.tripadvisor
EOF
}

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --install)
                install_systemwide
                ;;
            --version|-v)
                echo "droidB version $VERSION"
                exit 0
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            --device|-d)
                shift
                SERIAL="$1"
                ;;
            *)
                echo -e "${RED}Unknown option: $1${ENDC}"
                show_help
                exit 1
                ;;
        esac
        shift
    done
}

show_help() {
    cat << EOF
${BOLD}${BLUE}droidB v$VERSION - Advanced Android Device Manager${ENDC}

${BOLD}USAGE:${ENDC}
    $SCRIPT_NAME [OPTIONS]

${BOLD}OPTIONS:${ENDC}
    --install           Install droidB system-wide
    --version, -v       Show version information
    --help, -h          Show this help message
    --device, -d        Specify device serial

${BOLD}FEATURES:${ENDC}
    • Universal Debloater (100+ bloatware packages)
    • Samsung firmware flashing (Odin4 + Heimdall)
    • Fastboot operations (flash, unlock, boot)
    • Full ADB automation
    • Drag & drop file operations
    • Device backup/restore
    • Security-focused design

${BOLD}SAMSUNG FEATURES:${ENDC}
    • Odin4 integration for firmware flashing
    • Heimdall support (cross-platform)
    • Download mode detection
    • PIT file operations
    • USB rules auto-setup

${BOLD}EXAMPLES:${ENDC}
    $SCRIPT_NAME                    # Interactive mode
    $SCRIPT_NAME --install          # Install system-wide
    $SCRIPT_NAME --device SERIAL    # Specific device

${BOLD}AUTHOR:${ENDC}
    0xbv1 | 0xb0rn3
    https://github.com/0xb0rn3/droidB

EOF
}

clear_screen() {
    clear
    echo -ne "\033]0;droidB v$VERSION\007"
}

display_banner() {
    clear_screen
    echo -e "${CYAN}"
    cat << 'EOF'
    ╔══════════════════════════════════════════════════════════╗
    ║                                                          ║
    ║     ██████╗ ██████╗  ██████╗ ██╗██████╗ ██████╗        ║
    ║     ██╔══██╗██╔══██╗██╔═══██╗██║██╔══██╗██╔══██╗       ║
    ║     ██║  ██║██████╔╝██║   ██║██║██║  ██║██████╔╝       ║
    ║     ██║  ██║██╔══██╗██║   ██║██║██║  ██║██╔══██╗       ║
    ║     ██████╔╝██║  ██║╚██████╔╝██║██████╔╝██████╔╝       ║
    ║     ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚═╝╚═════╝ ╚═════╝        ║
    ║                                                          ║
    ╚══════════════════════════════════════════════════════════╝
EOF
    echo -e "${ENDC}"
    echo -e "${BOLD}${BLUE}    Advanced Android Device Manager v${VERSION}${ENDC}"
    echo -e "${GREEN}    Universal Debloater | Samsung Tools | Security-Focused${ENDC}"
    echo -e "${MAGENTA}    Developer: ${BOLD}0xbv1 | 0xb0rn3${ENDC}"
    echo -e "${YELLOW}════════════════════════════════════════════════════════════${ENDC}"
}

process_path() {
    local input="$1"
    input="${input#\'}"
    input="${input%\'}"
    input="${input#\"}"
    input="${input%\"}"
    input="${input//\\ / }"
    input="${input/#\~/$HOME}"
    echo "$input"
}

confirm_action() {
    local prompt="$1"
    read -p "${BOLD}${YELLOW}$prompt (y/N): ${ENDC}" response
    [[ "$response" =~ ^[Yy]$ ]]
}

get_device_info() {
    DEVICES=$($ADB devices 2>/dev/null | tail -n +2 | grep -v "^$")
    
    if [[ -z "$DEVICES" ]]; then
        DEVICE_INFO=""
        return 1
    fi
    
    DEVICE_COUNT=$(echo "$DEVICES" | wc -l)
    
    if [[ $DEVICE_COUNT -gt 1 ]]; then
        echo -e "${GREEN}Multiple devices connected:${ENDC}"
        echo "$DEVICES" | nl -w 2 -s '. '
        read -p "Select device (number): " CHOICE
        SERIAL=$(echo "$DEVICES" | sed -n "${CHOICE}p" | awk '{print $1}')
    else
        SERIAL=$(echo "$DEVICES" | awk '{print $1}')
    fi
    
    STATE=$($ADB devices | grep $SERIAL | awk '{print $2}')
    
    if [[ "$STATE" == "unauthorized" ]]; then
        echo -e "${RED}Device unauthorized. Check device screen${ENDC}"
        DEVICE_INFO="serial=$SERIAL state=$STATE"
        return 1
    fi
    
    MODEL=$($ADB -s $SERIAL shell getprop ro.product.model 2>/dev/null | tr -d '\r')
    ANDROID_VERSION=$($ADB -s $SERIAL shell getprop ro.build.version.release 2>/dev/null | tr -d '\r')
    MANUFACTURER=$($ADB -s $SERIAL shell getprop ro.product.manufacturer 2>/dev/null | tr -d '\r')
    
    DEVICE_INFO="serial=$SERIAL model=$MODEL android_version=$ANDROID_VERSION manufacturer=$MANUFACTURER state=$STATE"
    
    return 0
}

# DEBLOATER FUNCTIONS

universal_debloater_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${MAGENTA}🗑️  UNIVERSAL DEBLOATER${ENDC}"
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
        
        if [[ -z "$SERIAL" ]]; then
            echo -e "${RED}No device connected${ENDC}"
            read -p "Press Enter to return..."
            return
        fi
        
        echo -e "${GREEN}Device: $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+' || echo 'Unknown')${ENDC}"
        echo -e "${CYAN}Serial: $SERIAL${ENDC}"
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
        
        local app_count=$(grep -cv "^$\|^#" "$DEBLOAT_LIST_FILE" 2>/dev/null || echo "0")
        echo -e "${BOLD}Embedded bloatware list: ${GREEN}$app_count packages${ENDC}"
        
        echo ""
        echo "1. Debloat with embedded list (recommended)"
        echo "2. Debloat with custom list file"
        echo "3. Preview embedded debloat list"
        echo "4. Selective debloat (choose apps)"
        echo "5. Scan device for bloatware"
        echo "6. Revert/Restore debloated apps"
        echo "7. Create backup before debloat"
        echo "8. Export embedded list to file"
        echo "9. Back to main menu"
        echo ""
        
        read -p "Select option: " choice
        
        case $choice in
            1) debloat_with_embedded_list ;;
            2) debloat_with_custom_list ;;
            3) preview_debloat_list ;;
            4) selective_debloat ;;
            5) scan_for_bloatware ;;
            6) revert_debloat ;;
            7) backup_before_debloat ;;
            8) export_embedded_list ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

debloat_with_embedded_list() {
    clear_screen
    echo -e "${BOLD}${RED}⚠️  DEBLOAT WITH EMBEDDED LIST ⚠️${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    local app_count=$(grep -cv "^$\|^#" "$DEBLOAT_LIST_FILE")
    echo -e "${WHITE}This will remove ${GREEN}$app_count${WHITE} bloatware packages from your device.${ENDC}"
    echo -e "${YELLOW}These apps will be uninstalled for the current user (data preserved).${ENDC}"
    echo -e "${CYAN}You can restore them later using the revert function.${ENDC}"
    echo ""
    echo -e "${RED}WARNING: Some apps may be needed for certain features.${ENDC}"
    echo ""
    
    confirm_action "Proceed with debloat?" || return
    
    echo ""
    echo -e "${BLUE}Starting debloat process...${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    local success_count=0
    local fail_count=0
    local not_found_count=0
    
    while IFS= read -r package; do
        [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
        
        package=$(echo "$package" | xargs)
        
        echo -ne "${CYAN}Processing: ${WHITE}$package${ENDC}..."
        
        if $ADB -s $SERIAL shell pm list packages 2>/dev/null | grep -q "^package:$package$"; then
            if $ADB -s $SERIAL shell pm uninstall -k --user 0 "$package" 2>/dev/null | grep -q "Success"; then
                echo -e " ${GREEN}[✓ REMOVED]${ENDC}"
                ((success_count++))
            else
                echo -e " ${RED}[✗ FAILED]${ENDC}"
                ((fail_count++))
            fi
        else
            echo -e " ${YELLOW}[- NOT FOUND]${ENDC}"
            ((not_found_count++))
        fi
    done < "$DEBLOAT_LIST_FILE"
    
    echo ""
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    echo -e "${BOLD}${GREEN}Debloat Summary:${ENDC}"
    echo -e "${GREEN}  ✓ Successfully removed: $success_count packages${ENDC}"
    echo -e "${RED}  ✗ Failed to remove: $fail_count packages${ENDC}"
    echo -e "${YELLOW}  - Not found on device: $not_found_count packages${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo ""
    read -p "Reboot device now? (y/N): " reboot_choice
    if [[ "$reboot_choice" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Rebooting device...${ENDC}"
        $ADB -s $SERIAL reboot
        echo -e "${GREEN}Reboot command sent${ENDC}"
    fi
    
    read -p "Press Enter to continue..."
}

debloat_with_custom_list() {
    clear_screen
    echo -e "${BOLD}${CYAN}DEBLOAT WITH CUSTOM LIST${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo -e "${WHITE}Drag & drop your custom debloat list file:${ENDC}"
    echo -e "${CYAN}Format: One package name per line, # for comments${ENDC}"
    echo ""
    
    read -p "File path: " custom_file
    custom_file=$(process_path "$custom_file")
    
    if [[ ! -f "$custom_file" ]]; then
        echo -e "${RED}File not found: $custom_file${ENDC}"
        sleep 2
        return
    fi
    
    local app_count=$(grep -cv "^$\|^#" "$custom_file")
    echo ""
    echo -e "${GREEN}Found $app_count packages in custom list${ENDC}"
    echo ""
    
    confirm_action "Proceed with custom debloat?" || return
    
    echo ""
    echo -e "${BLUE}Starting custom debloat process...${ENDC}"
    
    local success_count=0
    local fail_count=0
    
    while IFS= read -r package; do
        [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
        
        package=$(echo "$package" | xargs)
        
        echo -ne "${CYAN}Processing: ${WHITE}$package${ENDC}..."
        
        if $ADB -s $SERIAL shell pm list packages 2>/dev/null | grep -q "^package:$package$"; then
            if $ADB -s $SERIAL shell pm uninstall -k --user 0 "$package" 2>/dev/null | grep -q "Success"; then
                echo -e " ${GREEN}[✓]${ENDC}"
                ((success_count++))
            else
                echo -e " ${RED}[✗]${ENDC}"
                ((fail_count++))
            fi
        fi
    done < "$custom_file"
    
    echo ""
    echo -e "${GREEN}Removed: $success_count${ENDC} | ${RED}Failed: $fail_count${ENDC}"
    read -p "Press Enter..."
}

preview_debloat_list() {
    clear_screen
    echo -e "${BOLD}${CYAN}EMBEDDED DEBLOAT LIST PREVIEW${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    cat "$DEBLOAT_LIST_FILE" | less
    
    read -p "Press Enter to continue..."
}

selective_debloat() {
    clear_screen
    echo -e "${BOLD}${CYAN}SELECTIVE DEBLOAT${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo "1. Amazon bloatware"
    echo "2. Facebook apps"
    echo "3. Google apps"
    echo "4. Microsoft Office"
    echo "5. Samsung bloatware"
    echo "6. Bixby services"
    echo "7. Custom package names"
    echo ""
    
    read -p "Select category: " category
    
    local packages=""
    
    case $category in
        1) packages="com.amazon.fv com.amazon.kindle com.amazon.mp3" ;;
        2) packages="com.facebook.appmanager com.facebook.katana com.facebook.services" ;;
        3) packages="com.google.android.apps.docs com.google.android.apps.maps com.google.android.youtube" ;;
        4) packages="com.microsoft.office.excel com.microsoft.office.word com.microsoft.office.powerpoint" ;;
        5) packages="com.samsung.android.app.sbrowseredge com.samsung.android.tvplus" ;;
        6) packages="com.samsung.android.bixby.agent com.samsung.android.bixby.service" ;;
        7)
            echo ""
            echo -e "${WHITE}Enter package names (space separated):${ENDC}"
            read -p "> " packages
            ;;
        *) echo -e "${RED}Invalid option${ENDC}"; sleep 1; return ;;
    esac
    
    [[ -z "$packages" ]] && return
    
    echo ""
    for pkg in $packages; do
        echo -ne "${CYAN}Removing: ${WHITE}$pkg${ENDC}..."
        if $ADB -s $SERIAL shell pm uninstall -k --user 0 "$pkg" 2>/dev/null | grep -q "Success"; then
            echo -e " ${GREEN}[✓]${ENDC}"
        else
            echo -e " ${RED}[✗]${ENDC}"
        fi
    done
    
    read -p "Press Enter..."
}

scan_for_bloatware() {
    clear_screen
    echo -e "${BOLD}${CYAN}SCAN DEVICE FOR BLOATWARE${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo -e "${BLUE}Scanning device...${ENDC}"
    
    local found_count=0
    
    while IFS= read -r package; do
        [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
        
        package=$(echo "$package" | xargs)
        
        if $ADB -s $SERIAL shell pm list packages 2>/dev/null | grep -q "^package:$package$"; then
            echo -e "${RED}[FOUND]${ENDC} $package"
            ((found_count++))
        fi
    done < "$DEBLOAT_LIST_FILE"
    
    echo ""
    echo -e "${RED}Found $found_count bloatware packages on device${ENDC}"
    
    read -p "Press Enter..."
}

revert_debloat() {
    clear_screen
    echo -e "${BOLD}${GREEN}REVERT/RESTORE DEBLOATED APPS${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo "1. Restore all apps from embedded list"
    echo "2. Restore specific packages"
    echo "3. Back"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1)
            confirm_action "Restore all packages?" || return
            
            local success_count=0
            local fail_count=0
            
            while IFS= read -r package; do
                [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
                
                package=$(echo "$package" | xargs)
                
                echo -ne "${CYAN}Restoring: ${WHITE}$package${ENDC}..."
                
                if $ADB -s $SERIAL shell cmd package install-existing "$package" 2>/dev/null | grep -Ev "(Failure|doesn't exist)" > /dev/null; then
                    echo -e " ${GREEN}[✓]${ENDC}"
                    ((success_count++))
                else
                    echo -e " ${RED}[✗]${ENDC}"
                    ((fail_count++))
                fi
            done < "$DEBLOAT_LIST_FILE"
            
            echo ""
            echo -e "${GREEN}Restored: $success_count${ENDC} | ${RED}Failed: $fail_count${ENDC}"
            ;;
        2)
            echo ""
            echo -e "${WHITE}Enter package names (space separated):${ENDC}"
            read -p "> " packages
            
            for package in $packages; do
                echo -ne "${CYAN}Restoring: ${WHITE}$package${ENDC}..."
                if $ADB -s $SERIAL shell cmd package install-existing "$package" 2>/dev/null | grep -Ev "(Failure|doesn't exist)" > /dev/null; then
                    echo -e " ${GREEN}[✓]${ENDC}"
                else
                    echo -e " ${RED}[✗]${ENDC}"
                fi
            done
            ;;
    esac
    
    read -p "Press Enter..."
}

backup_before_debloat() {
    clear_screen
    echo -e "${BOLD}${CYAN}BACKUP PACKAGE LIST${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    local backup_file="debloat_backup_$(date +%Y%m%d_%H%M%S).txt"
    
    echo "# droidB Backup - $(date)" > "$backup_file"
    $ADB -s $SERIAL shell pm list packages | sed 's/package://' >> "$backup_file"
    
    echo ""
    echo -e "${GREEN}✓ Backup saved: $backup_file${ENDC}"
    
    read -p "Press Enter..."
}

export_embedded_list() {
    clear_screen
    echo -e "${BOLD}${CYAN}EXPORT EMBEDDED LIST${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    local export_file="droidb_debloat_list_$(date +%Y%m%d).txt"
    
    cp "$DEBLOAT_LIST_FILE" "$export_file"
    
    echo ""
    echo -e "${GREEN}✓ List exported to: $export_file${ENDC}"
    
    read -p "Press Enter..."
}

# SAMSUNG OPERATIONS FUNCTIONS

check_samsung_tools() {
    if command -v odin4 &>/dev/null; then
        ODIN4_INSTALLED=true
        echo -e "${GREEN}✓ Odin4: Installed${ENDC}"
    else
        echo -e "${YELLOW}⚠ Odin4: Not installed${ENDC}"
    fi
    
    if command -v heimdall &>/dev/null; then
        HEIMDALL_INSTALLED=true
        echo -e "${GREEN}✓ Heimdall: Installed${ENDC}"
    else
        echo -e "${YELLOW}⚠ Heimdall: Not installed${ENDC}"
    fi
}

setup_samsung_udev_rules() {
    local RULES_FILE="/etc/udev/rules.d/51-samsung.rules"
    
    if [[ ! -f "$RULES_FILE" ]]; then
        echo -e "${BLUE}Setting up Samsung USB rules...${ENDC}"
        
        cat << 'EOF' | sudo tee "$RULES_FILE" > /dev/null
# Samsung devices
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", MODE="0666", GROUP="plugdev"
# Samsung Galaxy models
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="6860", MODE="0666", GROUP="plugdev"
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="68??", MODE="0666", GROUP="plugdev"
# Samsung download mode
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="685d", MODE="0666", GROUP="plugdev"
EOF
        
        sudo udevadm control --reload-rules
        sudo udevadm trigger
        sudo usermod -a -G plugdev $USER 2>/dev/null
        
        echo -e "${GREEN}✓ Samsung USB rules configured${ENDC}"
    fi
}

install_odin4_auto() {
    if [[ "$OSTYPE" != "linux-gnu"* ]]; then
        echo -e "${YELLOW}Odin4 is only available for Linux.${ENDC}"
        return 1
    fi
    
    if command -v odin4 &>/dev/null; then
        echo -e "${GREEN}Odin4 already installed.${ENDC}"
        ODIN4_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Odin4 for Linux...${ENDC}"
    
    if command -v yay &>/dev/null; then
        echo -e "${BLUE}Installing via AUR (yay)...${ENDC}"
        yay -S --noconfirm odin4-cli 2>/dev/null && ODIN4_INSTALLED=true
    elif command -v paru &>/dev/null; then
        echo -e "${BLUE}Installing via AUR (paru)...${ENDC}"
        paru -S --noconfirm odin4-cli 2>/dev/null && ODIN4_INSTALLED=true
    else
        echo -e "${BLUE}Downloading Odin4 from GitHub...${ENDC}"
        ODIN_URL="https://github.com/Adrilaw/OdinV4/releases/download/v1.0/odin.zip"
        TEMP_DIR=$(mktemp -d)
        
        if wget -q "$ODIN_URL" -O "$TEMP_DIR/odin.zip"; then
            cd "$TEMP_DIR"
            unzip -q odin.zip
            
            if [[ -f "odin4" ]]; then
                chmod +x odin4
                sudo mv odin4 /usr/local/bin/
                ODIN4_INSTALLED=true
                echo -e "${GREEN}Odin4 installed successfully${ENDC}"
            else
                echo -e "${RED}Odin4 binary not found in archive${ENDC}"
            fi
            
            cd - >/dev/null
            rm -rf "$TEMP_DIR"
        else
            echo -e "${RED}Failed to download Odin4${ENDC}"
        fi
    fi
    
    setup_samsung_udev_rules
    
    return $([[ $ODIN4_INSTALLED == true ]] && echo 0 || echo 1)
}

install_heimdall() {
    if command -v heimdall &>/dev/null; then
        echo -e "${GREEN}Heimdall already installed.${ENDC}"
        HEIMDALL_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Heimdall...${ENDC}"
    
    if [[ -f /etc/debian_version ]]; then
        sudo apt update && sudo apt install -y heimdall-flash
    elif [[ -f /etc/arch-release ]]; then
        sudo pacman -S --noconfirm heimdall
    elif [[ -f /etc/redhat-release ]]; then
        sudo dnf install -y heimdall
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        command -v brew &>/dev/null && brew install heimdall
    else
        echo -e "${RED}Unsupported OS for automatic Heimdall installation${ENDC}"
        return 1
    fi
    
    command -v heimdall &>/dev/null && HEIMDALL_INSTALLED=true
}

samsung_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${MAGENTA}📱 SAMSUNG OPERATIONS${ENDC}"
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
        
        echo -e "${CYAN}Tool Status:${ENDC}"
        echo -e "  Odin4:    $([[ $ODIN4_INSTALLED == true ]] && echo "${GREEN}✓ Installed${ENDC}" || echo "${RED}✗ Not Installed${ENDC}")"
        echo -e "  Heimdall: $([[ $HEIMDALL_INSTALLED == true ]] && echo "${GREEN}✓ Installed${ENDC}" || echo "${RED}✗ Not Installed${ENDC}")"
        echo ""
        
        if [[ $ODIN4_INSTALLED == false && $HEIMDALL_INSTALLED == false ]]; then
            echo -e "${RED}No Samsung tools installed${ENDC}"
            echo ""
            echo "1. Install Odin4 (Linux only)"
            echo "2. Install Heimdall"
            echo "3. Setup Samsung USB rules"
            echo "4. Back to main menu"
            echo ""
            
            read -p "Select: " opt
            case $opt in
                1) install_odin4_auto; read -p "Press Enter..." ;;
                2) install_heimdall; read -p "Press Enter..." ;;
                3) setup_samsung_udev_rules; read -p "Press Enter..." ;;
                4) return ;;
            esac
        else
            echo "1. Flash firmware with Odin4 (BL/AP/CP/CSC)"
            echo "2. Flash single partition with Odin4"
            echo "3. Flash with Heimdall"
            echo "4. Check download mode"
            echo "5. PIT file operations"
            echo "6. Install/Update Samsung tools"
            echo "7. Back to main menu"
            echo ""
            
            read -p "Select: " opt
            
            case $opt in
                1) samsung_flash_firmware ;;
                2) samsung_flash_single ;;
                3) samsung_flash_heimdall ;;
                4) check_download_mode ;;
                5) pit_operations ;;
                6) samsung_tools_menu ;;
                7) return ;;
            esac
        fi
    done
}

samsung_flash_firmware() {
    clear_screen
    echo -e "${BOLD}${MAGENTA}SAMSUNG FIRMWARE FLASH (Odin4)${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    if [[ $ODIN4_INSTALLED == false ]]; then
        echo -e "${RED}Odin4 not installed${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo -e "${CYAN}Drag & drop .tar/.tar.md5 files or type paths${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo -e "\n${BOLD}Firmware Files:${ENDC}"
    
    echo -e "${BLUE}BL (Bootloader) - optional:${ENDC}"
    read -p "Path: " BL_FILE
    BL_FILE=$(process_path "$BL_FILE")
    
    echo -e "${BLUE}AP (System/PDA) - required:${ENDC}"
    read -p "Path: " AP_FILE
    AP_FILE=$(process_path "$AP_FILE")
    
    echo -e "${BLUE}CP (Modem) - optional:${ENDC}"
    read -p "Path: " CP_FILE
    CP_FILE=$(process_path "$CP_FILE")
    
    echo -e "${BLUE}CSC (Region) - optional:${ENDC}"
    read -p "Path: " CSC_FILE
    CSC_FILE=$(process_path "$CSC_FILE")
    
    echo -e "${BLUE}HOME_CSC (Keep Data) - optional:${ENDC}"
    read -p "Path (use instead of CSC to keep data): " HOME_CSC_FILE
    HOME_CSC_FILE=$(process_path "$HOME_CSC_FILE")
    
    if [[ -z "$AP_FILE" || ! -f "$AP_FILE" ]]; then
        echo -e "${RED}AP file is required for flashing${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    local ODIN_CMD="sudo odin4"
    
    [[ -n "$BL_FILE" && -f "$BL_FILE" ]] && ODIN_CMD="$ODIN_CMD -b \"$BL_FILE\""
    [[ -n "$AP_FILE" && -f "$AP_FILE" ]] && ODIN_CMD="$ODIN_CMD -a \"$AP_FILE\""
    [[ -n "$CP_FILE" && -f "$CP_FILE" ]] && ODIN_CMD="$ODIN_CMD -c \"$CP_FILE\""
    
    if [[ -n "$HOME_CSC_FILE" && -f "$HOME_CSC_FILE" ]]; then
        ODIN_CMD="$ODIN_CMD -s \"$HOME_CSC_FILE\""
    elif [[ -n "$CSC_FILE" && -f "$CSC_FILE" ]]; then
        ODIN_CMD="$ODIN_CMD -s \"$CSC_FILE\""
    fi
    
    echo -e "\n${BOLD}${YELLOW}Flash Summary:${ENDC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    [[ -n "$BL_FILE" && -f "$BL_FILE" ]] && echo -e "BL: ${GREEN}$(basename "$BL_FILE")${ENDC}"
    [[ -n "$AP_FILE" && -f "$AP_FILE" ]] && echo -e "AP: ${GREEN}$(basename "$AP_FILE")${ENDC}"
    [[ -n "$CP_FILE" && -f "$CP_FILE" ]] && echo -e "CP: ${GREEN}$(basename "$CP_FILE")${ENDC}"
    [[ -n "$CSC_FILE" && -f "$CSC_FILE" ]] && echo -e "CSC: ${GREEN}$(basename "$CSC_FILE")${ENDC}"
    [[ -n "$HOME_CSC_FILE" && -f "$HOME_CSC_FILE" ]] && echo -e "HOME_CSC: ${GREEN}$(basename "$HOME_CSC_FILE")${ENDC}"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    echo -e "\n${RED}${BOLD}⚠️  CRITICAL WARNING ⚠️${ENDC}"
    echo -e "${RED}This will replace device firmware!${ENDC}"
    echo -e "${RED}Wrong firmware = BRICK${ENDC}"
    echo -e "${RED}Device must be in Download Mode${ENDC}"
    
    confirm_action "Proceed with firmware flash?" || return
    
    echo -e "\n${BLUE}Executing: $ODIN_CMD${ENDC}"
    eval $ODIN_CMD
    
    if [[ $? -eq 0 ]]; then
        echo -e "\n${GREEN}${BOLD}✓ Flash completed successfully!${ENDC}"
    else
        echo -e "\n${RED}${BOLD}✗ Flash failed! Check device and try again.${ENDC}"
    fi
    
    read -p "Press Enter to continue..."
}

samsung_flash_single() {
    clear_screen
    echo -e "${BOLD}${MAGENTA}FLASH SINGLE PARTITION${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo "Select partition type:"
    echo "1. BL (Bootloader)"
    echo "2. AP (System)"
    echo "3. CP (Modem)"
    echo "4. CSC (Region)"
    echo ""
    
    read -p "Select: " part_type
    
    echo -e "\n${YELLOW}Drag & drop file:${ENDC}"
    read -p "File path: " FILE
    FILE=$(process_path "$FILE")
    
    if [[ ! -f "$FILE" ]]; then
        echo -e "${RED}File not found${ENDC}"
        sleep 2
        return
    fi
    
    confirm_action "Flash $(basename "$FILE")?" || return
    
    case $part_type in
        1) sudo odin4 -b "$FILE" ;;
        2) sudo odin4 -a "$FILE" ;;
        3) sudo odin4 -c "$FILE" ;;
        4) sudo odin4 -s "$FILE" ;;
        *) echo -e "${RED}Invalid option${ENDC}"; sleep 2; return ;;
    esac
    
    read -p "Press Enter..."
}

samsung_flash_heimdall() {
    clear_screen
    echo -e "${BOLD}${MAGENTA}FLASH WITH HEIMDALL${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    if [[ $HEIMDALL_INSTALLED == false ]]; then
        echo -e "${RED}Heimdall not installed${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo "1. Flash recovery"
    echo "2. Flash kernel"
    echo "3. Flash system"
    echo "4. Custom partition"
    echo ""
    
    read -p "Select: " opt
    
    echo -e "\n${YELLOW}Drag & drop image file:${ENDC}"
    read -p "File path: " FILE
    FILE=$(process_path "$FILE")
    
    if [[ ! -f "$FILE" ]]; then
        echo -e "${RED}File not found${ENDC}"
        sleep 2
        return
    fi
    
    confirm_action "Flash with Heimdall?" || return
    
    case $opt in
        1) sudo heimdall flash --RECOVERY "$FILE" ;;
        2) sudo heimdall flash --KERNEL "$FILE" ;;
        3) sudo heimdall flash --SYSTEM "$FILE" ;;
        4)
            read -p "Partition name (uppercase): " PART
            sudo heimdall flash --$PART "$FILE"
            ;;
    esac
    
    read -p "Press Enter..."
}

check_download_mode() {
    clear_screen
    echo -e "${BOLD}${CYAN}CHECK SAMSUNG DOWNLOAD MODE${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo -e "${BLUE}Checking for Samsung devices...${ENDC}"
    echo ""
    
    lsusb | grep "04e8:" && echo -e "\n${GREEN}Samsung device detected${ENDC}" || echo -e "\n${RED}No Samsung devices found${ENDC}"
    
    echo ""
    if [[ $ODIN4_INSTALLED == true ]]; then
        echo -e "${BLUE}Odin4 device list:${ENDC}"
        sudo odin4 -l 2>/dev/null || echo -e "${YELLOW}No devices in download mode${ENDC}"
    fi
    
    if [[ $HEIMDALL_INSTALLED == true ]]; then
        echo ""
        echo -e "${BLUE}Heimdall device detection:${ENDC}"
        sudo heimdall detect 2>/dev/null || echo -e "${YELLOW}No devices detected${ENDC}"
    fi
    
    echo ""
    echo -e "${CYAN}To enter Download Mode:${ENDC}"
    echo "  1. Power off device"
    echo "  2. Hold Volume Down + Power"
    echo "  3. Press Volume Up to confirm"
    
    read -p "Press Enter..."
}

pit_operations() {
    clear_screen
    echo -e "${BOLD}${CYAN}PIT FILE OPERATIONS${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    if [[ $HEIMDALL_INSTALLED == false ]]; then
        echo -e "${RED}Heimdall required for PIT operations${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo "1. Download PIT from device"
    echo "2. Print PIT info"
    echo "3. Flash with PIT (Odin4)"
    echo "4. Back"
    echo ""
    
    read -p "Select: " opt
    
    case $opt in
        1)
            read -p "Output filename (e.g., device.pit): " PIT_FILE
            PIT_FILE=${PIT_FILE:-device.pit}
            sudo heimdall download-pit --output "$PIT_FILE"
            [[ -f "$PIT_FILE" ]] && echo -e "${GREEN}✓ PIT saved: $PIT_FILE${ENDC}"
            ;;
        2)
            sudo heimdall print-pit
            ;;
        3)
            if [[ $ODIN4_INSTALLED == false ]]; then
                echo -e "${RED}Odin4 not installed${ENDC}"
            else
                read -p "PIT file path: " PIT
                PIT=$(process_path "$PIT")
                [[ -f "$PIT" ]] && sudo odin4 --pit "$PIT"
            fi
            ;;
    esac
    
    [[ $opt != 4 ]] && read -p "Press Enter..."
}

samsung_tools_menu() {
    clear_screen
    echo -e "${BOLD}${CYAN}SAMSUNG TOOLS INSTALLATION${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo "1. Install Odin4"
    echo "2. Install Heimdall"
    echo "3. Setup USB rules"
    echo "4. Back"
    echo ""
    
    read -p "Select: " opt
    
    case $opt in
        1) install_odin4_auto ;;
        2) install_heimdall ;;
        3) setup_samsung_udev_rules ;;
    esac
    
    [[ $opt != 4 ]] && read -p "Press Enter..."
}

display_device_info() {
    clear_screen
    echo -e "${BOLD}${CYAN}📱 DEVICE INFORMATION${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    if [[ -z "$DEVICE_INFO" ]]; then
        echo -e "${RED}No device information available${ENDC}"
    else
        echo -e "${GREEN}Serial:${ENDC}           $(echo $DEVICE_INFO | grep -oP 'serial=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}Manufacturer:${ENDC}     $(echo $DEVICE_INFO | grep -oP 'manufacturer=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}Model:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}Android Version:${ENDC}  $(echo $DEVICE_INFO | grep -oP 'android_version=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}State:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+' || echo 'N/A')"
    fi
    
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    read -p "Press Enter to continue..."
}

app_management_menu() {
    clear_screen
    echo -e "${BOLD}${CYAN}📱 APP MANAGEMENT${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo "1. Install APK"
    echo "2. Uninstall app"
    echo "3. List installed apps"
    echo "4. Back"
    
    read -p "Select: " opt
    
    case $opt in
        1)
            echo -e "${YELLOW}Drag & drop APK or type path:${ENDC}"
            read -p "APK file: " APK
            APK=$(process_path "$APK")
            [[ -f "$APK" ]] && $ADB -s $SERIAL install "$APK"
            ;;
        2)
            read -p "Package name: " PKG
            $ADB -s $SERIAL uninstall $PKG
            ;;
        3)
            $ADB -s $SERIAL shell pm list packages
            ;;
    esac
    
    [[ $opt != 4 ]] && read -p "Press Enter..."
}

file_operations_menu() {
    clear_screen
    echo -e "${BOLD}${CYAN}📁 FILE OPERATIONS${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo "1. Push file to device"
    echo "2. Pull file from device"
    echo "3. Screenshot"
    echo "4. Back"
    
    read -p "Select: " opt
    
    case $opt in
        1)
            echo -e "${YELLOW}File path:${ENDC}"
            read -p "> " FILE
            FILE=$(process_path "$FILE")
            [[ -f "$FILE" ]] && $ADB -s $SERIAL push "$FILE" /sdcard/
            ;;
        2)
            read -p "Device path: " SRC
            $ADB -s $SERIAL pull "$SRC" .
            ;;
        3)
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            $ADB -s $SERIAL shell screencap /sdcard/screenshot.png
            $ADB -s $SERIAL pull /sdcard/screenshot.png screenshot_$TIMESTAMP.png
            $ADB -s $SERIAL shell rm /sdcard/screenshot.png
            echo -e "${GREEN}Saved: screenshot_$TIMESTAMP.png${ENDC}"
            ;;
    esac
    
    [[ $opt != 4 ]] && read -p "Press Enter..."
}

system_operations_menu() {
    clear_screen
    echo -e "${BOLD}${CYAN}⚙️  SYSTEM OPERATIONS${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    echo "1. Reboot device"
    echo "2. Reboot to recovery"
    echo "3. Reboot to bootloader"
    echo "4. Battery info"
    echo "5. Back"
    
    read -p "Select: " opt
    
    case $opt in
        1) $ADB -s $SERIAL reboot ;;
        2) $ADB -s $SERIAL reboot recovery ;;
        3) $ADB -s $SERIAL reboot bootloader ;;
        4) $ADB -s $SERIAL shell dumpsys battery ;;
    esac
    
    [[ $opt != 5 ]] && read -p "Press Enter..."
}

fastboot_operations_menu() {
    clear_screen
    echo -e "${BOLD}${RED}⚡ FASTBOOT OPERATIONS${ENDC}"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    
    if [[ -z "$FASTBOOT" ]]; then
        echo -e "${RED}Fastboot not available${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    FASTBOOT_DEVICES=$($FASTBOOT devices 2>/dev/null)
    
    if [[ -z "$FASTBOOT_DEVICES" ]]; then
        echo -e "${RED}No devices in fastboot mode${ENDC}"
        echo -e "${CYAN}To enter fastboot:${ENDC}"
        echo "  • adb reboot bootloader"
        echo "  • Volume Down + Power (device off)"
        read -p "Press Enter..."
        return
    fi
    
    echo -e "${GREEN}Fastboot device detected${ENDC}"
    echo ""
    
    echo "1. Flash partition"
    echo "2. Boot image (temporary)"
    echo "3. Unlock bootloader (WIPES DATA)"
    echo "4. Lock bootloader"
    echo "5. Get device info"
    echo "6. Erase partition"
    echo "7. Reboot"
    echo "8. Back"
    
    read -p "Select: " opt
    
    case $opt in
        1)
            read -p "Partition name (boot/recovery/system): " PART
            echo -e "${YELLOW}Drag & drop image:${ENDC}"
            read -p "Image: " IMG
            IMG=$(process_path "$IMG")
            [[ -f "$IMG" ]] && confirm_action "Flash $PART?" && $FASTBOOT flash $PART "$IMG"
            ;;
        2)
            echo -e "${YELLOW}Drag & drop image:${ENDC}"
            read -p "Image: " IMG
            IMG=$(process_path "$IMG")
            [[ -f "$IMG" ]] && $FASTBOOT boot "$IMG"
            ;;
        3)
            echo -e "${RED}${BOLD}WARNING: This will WIPE ALL DATA${ENDC}"
            confirm_action "Unlock bootloader?" && ($FASTBOOT flashing unlock || $FASTBOOT oem unlock)
            ;;
        4)
            echo -e "${RED}${BOLD}WARNING: Lock with custom firmware = BRICK${ENDC}"
            confirm_action "Lock bootloader?" && ($FASTBOOT flashing lock || $FASTBOOT oem lock)
            ;;
        5)
            $FASTBOOT getvar all 2>&1 | grep -v "< waiting"
            ;;
        6)
            read -p "Partition to erase: " PART
            confirm_action "Erase $PART?" && $FASTBOOT erase $PART
            ;;
        7)
            $FASTBOOT reboot
            ;;
    esac
    
    [[ $opt != 8 ]] && read -p "Press Enter..."
}

install_systemwide() {
    echo -e "${BOLD}${GREEN}Installing droidB system-wide...${ENDC}"
    
    if [[ $EUID -ne 0 ]]; then
        sudo cp "$0" "$INSTALL_DIR/$SCRIPT_NAME"
        sudo chmod +x "$INSTALL_DIR/$SCRIPT_NAME"
    else
        cp "$0" "$INSTALL_DIR/$SCRIPT_NAME"
        chmod +x "$INSTALL_DIR/$SCRIPT_NAME"
    fi
    
    echo -e "${GREEN}✓ Installed to $INSTALL_DIR/$SCRIPT_NAME${ENDC}"
    echo -e "${GREEN}Run '$SCRIPT_NAME' from anywhere${ENDC}"
    exit 0
}

check_requirements() {
    # Create embedded debloat list
    create_embedded_debloat_list
    
    if ! command -v adb &>/dev/null; then
        echo -e "${RED}ERROR: ADB not found${ENDC}"
        echo "Install android-tools package for your system"
        exit 1
    fi
    ADB=$(command -v adb)
    
    if ! command -v fastboot &>/dev/null; then
        echo -e "${YELLOW}Warning: Fastboot not found${ENDC}"
    fi
    FASTBOOT=$(command -v fastboot)
    
    # Check Samsung tools
    check_samsung_tools
    
    $ADB start-server &>/dev/null
}

main_menu() {
    while true; do
        clear_screen
        display_banner
        
        get_device_info 2>/dev/null
        
        if [[ -n "$DEVICE_INFO" ]]; then
            STATE=$(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+' || echo 'Unknown')
            MODEL=$(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+' || echo 'Unknown')
            echo -e "${GREEN}Device: $MODEL ($STATE)${ENDC}"
        else
            echo -e "${YELLOW}No device connected${ENDC}"
        fi
        
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
        echo -e "${BOLD}Main Menu:${ENDC}"
        echo "  1. Device Information"
        echo "  2. Universal Debloater 🗑️"
        echo "  3. App Management"
        echo "  4. File Operations"
        echo "  5. System Operations"
        echo "  6. Fastboot Operations"
        echo "  7. Samsung Operations 📱"
        echo "  8. Install System-Wide"
        echo "  q. Exit"
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
        
        read -p "Select option: " choice
        
        case $choice in
            1) display_device_info ;;
            2) [[ -n "$SERIAL" ]] && universal_debloater_menu || { echo -e "${RED}No device${ENDC}"; sleep 2; } ;;
            3) app_management_menu ;;
            4) file_operations_menu ;;
            5) system_operations_menu ;;
            6) fastboot_operations_menu ;;
            7) samsung_operations_menu ;;
            8) install_systemwide ;;
            q|Q) exit 0 ;;
        esac
    done
}

cleanup() {
    rm -f "$DEBLOAT_LIST_FILE" 2>/dev/null
}

trap cleanup EXIT

main() {
    parse_arguments "$@"
    check_requirements
    main_menu
}

main "$@"
