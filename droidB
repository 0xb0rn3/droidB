#!/usr/bin/env bash

set -uo pipefail 

# Ensure standard utility paths are available (fixes Archcraft/minimal installs)
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

VERSION="0.3.1"
SCRIPT_NAME="droidB"
INSTALL_DIR="/usr/local/bin"

BLUE='\033[94m'
GREEN='\033[92m'
RED='\033[91m'
YELLOW='\033[93m'
MAGENTA='\033[95m'
CYAN='\033[96m'
WHITE='\033[97m'
BOLD='\033[1m'
ENDC='\033[0m'

SERIAL=""
ADB=""
FASTBOOT=""
DEVICE_INFO=""
DEBLOAT_LIST_FILE="/tmp/droidb_debloat_list.txt"
SAMSUNG_VENDOR_ID="04e8"
ODIN4_INSTALLED=false
HEIMDALL_INSTALLED=false

create_embedded_debloat_list() {
    cat > "$DEBLOAT_LIST_FILE" << 'EOF'
com.amazon.fv
com.amazon.kindle
com.amazon.mp3
com.amazon.mShop.android
com.amazon.venezia
com.android.apps.tag
com.android.backupconfirm
com.android.bips
com.android.bookmarkprovider
com.android.chrome
com.android.dreams.basic
com.android.dreams.phototable
com.android.email
com.android.exchange
com.android.hotwordenrollment.okgoogle
com.android.hotwordenrollment.xgoogle
com.android.internal.display.cutout.emulation.waterfall
com.android.printspooler
com.android.providers.calendar
com.android.providers.partnerbookmarks
com.android.providers.userdictionary
com.android.role.notes.enabled
com.android.settings.intelligence
com.android.sharedstoragebackup
com.android.stk
com.android.wallpapercropper
com.android.wallpaper.livepicker
com.audible.application
com.blurb.checkout
com.cequint.ecid
com.cnn.mobile.android.phone.edgepanel
com.diotek.sec.lookup.dictionary
com.dsi.ant.plugins.antplus
com.dsi.ant.sample.acquirechannels
com.dsi.ant.server
com.dsi.ant.service.socket
com.enhance.gameservice
com.facebook.appmanager
com.facebook.katana
com.facebook.services
com.facebook.system
com.flipboard.app
com.flipboard.boxer.app
com.google.android.aicore
com.google.android.apps.accessibility.voiceaccess
com.google.android.apps.aiwallpapers
com.google.android.apps.bard
com.google.android.apps.books
com.google.android.apps.docs
com.google.android.apps.magazines
com.google.android.apps.maps
com.google.android.apps.photos
com.google.android.apps.plus
com.google.android.apps.restore
com.google.android.apps.tachyon
com.google.android.apps.youtube.music
com.google.android.feedback
com.google.android.gm
com.google.android.gms.supervision
com.google.android.googlequicksearchbox
com.google.android.healthconnect.controller
com.google.android.onetimeinitializer
com.google.android.partnersetup
com.google.android.printservice.recommendation
com.google.android.projection.gearhead
com.google.android.safetycenter.resources
com.google.android.syncadapters.calendar
com.google.android.talk
com.google.android.tts
com.google.android.videos
com.google.android.youtube
com.google.ar.core
com.google.audio.hearing.visualization.accessibility.scribe
com.google.mainline.telemetry
com.google.vr.vrcore
com.gotv.nflgamecenter.us.lite
com.hancom.office.editor.hidden
com.imdb.mobile
com.infraware.polarisoffice5
com.linkedin.android
com.microsoft.appmanager
com.microsoft.office.excel
com.microsoft.office.officehubrow
com.microsoft.office.outlook
com.microsoft.office.powerpoint
com.microsoft.office.word
com.microsoft.skydrive
com.mobeam.barcodeService
com.monotype.android.font.chococooky
com.monotype.android.font.cooljazz
com.monotype.android.font.foundation
com.monotype.android.font.rosemary
com.monotype.android.font.samsungone
com.netflix.mediaclient
com.nuance.swype.input
com.osp.app.signin
com.policydm
com.samsung.aasaservice
com.samsung.android.aicore
com.samsung.android.aircommandmanager
com.samsung.android.allshare.service.fileshare
com.samsung.android.allshare.service.mediashare
com.samsung.android.app.advsounddetector
com.samsung.android.app.appsedge
com.samsung.android.app.assistantmenu
com.samsung.android.app.camera.sticker.facear3d.preload
com.samsung.android.app.camera.sticker.facearavatar.preload
com.samsung.android.app.camera.sticker.facearframe.preload
com.samsung.android.app.camera.sticker.facear.preload
com.samsung.android.app.camera.sticker.stamp.preload
com.samsung.android.app.clipboardedge
com.samsung.android.app.cocktailbarservice
com.samsung.android.app.episodes
com.samsung.android.app.filterinstaller
com.samsung.android.app.find
com.samsung.android.app.galaxyfinder
com.samsung.android.app.interpreter
com.samsung.android.app.ledbackcover
com.samsung.android.app.ledcoverdream
com.samsung.android.app.memo
com.samsung.android.app.mirrorlink
com.samsung.android.app.notes
com.samsung.android.app.omcagent
com.samsung.android.app.parentalcare
com.samsung.android.app.readingglass
com.samsung.android.app.reminder
com.samsung.android.app.routines
com.samsung.android.app.sbrowseredge
com.samsung.android.app.settings.bixby
com.samsung.android.app.sharelive
com.samsung.android.app.simplesharing
com.samsung.android.app.sketchbook
com.samsung.android.app.soundpicker
com.samsung.android.app.spage
com.samsung.android.app.storyalbumwidget
com.samsung.android.app.talkback
com.samsung.android.app.taskedge
com.samsung.android.app.tips
com.samsung.android.app.updatecenter
com.samsung.android.app.vrsetupwizardstub
com.samsung.android.app.watchmanager
com.samsung.android.app.watchmanagerstub
com.samsung.android.app.withtv
com.samsung.android.ardrawing
com.samsung.android.aremoji
com.samsung.android.aremojieditor
com.samsung.android.arzone
com.samsung.android.authfw
com.samsung.android.aware.service
com.samsung.android.bbc.bbcagent
com.samsung.android.beaconmanager
com.samsung.android.bixby.agent
com.samsung.android.bixby.agent.dummy
com.samsung.android.bixby.es.globalaction
com.samsung.android.bixby.ondevice.enus
com.samsung.android.bixby.ondevice.esus
com.samsung.android.bixby.plmsync
com.samsung.android.bixby.service
com.samsung.android.bixbyvision.framework
com.samsung.android.bixby.voiceinput
com.samsung.android.bixby.wakeup
com.samsung.android.calendar
com.samsung.android.carkey
com.samsung.android.coldwalletservice
com.samsung.android.da.daagent
com.samsung.android.dbsc
com.samsung.android.dkey
com.samsung.android.dlp.service
com.samsung.android.drivelink.stub
com.samsung.android.easysetup
com.samsung.android.email.provider
com.samsung.android.ese
com.samsung.android.fmm
com.samsung.android.forest
com.samsung.android.game.gamehome
com.samsung.android.game.gametools
com.samsung.android.game.gos
com.samsung.android.gametuner.thin
com.samsung.android.globalpostprocmgr
com.samsung.android.gru
com.samsung.android.hmt.vrshell
com.samsung.android.hmt.vrsvc
com.samsung.android.hwresourceshare.storage
com.samsung.android.intellivoiceservice
com.samsung.android.ipsgeofence
com.samsung.android.keyguardwallpaperupdator
com.samsung.android.kidsinstaller
com.samsung.android.knox.analytics.uploader
com.samsung.android.knox.zt.framework
com.samsung.android.liveeffectservice
com.samsung.android.mapsagent
com.samsung.android.mateagent
com.samsung.android.mdecservice
com.samsung.android.mdm
com.samsung.android.mdx
com.samsung.android.mdx.kit
com.samsung.android.messaging
com.samsung.android.mobileservice
com.samsung.android.net.wifi.wifiguider
com.samsung.android.nmt.apps.t2t.languagepack.enesus
com.samsung.android.offline.languagemodel
com.samsung.android.oneconnect
com.samsung.android.rajaampat
com.samsung.android.samsungpass
com.samsung.android.samsungpassautofill
com.samsung.android.scloud
com.samsung.android.scpm
com.samsung.android.sdk.ocr
com.samsung.android.sdk.professionalaudio.utility.jammonitor
com.samsung.android.server.iris
com.samsung.android.service.livedrawing
com.samsung.android.service.peoplestripe
com.samsung.android.service.stplatform
com.samsung.android.service.tagservice
com.samsung.android.service.travel
com.samsung.android.setting.multisound
com.samsung.android.smartmirroring
com.samsung.android.smartsuggestions
com.samsung.android.smartswitchassistant
com.samsung.android.spay
com.samsung.android.spayfw
com.samsung.android.spdfnote
com.samsung.android.ssco
com.samsung.android.stickercenter
com.samsung.android.stickerplugin
com.samsung.android.svoice
com.samsung.android.svoiceime
com.samsung.android.themecenter
com.samsung.android.themestore
com.samsung.android.tripwidget
com.samsung.android.tvplus
com.samsung.android.visionarapps
com.samsung.android.visioncloudagent
com.samsung.android.visionintelligence
com.samsung.android.vision.model
com.samsung.android.visual.cloudcore
com.samsung.android.voc
com.samsung.android.voicewakeup
com.samsung.android.vtcamerasettings
com.samsung.android.widgetapp.yahooedge.finance
com.samsung.android.widgetapp.yahooedge.sport
com.samsung.app.highlightplayer
com.samsung.app.newtrim
com.samsung.daydream.customization
com.samsung.dcmservice
com.samsung.desktopsystemui
com.samsung.ecomm
com.samsung.enhanceservice
com.samsung.faceservice
com.samsung.fresco.logging
com.samsung.groupcast
com.samsung.hs20provider
com.samsung.ipservice
com.samsung.knox.appsupdateagent
com.samsung.knox.rcp.components
com.samsung.knox.securefolder
com.samsung.knox.securefolder.setuppage
com.samsung.petservice
com.samsung.safetyinformation
com.samsung.sec.android.application.csc
com.samsung.SMT
com.samsung.sree
com.samsung.storyservice
com.samsung.svoice.sync
com.samsung.systemui.bixby
com.samsung.systemui.bixby2
com.samsung.ucs.agent.ese
com.samsung.voiceserviceplatform
com.sec.android.app.apex
com.sec.android.app.applinker
com.sec.android.app.billing
com.sec.android.app.bluetoothtest
com.sec.android.app.chromecustomizations
com.sec.android.app.clockpackage
com.sec.android.app.DataCreate
com.sec.android.app.desktoplauncher
com.sec.android.app.dexonpc
com.sec.android.app.factorykeystring
com.sec.android.app.gamehub
com.sec.android.app.hwmoduletest
com.sec.android.app.kidshome
com.sec.android.app.magnifier
com.sec.android.app.myfiles
com.sec.android.app.ocr
com.sec.android.app.parser
com.sec.android.app.personalization
com.sec.android.app.popupcalculator
com.sec.android.app.quicktool
com.sec.android.app.ringtoneBR
com.sec.android.app.safetyassurance
com.sec.android.app.samsungapps
com.sec.android.app.sbrowser
com.sec.android.app.SecSetupWizard
com.sec.android.app.servicemodeapp
com.sec.android.app.setupwizard
com.sec.android.app.shealth
com.sec.android.app.SmartClipEdgeService
com.sec.android.app.soundalive
com.sec.android.app.sysscope
com.sec.android.app.tfunlock
com.sec.android.app.tourviewer
com.sec.android.app.translator
com.sec.android.app.vepreload
com.sec.android.app.ve.vebgm
com.sec.android.app.voicenote
com.sec.android.app.wfdbroker
com.sec.android.app.withtv
com.sec.android.app.wlantest
com.sec.android.autodoodle.service
com.sec.android.AutoPreconfig
com.sec.android.cover.ledcover
com.sec.android.desktopmode.uiservice
com.sec.android.dexsystemui
com.sec.android.diagmonagent
com.sec.android.easyMover
com.sec.android.easyMover.Agent
com.sec.android.easyonehand
com.sec.android.emergencylauncher
com.sec.android.mimage.avatarstickers
com.sec.android.mimage.gear360editor
com.sec.android.mimage.photoretouching
com.sec.android.ofviewer
com.sec.android.omc
com.sec.android.Preconfig
com.sec.android.preloadinstaller
com.sec.android.provider.snote
com.sec.android.providers.security
com.sec.android.providers.tasks
com.sec.android.RilServiceModeApp
com.sec.android.sdhms
com.sec.android.service.health
com.sec.android.sidesync30
com.sec.android.splitsound
com.sec.android.uibcvirtualsoftkey
com.sec.android.widgetapp.diotek.smemo
com.sec.android.widgetapp.easymodecontactswidget
com.sec.android.widgetapp.samsungapps
com.sec.app.TransmitPowerService
com.sec.automation
com.sec.bcservice
com.sec.downloadablekeystore
com.sec.enterprise.knox.attestation
com.sec.enterprise.knox.cloudmdm.smdms
com.sec.enterprise.mdm.services.simpin
com.sec.enterprise.mdm.vpn
com.sec.epdgtestapp
com.sec.everglades
com.sec.everglades.update
com.sec.factory
com.sec.factory.camera
com.sec.factory.iris.usercamera
com.sec.hearingadjust
com.sec.kidsplat.installer
com.sec.knox.foldercontainer
com.sec.knox.knoxsetupwizardclient
com.sec.knox.switcher
com.sec.location.nsflp2
com.sec.mldapchecker
com.sec.modem.settings
com.sec.penup
com.sec.providers.assisteddialing
com.sec.readershub
com.sec.smartcard.manager
com.sec.spen.flashannotate
com.sec.spp.push
com.sec.sve
com.sec.usbsettings
com.sec.vowifispg
com.sec.yosemite.phone
com.sem.factoryapp
com.singtel.mysingtel
com.skms.android.agent
com.skype.raider
com.spotify.music
com.srin.indramayu
com.test.LTEfunctionality
com.touchtype.swiftkey
com.tripadvisor.tripadvisor
com.trustonic.tuiservice
com.tv.peel.samsung.app
com.vlingo.midas
com.wssnps
com.yelp.android.samsungedge
EOF
}

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --install)
                install_systemwide
                ;;
            --version|-v)
                echo "droidB version $VERSION"
                exit 0
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            --device|-d)
                shift
                SERIAL="$1"
                ;;
            *)
                echo -e "${RED}Unknown option: $1${ENDC}"
                show_help
                exit 1
                ;;
        esac
        shift
    done
}

show_help() {
    cat << EOF
${BOLD}${BLUE}droidB v$VERSION${ENDC}

${BOLD}USAGE:${ENDC}
    $SCRIPT_NAME [OPTIONS]

${BOLD}OPTIONS:${ENDC}
    --install           Install droidB system-wide
    --version, -v       Show version information
    --help, -h          Show this help message
    --device, -d        Specify device serial

${BOLD}FEATURES:${ENDC}
    â€¢ Universal Debloater (300+ bloatware packages)
    â€¢ Samsung firmware flashing (Odin4 + Heimdall)
    â€¢ Fastboot operations (flash, unlock, boot)
    â€¢ Full ADB automation
    â€¢ Drag & drop file operations
    â€¢ Device backup/restore
    â€¢ Security-focused design

${BOLD}EXAMPLES:${ENDC}
    $SCRIPT_NAME
    $SCRIPT_NAME --install
    $SCRIPT_NAME --device SERIAL

${BOLD}AUTHOR:${ENDC}
    0xbv1 | 0xb0rn3
    https://github.com/0xb0rn3/droidB

EOF
}

clear_screen() {
    command -v clear &>/dev/null && clear || printf '\033[2J\033[H'
    echo -ne "\033]0;droidB v$VERSION\007"
}

display_banner() {
    clear_screen
    echo -e "${CYAN}"
    cat << 'EOF'
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                                          â•‘
    â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—        â•‘
    â•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—       â•‘
    â•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•       â•‘
    â•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—       â•‘
    â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•       â•‘
    â•‘     â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•        â•‘
    â•‘                                                          â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo -e "${ENDC}"
    echo -e "${BOLD}${BLUE}    Advanced Android Device Manager v${VERSION}${ENDC}"
    echo -e "${GREEN}    Universal Debloater | Samsung Tools | Security-Focused${ENDC}"
    echo -e "${MAGENTA}    Developer: ${BOLD}0xbv1 | 0xb0rn3${ENDC}"
    echo -e "${YELLOW}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"
}

process_path() {
    local input="$1"
    input="${input#\'}"
    input="${input%\'}"
    input="${input#\"}"
    input="${input%\"}"
    input="${input//\\ / }"
    input="${input/#\~/$HOME}"
    echo "$input"
}

confirm_action() {
    local prompt="$1"
    read -p "${BOLD}${YELLOW}$prompt (y/N): ${ENDC}" response
    [[ "$response" =~ ^[Yy]$ ]]
}

get_device_info() {
    DEVICES=$($ADB devices 2>/dev/null | tail -n +2 | grep -v "^$" | grep "device$")
    
    if [[ -z "$DEVICES" ]]; then
        DEVICE_INFO=""
        return 1
    fi
    
    DEVICE_COUNT=$(echo "$DEVICES" | wc -l)
    
    if [[ $DEVICE_COUNT -gt 1 ]]; then
        echo -e "${GREEN}Multiple devices connected:${ENDC}"
        echo "$DEVICES" | nl -w 2 -s '. '
        read -p "Select device (number): " CHOICE
        SERIAL=$(echo "$DEVICES" | sed -n "${CHOICE}p" | awk '{print $1}')
    else
        SERIAL=$(echo "$DEVICES" | awk '{print $1}')
    fi
    
    STATE=$($ADB devices | grep $SERIAL | awk '{print $2}')
    
    if [[ "$STATE" == "unauthorized" ]]; then
        echo -e "${RED}Device unauthorized. Check device screen${ENDC}"
        DEVICE_INFO="serial=$SERIAL state=$STATE"
        return 1
    fi
    
    MODEL=$($ADB -s $SERIAL shell getprop ro.product.model 2>/dev/null | tr -d '\r')
    ANDROID_VERSION=$($ADB -s $SERIAL shell getprop ro.build.version.release 2>/dev/null | tr -d '\r')
    MANUFACTURER=$($ADB -s $SERIAL shell getprop ro.product.manufacturer 2>/dev/null | tr -d '\r')
    
    DEVICE_INFO="serial=$SERIAL model=$MODEL android_version=$ANDROID_VERSION manufacturer=$MANUFACTURER state=$STATE"
    
    return 0
}

universal_debloater_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${MAGENTA}ğŸ—‘ï¸  UNIVERSAL DEBLOATER${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        if [[ -z "$SERIAL" ]]; then
            echo -e "${RED}No device connected${ENDC}"
            read -p "Press Enter to return..."
            return
        fi
        
        echo -e "${GREEN}Device: $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+' || echo 'Unknown')${ENDC}"
        echo -e "${CYAN}Serial: $SERIAL${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        local app_count=$(grep -cv "^$\|^#" "$DEBLOAT_LIST_FILE" 2>/dev/null || echo "0")
        echo -e "${BOLD}Embedded bloatware list: ${GREEN}$app_count packages${ENDC}"
        
        echo ""
        echo "1. Debloat with embedded list (recommended)"
        echo "2. Debloat with custom list file"
        echo "3. Preview embedded debloat list"
        echo "4. Selective debloat (choose apps)"
        echo "5. Scan device for bloatware"
        echo "6. Revert/Restore debloated apps"
        echo "7. Create backup before debloat"
        echo "8. Export embedded list to file"
        echo "9. Back to main menu"
        echo ""
        
        read -p "Select option: " choice
        
        case $choice in
            1) debloat_with_embedded_list ;;
            2) debloat_with_custom_list ;;
            3) preview_debloat_list ;;
            4) selective_debloat ;;
            5) scan_for_bloatware ;;
            6) revert_debloat ;;
            7) backup_before_debloat ;;
            8) export_embedded_list ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

debloat_with_embedded_list() {
    clear_screen
    echo -e "${BOLD}${RED}âš ï¸  DEBLOAT WITH EMBEDDED LIST âš ï¸${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    local app_count=$(grep -cv "^$\|^#" "$DEBLOAT_LIST_FILE")
    echo -e "${WHITE}This will remove ${GREEN}$app_count${WHITE} bloatware packages from your device.${ENDC}"
    echo -e "${YELLOW}These apps will be uninstalled for the current user (data preserved).${ENDC}"
    echo -e "${CYAN}You can restore them later using the revert function.${ENDC}"
    echo ""
    echo -e "${RED}WARNING: Some apps may be needed for certain features.${ENDC}"
    echo -e "${RED}This action cannot be easily undone and may affect device functionality.${ENDC}"
    echo ""
    
    confirm_action "Proceed with debloat?" || return
    
    echo ""
    echo -e "${BLUE}Starting debloat process...${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    local success_count=0
    local fail_count=0
    local not_found_count=0
    
    mapfile -t packages < "$DEBLOAT_LIST_FILE"
    
    for package in "${packages[@]}"; do
        [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
        
        package=$(echo "$package" | xargs | tr -d '\r\n')
        
        [[ -z "$package" ]] && continue
        
        echo -ne "${CYAN}Removing: ${WHITE}$package${ENDC}..."
        
        if $ADB -s $SERIAL shell pm list packages 2>/dev/null | grep -q "^package:$package$"; then
            local result=$($ADB -s $SERIAL shell pm uninstall -k --user 0 "$package" 2>/dev/null)
            if echo "$result" | grep -q "Success"; then
                echo -e " ${GREEN}[SUCCESS]${ENDC}"
                ((success_count++))
            else
                echo -e " ${RED}[FAILED]${ENDC}"
                ((fail_count++))
            fi
        else
            echo -e " ${YELLOW}[NOT FOUND]${ENDC}"
            ((not_found_count++))
        fi
    done
    
    echo ""
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    echo -e "${BOLD}${GREEN}Debloat Summary:${ENDC}"
    echo -e "${GREEN}  âœ“ Successfully removed: $success_count packages${ENDC}"
    echo -e "${RED}  âœ— Failed to remove: $fail_count packages${ENDC}"
    echo -e "${YELLOW}  - Not found on device: $not_found_count packages${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    echo -e "${WHITE}Debloat process completed!${ENDC}"
    
    echo ""
    read -p "Reboot device now? (y/N): " reboot_choice
    if [[ "$reboot_choice" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Rebooting device...${ENDC}"
        $ADB -s $SERIAL reboot
        echo -e "${GREEN}Reboot command sent${ENDC}"
    fi
    
    read -p "Press Enter to continue..."
}

debloat_with_custom_list() {
    clear_screen
    echo -e "${BOLD}${CYAN}DEBLOAT WITH CUSTOM LIST${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo -e "${WHITE}Drag & drop your custom debloat list file:${ENDC}"
    echo -e "${CYAN}Format: One package name per line, # for comments${ENDC}"
    echo ""
    
    read -p "File path: " custom_file
    custom_file=$(process_path "$custom_file")
    
    if [[ ! -f "$custom_file" ]]; then
        echo -e "${RED}File not found: $custom_file${ENDC}"
        sleep 2
        return
    fi
    
    local app_count=$(grep -cv "^$\|^#" "$custom_file")
    echo ""
    echo -e "${GREEN}Found $app_count packages in custom list${ENDC}"
    echo ""
    
    confirm_action "Proceed with custom debloat?" || return
    
    echo ""
    echo -e "${BLUE}Starting custom debloat process...${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    local success_count=0
    local fail_count=0
    local not_found_count=0
    
    mapfile -t packages < "$custom_file"
    
    for package in "${packages[@]}"; do
        [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
        
        package=$(echo "$package" | xargs | tr -d '\r\n')
        
        [[ -z "$package" ]] && continue
        
        echo -ne "${CYAN}Removing: ${WHITE}$package${ENDC}..."
        
        if $ADB -s $SERIAL shell pm list packages 2>/dev/null | grep -q "^package:$package$"; then
            local result=$($ADB -s $SERIAL shell pm uninstall -k --user 0 "$package" 2>/dev/null)
            if echo "$result" | grep -q "Success"; then
                echo -e " ${GREEN}[SUCCESS]${ENDC}"
                ((success_count++))
            else
                echo -e " ${RED}[FAILED]${ENDC}"
                ((fail_count++))
            fi
        else
            echo -e " ${YELLOW}[NOT FOUND]${ENDC}"
            ((not_found_count++))
        fi
    done
    
    echo ""
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    echo -e "${GREEN}Successfully removed: $success_count${ENDC}"
    echo -e "${RED}Failed: $fail_count${ENDC}"
    echo -e "${YELLOW}Not found: $not_found_count${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    read -p "Press Enter..."
}

preview_debloat_list() {
    clear_screen
    echo -e "${BOLD}${CYAN}EMBEDDED DEBLOAT LIST PREVIEW${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    cat "$DEBLOAT_LIST_FILE" | less
    
    read -p "Press Enter to continue..."
}

selective_debloat() {
    clear_screen
    echo -e "${BOLD}${CYAN}SELECTIVE DEBLOAT${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo "1. Amazon bloatware"
    echo "2. Facebook apps"
    echo "3. Google apps"
    echo "4. Microsoft Office"
    echo "5. Samsung bloatware"
    echo "6. Bixby services"
    echo "7. Custom package names"
    echo ""
    
    read -p "Select category: " category
    
    local packages=""
    
    case $category in
        1) packages="com.amazon.fv com.amazon.kindle com.amazon.mp3 com.amazon.mShop.android com.amazon.venezia" ;;
        2) packages="com.facebook.appmanager com.facebook.katana com.facebook.services com.facebook.system" ;;
        3) packages="com.google.android.apps.docs com.google.android.apps.maps com.google.android.youtube com.google.android.apps.books" ;;
        4) packages="com.microsoft.office.excel com.microsoft.office.word com.microsoft.office.powerpoint com.microsoft.office.outlook" ;;
        5) packages="com.samsung.android.app.sbrowseredge com.samsung.android.tvplus com.samsung.android.calendar" ;;
        6) packages="com.samsung.android.bixby.agent com.samsung.android.bixby.service com.samsung.android.bixby.wakeup com.samsung.android.bixbyvision.framework" ;;
        7)
            echo ""
            echo -e "${WHITE}Enter package names (space separated):${ENDC}"
            read -p "> " packages
            ;;
        *) echo -e "${RED}Invalid option${ENDC}"; sleep 1; return ;;
    esac
    
    [[ -z "$packages" ]] && return
    
    echo ""
    for pkg in $packages; do
        echo -ne "${CYAN}Removing: ${WHITE}$pkg${ENDC}..."
        local result=$($ADB -s $SERIAL shell pm uninstall -k --user 0 "$pkg" 2>/dev/null)
        if echo "$result" | grep -q "Success"; then
            echo -e " ${GREEN}[SUCCESS]${ENDC}"
        else
            echo -e " ${RED}[FAILED]${ENDC}"
        fi
    done
    
    read -p "Press Enter..."
}

scan_for_bloatware() {
    clear_screen
    echo -e "${BOLD}${CYAN}SCAN DEVICE FOR BLOATWARE${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo -e "${BLUE}Scanning device...${ENDC}"
    echo ""
    
    local found_count=0
    
    mapfile -t packages < "$DEBLOAT_LIST_FILE"
    
    for package in "${packages[@]}"; do
        [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
        
        package=$(echo "$package" | xargs | tr -d '\r\n')
        
        [[ -z "$package" ]] && continue
        
        if $ADB -s $SERIAL shell pm list packages 2>/dev/null | grep -q "^package:$package$"; then
            echo -e "${RED}[FOUND]${ENDC} $package"
            ((found_count++))
        fi
    done
    
    echo ""
    echo -e "${RED}Found $found_count bloatware packages on device${ENDC}"
    
    read -p "Press Enter..."
}

revert_debloat() {
    clear_screen
    echo -e "${BOLD}${GREEN}REVERT/RESTORE DEBLOATED APPS${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo "1. Restore all apps from embedded list"
    echo "2. Restore specific packages"
    echo "3. Back"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1)
            confirm_action "Restore all packages?" || return
            
            echo ""
            echo -e "${BLUE}Starting restore process...${ENDC}"
            echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
            
            local success_count=0
            local fail_count=0
            
            mapfile -t packages < "$DEBLOAT_LIST_FILE"
            
            for package in "${packages[@]}"; do
                [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
                
                package=$(echo "$package" | xargs | tr -d '\r\n')
                
                [[ -z "$package" ]] && continue
                
                echo -ne "${CYAN}Restoring: ${WHITE}$package${ENDC}..."
                
                local result=$($ADB -s $SERIAL shell cmd package install-existing "$package" 2>&1)
                if echo "$result" | grep -q "Package .* installed for user"; then
                    echo -e " ${GREEN}[SUCCESS]${ENDC}"
                    ((success_count++))
                else
                    echo -e " ${RED}[FAILED]${ENDC}"
                    ((fail_count++))
                fi
            done
            
            echo ""
            echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
            echo -e "${GREEN}Restored: $success_count${ENDC} | ${RED}Failed: $fail_count${ENDC}"
            echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
            ;;
        2)
            echo ""
            echo -e "${WHITE}Enter package names (space separated):${ENDC}"
            read -p "> " packages
            
            echo ""
            for package in $packages; do
                echo -ne "${CYAN}Restoring: ${WHITE}$package${ENDC}..."
                local result=$($ADB -s $SERIAL shell cmd package install-existing "$package" 2>&1)
                if echo "$result" | grep -q "Package .* installed for user"; then
                    echo -e " ${GREEN}[SUCCESS]${ENDC}"
                else
                    echo -e " ${RED}[FAILED]${ENDC}"
                fi
            done
            ;;
    esac
    
    read -p "Press Enter..."
}

backup_before_debloat() {
    clear_screen
    echo -e "${BOLD}${CYAN}BACKUP PACKAGE LIST${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    local backup_file="debloat_backup_$(date +%Y%m%d_%H%M%S).txt"
    
    echo "# droidB Backup - $(date)" > "$backup_file"
    echo "# Device: $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+')" >> "$backup_file"
    echo "# Serial: $SERIAL" >> "$backup_file"
    echo "" >> "$backup_file"
    $ADB -s $SERIAL shell pm list packages | sed 's/package://' >> "$backup_file"
    
    echo ""
    echo -e "${GREEN}âœ“ Backup saved: $backup_file${ENDC}"
    echo -e "${CYAN}Total packages: $(grep -cv "^$\|^#" "$backup_file")${ENDC}"
    
    read -p "Press Enter..."
}

export_embedded_list() {
    clear_screen
    echo -e "${BOLD}${CYAN}EXPORT EMBEDDED LIST${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    local export_file="droidb_debloat_list_$(date +%Y%m%d).txt"
    
    cp "$DEBLOAT_LIST_FILE" "$export_file"
    
    echo ""
    echo -e "${GREEN}âœ“ List exported to: $export_file${ENDC}"
    echo -e "${CYAN}Location: $(pwd)/$export_file${ENDC}"
    
    read -p "Press Enter..."
}

check_samsung_tools() {
    if command -v odin4 &>/dev/null; then
        ODIN4_INSTALLED=true
        echo -e "${GREEN}âœ“ Odin4: Installed${ENDC}"
    else
        echo -e "${YELLOW}âš  Odin4: Not installed${ENDC}"
    fi
    
    if command -v heimdall &>/dev/null; then
        HEIMDALL_INSTALLED=true
        echo -e "${GREEN}âœ“ Heimdall: Installed${ENDC}"
    else
        echo -e "${YELLOW}âš  Heimdall: Not installed${ENDC}"
    fi
}

setup_samsung_udev_rules() {
    local RULES_FILE="/etc/udev/rules.d/51-samsung.rules"
    
    if [[ ! -f "$RULES_FILE" ]]; then
        echo -e "${BLUE}Setting up Samsung USB rules...${ENDC}"
        
        cat << 'EOF' | sudo tee "$RULES_FILE" > /dev/null
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", MODE="0666", GROUP="plugdev"
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="6860", MODE="0666", GROUP="plugdev"
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="68??", MODE="0666", GROUP="plugdev"
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="685d", MODE="0666", GROUP="plugdev"
EOF
        
        sudo udevadm control --reload-rules
        sudo udevadm trigger
        sudo usermod -a -G plugdev $USER 2>/dev/null
        
        echo -e "${GREEN}âœ“ Samsung USB rules configured${ENDC}"
        echo -e "${YELLOW}You may need to log out and log back in for group changes to take effect${ENDC}"
    fi
}

install_odin4_auto() {
    if [[ "$OSTYPE" != "linux-gnu"* ]]; then
        echo -e "${YELLOW}Odin4 is only available for Linux.${ENDC}"
        return 1
    fi
    
    if command -v odin4 &>/dev/null; then
        echo -e "${GREEN}Odin4 already installed.${ENDC}"
        ODIN4_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Odin4 for Linux...${ENDC}"
    
    if command -v yay &>/dev/null; then
        echo -e "${BLUE}Installing via AUR (yay)...${ENDC}"
        yay -S --noconfirm odin4-cli 2>/dev/null && ODIN4_INSTALLED=true
    elif command -v paru &>/dev/null; then
        echo -e "${BLUE}Installing via AUR (paru)...${ENDC}"
        paru -S --noconfirm odin4-cli 2>/dev/null && ODIN4_INSTALLED=true
    else
        echo -e "${BLUE}Downloading Odin4 from GitHub...${ENDC}"
        ODIN_URL="https://github.com/Adrilaw/OdinV4/releases/download/v1.0/odin.zip"
        TEMP_DIR=$(mktemp -d)
        
        if wget -q "$ODIN_URL" -O "$TEMP_DIR/odin.zip"; then
            cd "$TEMP_DIR"
            unzip -q odin.zip
            
            if [[ -f "odin4" ]]; then
                chmod +x odin4
                sudo mv odin4 /usr/local/bin/
                ODIN4_INSTALLED=true
                echo -e "${GREEN}Odin4 installed successfully${ENDC}"
            else
                echo -e "${RED}Odin4 binary not found in archive${ENDC}"
            fi
            
            cd - >/dev/null
            rm -rf "$TEMP_DIR"
        else
            echo -e "${RED}Failed to download Odin4${ENDC}"
        fi
    fi
    
    setup_samsung_udev_rules
    
    return $([[ $ODIN4_INSTALLED == true ]] && echo 0 || echo 1)
}

install_heimdall() {
    if command -v heimdall &>/dev/null; then
        echo -e "${GREEN}Heimdall already installed.${ENDC}"
        HEIMDALL_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Heimdall...${ENDC}"
    
    if [[ -f /etc/debian_version ]]; then
        sudo apt update && sudo apt install -y heimdall-flash
    elif [[ -f /etc/arch-release ]]; then
        sudo pacman -S --noconfirm heimdall
    elif [[ -f /etc/redhat-release ]]; then
        sudo dnf install -y heimdall
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        command -v brew &>/dev/null && brew install heimdall
    else
        echo -e "${RED}Unsupported OS for automatic Heimdall installation${ENDC}"
        return 1
    fi
    
    command -v heimdall &>/dev/null && HEIMDALL_INSTALLED=true
}

samsung_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${MAGENTA}ğŸ“± SAMSUNG OPERATIONS${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        echo -e "${CYAN}Tool Status:${ENDC}"
        echo -e "  Odin4:    $([[ $ODIN4_INSTALLED == true ]] && echo "${GREEN}âœ“ Installed${ENDC}" || echo "${RED}âœ— Not Installed${ENDC}")"
        echo -e "  Heimdall: $([[ $HEIMDALL_INSTALLED == true ]] && echo "${GREEN}âœ“ Installed${ENDC}" || echo "${RED}âœ— Not Installed${ENDC}")"
        echo ""
        
        if [[ $ODIN4_INSTALLED == false && $HEIMDALL_INSTALLED == false ]]; then
            echo -e "${RED}No Samsung tools installed${ENDC}"
            echo ""
            echo "1. Install Odin4 (Linux only)"
            echo "2. Install Heimdall"
            echo "3. Setup Samsung USB rules"
            echo "4. Back to main menu"
            echo ""
            
            read -p "Select: " opt
            case $opt in
                1) install_odin4_auto; read -p "Press Enter..." ;;
                2) install_heimdall; read -p "Press Enter..." ;;
                3) setup_samsung_udev_rules; read -p "Press Enter..." ;;
                4) return ;;
            esac
        else
            echo "1. Flash firmware with Odin4 (BL/AP/CP/CSC)"
            echo "2. Flash single partition with Odin4"
            echo "3. Flash with Heimdall"
            echo "4. Check download mode"
            echo "5. PIT file operations"
            echo "6. Heimdall print partition table"
            echo "7. Odin4 list devices"
            echo "8. Install/Update Samsung tools"
            echo "9. Back to main menu"
            echo ""
            
            read -p "Select: " opt
            
            case $opt in
                1) samsung_flash_firmware ;;
                2) samsung_flash_single ;;
                3) samsung_flash_heimdall ;;
                4) check_download_mode ;;
                5) pit_operations ;;
                6) heimdall_print_partition ;;
                7) odin4_list_devices ;;
                8) samsung_tools_menu ;;
                9) return ;;
            esac
        fi
    done
}

samsung_flash_firmware() {
    clear_screen
    echo -e "${BOLD}${MAGENTA}SAMSUNG FIRMWARE FLASH (Odin4)${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    # â”€â”€ Pre-flash backup check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    pre_flash_backup_check || return
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    if [[ $ODIN4_INSTALLED == false ]]; then
        echo -e "${RED}Odin4 not installed${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo -e "${CYAN}Drag & drop .tar/.tar.md5 files or type paths${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo -e "\n${BOLD}Firmware Files:${ENDC}"
    
    echo -e "${BLUE}BL (Bootloader) - optional:${ENDC}"
    read -p "Path: " BL_FILE
    BL_FILE=$(process_path "$BL_FILE")
    
    echo -e "${BLUE}AP (System/PDA) - required:${ENDC}"
    read -p "Path: " AP_FILE
    AP_FILE=$(process_path "$AP_FILE")
    
    echo -e "${BLUE}CP (Modem) - optional:${ENDC}"
    read -p "Path: " CP_FILE
    CP_FILE=$(process_path "$CP_FILE")
    
    echo -e "${BLUE}CSC (Region) - optional:${ENDC}"
    read -p "Path: " CSC_FILE
    CSC_FILE=$(process_path "$CSC_FILE")
    
    echo -e "${BLUE}HOME_CSC (Keep Data) - optional:${ENDC}"
    read -p "Path (use instead of CSC to keep data): " HOME_CSC_FILE
    HOME_CSC_FILE=$(process_path "$HOME_CSC_FILE")
    
    if [[ -z "$AP_FILE" || ! -f "$AP_FILE" ]]; then
        echo -e "${RED}AP file is required for flashing${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    local ODIN_CMD="sudo odin4"
    
    [[ -n "$BL_FILE" && -f "$BL_FILE" ]] && ODIN_CMD="$ODIN_CMD -b \"$BL_FILE\""
    [[ -n "$AP_FILE" && -f "$AP_FILE" ]] && ODIN_CMD="$ODIN_CMD -a \"$AP_FILE\""
    [[ -n "$CP_FILE" && -f "$CP_FILE" ]] && ODIN_CMD="$ODIN_CMD -c \"$CP_FILE\""
    
    if [[ -n "$HOME_CSC_FILE" && -f "$HOME_CSC_FILE" ]]; then
        ODIN_CMD="$ODIN_CMD -s \"$HOME_CSC_FILE\""
    elif [[ -n "$CSC_FILE" && -f "$CSC_FILE" ]]; then
        ODIN_CMD="$ODIN_CMD -s \"$CSC_FILE\""
    fi
    
    echo -e "\n${BOLD}${YELLOW}Flash Summary:${ENDC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    [[ -n "$BL_FILE" && -f "$BL_FILE" ]] && echo -e "BL: ${GREEN}$(basename "$BL_FILE")${ENDC}"
    [[ -n "$AP_FILE" && -f "$AP_FILE" ]] && echo -e "AP: ${GREEN}$(basename "$AP_FILE")${ENDC}"
    [[ -n "$CP_FILE" && -f "$CP_FILE" ]] && echo -e "CP: ${GREEN}$(basename "$CP_FILE")${ENDC}"
    [[ -n "$CSC_FILE" && -f "$CSC_FILE" ]] && echo -e "CSC: ${GREEN}$(basename "$CSC_FILE")${ENDC}"
    [[ -n "$HOME_CSC_FILE" && -f "$HOME_CSC_FILE" ]] && echo -e "HOME_CSC: ${GREEN}$(basename "$HOME_CSC_FILE")${ENDC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    echo -e "\n${RED}${BOLD}âš ï¸  CRITICAL WARNING âš ï¸${ENDC}"
    echo -e "${RED}This will replace device firmware!${ENDC}"
    echo -e "${RED}Wrong firmware = BRICK${ENDC}"
    echo -e "${RED}Device must be in Download Mode${ENDC}"
    
    confirm_action "Proceed with firmware flash?" || return
    
    echo -e "\n${BLUE}Executing: $ODIN_CMD${ENDC}"
    eval $ODIN_CMD
    
    if [[ $? -eq 0 ]]; then
        echo -e "\n${GREEN}${BOLD}âœ“ Flash completed successfully!${ENDC}"
    else
        echo -e "\n${RED}${BOLD}âœ— Flash failed! Check device and try again.${ENDC}"
    fi
    
    read -p "Press Enter to continue..."
}

samsung_flash_single() {
    clear_screen
    echo -e "${BOLD}${MAGENTA}FLASH SINGLE PARTITION${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    pre_flash_backup_check || return
    
    echo "Select partition type:"
    echo "1. BL (Bootloader)"
    echo "2. AP (System)"
    echo "3. CP (Modem)"
    echo "4. CSC (Region)"
    echo ""
    
    read -p "Select: " part_type
    
    echo -e "\n${YELLOW}Drag & drop file:${ENDC}"
    read -p "File path: " FILE
    FILE=$(process_path "$FILE")
    
    if [[ ! -f "$FILE" ]]; then
        echo -e "${RED}File not found${ENDC}"
        sleep 2
        return
    fi
    
    confirm_action "Flash $(basename "$FILE")?" || return
    
    case $part_type in
        1) sudo odin4 -b "$FILE" ;;
        2) sudo odin4 -a "$FILE" ;;
        3) sudo odin4 -c "$FILE" ;;
        4) sudo odin4 -s "$FILE" ;;
        *) echo -e "${RED}Invalid option${ENDC}"; sleep 2; return ;;
    esac
    
    read -p "Press Enter..."
}

samsung_flash_heimdall() {
    clear_screen
    echo -e "${BOLD}${MAGENTA}FLASH WITH HEIMDALL${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    pre_flash_backup_check || return
    
    if [[ $HEIMDALL_INSTALLED == false ]]; then
        echo -e "${RED}Heimdall not installed${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo "1. Flash recovery"
    echo "2. Flash kernel (boot)"
    echo "3. Flash system"
    echo "4. Flash cache"
    echo "5. Flash userdata"
    echo "6. Custom partition"
    echo ""
    
    read -p "Select: " opt
    
    echo -e "\n${YELLOW}Drag & drop image file:${ENDC}"
    read -p "File path: " FILE
    FILE=$(process_path "$FILE")
    
    if [[ ! -f "$FILE" ]]; then
        echo -e "${RED}File not found${ENDC}"
        sleep 2
        return
    fi
    
    confirm_action "Flash with Heimdall?" || return
    
    case $opt in
        1) sudo heimdall flash --RECOVERY "$FILE" --no-reboot ;;
        2) sudo heimdall flash --KERNEL "$FILE" --no-reboot ;;
        3) sudo heimdall flash --SYSTEM "$FILE" --no-reboot ;;
        4) sudo heimdall flash --CACHE "$FILE" --no-reboot ;;
        5) sudo heimdall flash --USERDATA "$FILE" --no-reboot ;;
        6)
            read -p "Partition name (uppercase, e.g. BOOT): " PART
            sudo heimdall flash --$PART "$FILE" --no-reboot
            ;;
    esac
    
    if [[ $? -eq 0 ]]; then
        echo -e "\n${GREEN}Flash completed successfully${ENDC}"
        read -p "Reboot device now? (y/N): " reboot_choice
        if [[ "$reboot_choice" =~ ^[Yy]$ ]]; then
            sudo heimdall reboot
        fi
    fi
    
    read -p "Press Enter..."
}

check_download_mode() {
    clear_screen
    echo -e "${BOLD}${CYAN}CHECK SAMSUNG DOWNLOAD MODE${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo -e "${BLUE}Checking for Samsung devices...${ENDC}"
    echo ""
    
    lsusb | grep "04e8:" && echo -e "\n${GREEN}Samsung device detected${ENDC}" || echo -e "\n${RED}No Samsung devices found${ENDC}"
    
    echo ""
    if [[ $ODIN4_INSTALLED == true ]]; then
        echo -e "${BLUE}Odin4 device list:${ENDC}"
        sudo odin4 -l 2>/dev/null || echo -e "${YELLOW}No devices in download mode${ENDC}"
    fi
    
    if [[ $HEIMDALL_INSTALLED == true ]]; then
        echo ""
        echo -e "${BLUE}Heimdall device detection:${ENDC}"
        sudo heimdall detect 2>/dev/null || echo -e "${YELLOW}No devices detected${ENDC}"
    fi
    
    echo ""
    echo -e "${CYAN}To enter Download Mode:${ENDC}"
    echo "  1. Power off device"
    echo "  2. Hold Volume Down + Power"
    echo "  3. Press Volume Up to confirm"
    read -p "Press Enter..."
}

pit_operations() {
    clear_screen
    echo -e "${BOLD}${CYAN}PIT FILE OPERATIONS${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    if [[ $HEIMDALL_INSTALLED == false ]]; then
        echo -e "${RED}Heimdall required for PIT operations${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo "1. Download PIT from device"
    echo "2. Print PIT info"
    echo "3. Flash with PIT (Odin4)"
    echo "4. Back"
    echo ""
    
    read -p "Select: " opt
    
    case $opt in
        1)
            read -p "Output filename (e.g., device.pit): " PIT_FILE
            PIT_FILE=${PIT_FILE:-device.pit}
            sudo heimdall download-pit --output "$PIT_FILE"
            [[ -f "$PIT_FILE" ]] && echo -e "${GREEN}âœ“ PIT saved: $PIT_FILE${ENDC}"
            ;;
        2)
            sudo heimdall print-pit
            ;;
        3)
            if [[ $ODIN4_INSTALLED == false ]]; then
                echo -e "${RED}Odin4 not installed${ENDC}"
            else
                read -p "PIT file path: " PIT
                PIT=$(process_path "$PIT")
                [[ -f "$PIT" ]] && sudo odin4 --pit "$PIT"
            fi
            ;;
    esac
    
    [[ $opt != 4 ]] && read -p "Press Enter..."
}

heimdall_print_partition() {
    clear_screen
    echo -e "${BOLD}${CYAN}HEIMDALL PARTITION TABLE${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    if [[ $HEIMDALL_INSTALLED == false ]]; then
        echo -e "${RED}Heimdall not installed${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo -e "${BLUE}Printing partition table...${ENDC}"
    echo ""
    
    sudo heimdall print-pit
    
    read -p "Press Enter..."
}

odin4_list_devices() {
    clear_screen
    echo -e "${BOLD}${CYAN}ODIN4 DEVICE LIST${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    if [[ $ODIN4_INSTALLED == false ]]; then
        echo -e "${RED}Odin4 not installed${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo -e "${BLUE}Listing devices...${ENDC}"
    echo ""
    
    sudo odin4 -l 2>/dev/null || echo -e "${YELLOW}No devices found${ENDC}"
    
    read -p "Press Enter..."
}

samsung_tools_menu() {
    clear_screen
    echo -e "${BOLD}${CYAN}SAMSUNG TOOLS INSTALLATION${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo "1. Install Odin4"
    echo "2. Install Heimdall"
    echo "3. Setup USB rules"
    echo "4. Back"
    echo ""
    
    read -p "Select: " opt
    
    case $opt in
        1) install_odin4_auto ;;
        2) install_heimdall ;;
        3) setup_samsung_udev_rules ;;
    esac
    
    [[ $opt != 4 ]] && read -p "Press Enter..."
}

display_device_info() {
    clear_screen
    echo -e "${BOLD}${CYAN}ğŸ“± DEVICE INFORMATION${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    if [[ -z "$DEVICE_INFO" ]]; then
        echo -e "${RED}No device information available${ENDC}"
    else
        echo -e "${GREEN}Serial:${ENDC}           $(echo $DEVICE_INFO | grep -oP 'serial=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}Manufacturer:${ENDC}     $(echo $DEVICE_INFO | grep -oP 'manufacturer=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}Model:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}Android Version:${ENDC}  $(echo $DEVICE_INFO | grep -oP 'android_version=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}State:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+' || echo 'N/A')"
        
        echo ""
        echo -e "${CYAN}Additional Properties:${ENDC}"
        
        BRAND=$($ADB -s $SERIAL shell getprop ro.product.brand 2>/dev/null | tr -d '\r')
        DEVICE=$($ADB -s $SERIAL shell getprop ro.product.device 2>/dev/null | tr -d '\r')
        SDK=$($ADB -s $SERIAL shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r')
        SECURITY_PATCH=$($ADB -s $SERIAL shell getprop ro.build.version.security_patch 2>/dev/null | tr -d '\r')
        
        [[ -n "$BRAND" ]] && echo -e "${GREEN}Brand:${ENDC}            $BRAND"
        [[ -n "$DEVICE" ]] && echo -e "${GREEN}Device:${ENDC}           $DEVICE"
        [[ -n "$SDK" ]] && echo -e "${GREEN}SDK Level:${ENDC}        $SDK"
        [[ -n "$SECURITY_PATCH" ]] && echo -e "${GREEN}Security Patch:${ENDC}   $SECURITY_PATCH"
    fi
    
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    read -p "Press Enter to continue..."
}

# ============================================================
#  PUSH APK AS SYSTEM APP  (tinkerer feature)
#  Requires root (su) â€” tested with Magisk / KernelSU
#  Includes: auto-permissions, privapp XML, APK signing
# ============================================================

# â”€â”€ Root helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_check_root() {
    local t
    t=$($ADB -s "$SERIAL" shell "su -c 'id' 2>/dev/null" | tr -d '\r')
    echo "$t" | grep -q "uid=0" && return 0
    t=$($ADB -s "$SERIAL" shell "id" 2>/dev/null | tr -d '\r')
    echo "$t" | grep -q "uid=0" && return 0
    return 1
}

# Run a command as root â€” wraps args in single-quoted su -c call
_su() { $ADB -s "$SERIAL" shell "su -c '$*' 2>/dev/null" 2>/dev/null | tr -d '\r'; }

_system_writable() {
    [[ "$(_su "touch /system/.droidb_test && rm /system/.droidb_test && echo yes")" == "yes" ]]
}

_remount_rw() {
    echo -e "  ${YELLOW}Remounting /system read-writeâ€¦${ENDC}"
    _su "magisk --mount-master" 2>/dev/null
    _su "mount -o rw,remount /system" 2>/dev/null
    _su "mount -o remount,rw \$(mount | grep ' /system ' | awk '{print \$1}') /system" 2>/dev/null
    if _system_writable; then
        echo -e "  ${GREEN}âœ“ /system is now writable${ENDC}"; return 0
    else
        echo -e "  ${RED}âœ— Could not remount /system rw â€” try Magisk OverlayFS or a custom recovery${ENDC}"
        return 1
    fi
}

_remount_ro() {
    _su "mount -o ro,remount /system" 2>/dev/null
    echo -e "  ${CYAN}â†© /system remounted read-only${ENDC}"
}

# â”€â”€ APK helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_pick_system_dir() {
    echo ""
    echo -e "  ${BOLD}Target directory on device:${ENDC}"
    echo "    1. /system/app          â€” standard system app"
    echo "    2. /system/priv-app     â€” privileged (signature-level perms, PM-protected)"
    echo "    3. /system/product/app  â€” product partition"
    echo "    4. Custom path"
    read -rp "  Choice [1-4, default=2]: " dir_choice
    case "${dir_choice:-2}" in
        1) SYS_TARGET="/system/app" ;;
        2) SYS_TARGET="/system/priv-app" ;;
        3) SYS_TARGET="/system/product/app" ;;
        4) read -rp "  Custom path: " SYS_TARGET ;;
        *) SYS_TARGET="/system/priv-app" ;;
    esac
    echo -e "  ${CYAN}Target: $SYS_TARGET${ENDC}"
}

_get_pkg_name() {
    local apk="$1" pkg=""
    if command -v aapt &>/dev/null; then
        pkg=$(aapt dump badging "$apk" 2>/dev/null | grep "^package:" | grep -oP "name='\K[^']+")
    elif command -v aapt2 &>/dev/null; then
        pkg=$(aapt2 dump badging "$apk" 2>/dev/null | grep "^package:" | grep -oP "name='\K[^']+")
    fi
    # Fallback: parse AndroidManifest.xml directly from the zip
    if [[ -z "$pkg" ]]; then
        pkg=$(unzip -p "$apk" AndroidManifest.xml 2>/dev/null \
            | strings | grep -oP 'com\.[a-zA-Z0-9._]+' | head -1)
    fi
    [[ -z "$pkg" ]] && pkg=$(basename "$apk" .apk)
    echo "$pkg"
}

_validate_apk() {
    local apk="$1"
    if ! unzip -l "$apk" 2>/dev/null | grep -q "META-INF/"; then
        echo -e "  ${RED}âœ— Not a valid signed APK (no META-INF)${ENDC}"; return 1
    fi
    return 0
}

# Extract all uses-permission entries declared in the APK
_get_apk_declared_perms() {
    local apk="$1"
    if command -v aapt &>/dev/null; then
        aapt dump permissions "$apk" 2>/dev/null \
            | grep "uses-permission:" \
            | grep -oP "name='\K[^']+"
    elif command -v aapt2 &>/dev/null; then
        aapt2 dump permissions "$apk" 2>/dev/null \
            | grep "uses-permission:" \
            | grep -oP "name='\K[^']+"
    else
        # Fallback: pull strings from manifest (less accurate but works without aapt)
        unzip -p "$apk" AndroidManifest.xml 2>/dev/null \
            | strings \
            | grep -E "android\.permission\.[A-Z_]+" \
            | sort -u
    fi
}

# â”€â”€ Permission system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# All dangerous / sensitive permission groups
declare -A _PERM_GROUPS=(
    [location]="android.permission.ACCESS_FINE_LOCATION android.permission.ACCESS_COARSE_LOCATION android.permission.ACCESS_BACKGROUND_LOCATION"
    [contacts]="android.permission.READ_CONTACTS android.permission.WRITE_CONTACTS android.permission.GET_ACCOUNTS"
    [camera]="android.permission.CAMERA"
    [microphone]="android.permission.RECORD_AUDIO"
    [storage]="android.permission.READ_EXTERNAL_STORAGE android.permission.WRITE_EXTERNAL_STORAGE android.permission.MANAGE_EXTERNAL_STORAGE android.permission.READ_MEDIA_IMAGES android.permission.READ_MEDIA_VIDEO android.permission.READ_MEDIA_AUDIO"
    [phone]="android.permission.READ_PHONE_STATE android.permission.CALL_PHONE android.permission.READ_CALL_LOG android.permission.WRITE_CALL_LOG android.permission.ADD_VOICEMAIL android.permission.USE_SIP"
    [sms]="android.permission.SEND_SMS android.permission.RECEIVE_SMS android.permission.READ_SMS android.permission.RECEIVE_WAP_PUSH android.permission.RECEIVE_MMS"
    [calendar]="android.permission.READ_CALENDAR android.permission.WRITE_CALENDAR"
    [sensors]="android.permission.BODY_SENSORS android.permission.ACTIVITY_RECOGNITION"
    [bluetooth]="android.permission.BLUETOOTH_SCAN android.permission.BLUETOOTH_CONNECT android.permission.BLUETOOTH_ADVERTISE"
    [notifications]="android.permission.POST_NOTIFICATIONS"
    [system_alert]="android.permission.SYSTEM_ALERT_WINDOW"
    [install_packages]="android.permission.REQUEST_INSTALL_PACKAGES android.permission.INSTALL_PACKAGES"
    [device_admin]="android.permission.BIND_DEVICE_ADMIN"
    [accessibility]="android.permission.BIND_ACCESSIBILITY_SERVICE"
)

# Preset profiles
declare -A _PERM_PRESETS=(
    [social]="location contacts camera microphone storage notifications"
    [dev_root]="location contacts camera microphone storage phone sms calendar sensors bluetooth notifications system_alert install_packages"
    [media]="camera microphone storage notifications"
    [full]="location contacts camera microphone storage phone sms calendar sensors bluetooth notifications system_alert install_packages device_admin accessibility"
)

_permission_profile_menu() {
    # Returns selected permissions in SELECTED_PERMS (space-separated android.permission.* list)
    SELECTED_PERMS=""
    local selected_groups=()

    echo ""
    echo -e "  ${BOLD}${CYAN}â”Œâ”€ Permission Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${ENDC}"
    echo -e "  ${BOLD}${CYAN}â”‚${ENDC}  Grant permissions without user prompts          ${BOLD}${CYAN}â”‚${ENDC}"
    echo -e "  ${BOLD}${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${ENDC}"
    echo ""
    echo "  Select permission strategy:"
    echo "    1. ğŸ“µ  None â€” keep app's own declared permissions only"
    echo "    2. ğŸ“±  Social Media preset (location, contacts, camera, mic, storage, notifications)"
    echo "    3. ğŸ›   Full Dev/Root preset (all dangerous permissions)"
    echo "    4. ğŸ¥  Media preset (camera, mic, storage, notifications)"
    echo "    5. ğŸ’£  GRANT ALL (every permission group â€” nuclear option)"
    echo "    6. ğŸ”§  Custom â€” pick groups manually"
    echo "    7. ğŸ“‹  Auto-detect from APK manifest"
    echo ""
    read -rp "  Choice [1-7, default=7]: " perm_choice

    case "${perm_choice:-7}" in
        1)
            echo -e "  ${CYAN}No extra permissions will be granted.${ENDC}"
            return 0
            ;;
        2) IFS=' ' read -ra selected_groups <<< "${_PERM_PRESETS[social]}" ;;
        3) IFS=' ' read -ra selected_groups <<< "${_PERM_PRESETS[dev_root]}" ;;
        4) IFS=' ' read -ra selected_groups <<< "${_PERM_PRESETS[media]}" ;;
        5) selected_groups=("${!_PERM_GROUPS[@]}") ;;
        6)
            echo ""
            echo -e "  ${BOLD}Available permission groups:${ENDC}"
            local i=1
            local group_order=(location contacts camera microphone storage phone sms calendar sensors bluetooth notifications system_alert install_packages device_admin accessibility)
            for g in "${group_order[@]}"; do
                printf "    %2d. %-20s  %s\n" "$i" "$g" "$(echo "${_PERM_GROUPS[$g]}" | awk '{print $1}')"
                i=$((i+1))
            done
            echo ""
            read -rp "  Enter numbers separated by spaces (e.g. 1 3 4): " group_nums
            for n in $group_nums; do
                local idx=$((n-1))
                [[ $idx -ge 0 && $idx -lt ${#group_order[@]} ]] && selected_groups+=("${group_order[$idx]}")
            done
            ;;
        7)
            echo -e "  ${CYAN}Reading APK manifest permissionsâ€¦${ENDC}"
            local declared_perms
            declared_perms=$(_get_apk_declared_perms "$_SIGNING_APK_PATH")
            if [[ -z "$declared_perms" ]]; then
                echo -e "  ${YELLOW}âš  No permissions found in manifest (aapt not available or none declared).${ENDC}"
                echo -e "  ${YELLOW}  Falling back to Social Media preset.${ENDC}"
                IFS=' ' read -ra selected_groups <<< "${_PERM_PRESETS[social]}"
            else
                echo -e "  ${GREEN}Found declared permissions:${ENDC}"
                echo "$declared_perms" | while IFS= read -r p; do
                    echo -e "    ${CYAN}+${ENDC} $p"
                done
                # Convert declared perms directly â€” no group mapping needed
                SELECTED_PERMS="$declared_perms"
                echo -e "  ${GREEN}âœ“ Will auto-grant all ${MAGENTA}$(echo "$declared_perms" | wc -l)${GREEN} declared permissions${ENDC}"
                return 0
            fi
            ;;
        *)
            echo -e "  ${YELLOW}Invalid choice, using Social Media preset.${ENDC}"
            IFS=' ' read -ra selected_groups <<< "${_PERM_PRESETS[social]}"
            ;;
    esac

    # Expand groups into individual permissions
    local perm_list=""
    for grp in "${selected_groups[@]}"; do
        if [[ -n "${_PERM_GROUPS[$grp]:-}" ]]; then
            perm_list="$perm_list ${_PERM_GROUPS[$grp]}"
        fi
    done
    SELECTED_PERMS=$(echo "$perm_list" | tr ' ' '\n' | sort -u | grep -v '^$')

    local cnt; cnt=$(echo "$SELECTED_PERMS" | grep -c "android\." || true)
    echo -e "  ${GREEN}âœ“ ${MAGENTA}$cnt${GREEN} permissions selected across groups: ${CYAN}${selected_groups[*]}${ENDC}"
}

# Grant all SELECTED_PERMS to a package via pm grant (root)
_grant_permissions() {
    local pkg="$1"
    [[ -z "$SELECTED_PERMS" ]] && return 0

    echo -e "\n  ${BOLD}${CYAN}Granting permissions to $pkgâ€¦${ENDC}"
    local granted=0 failed=0

    while IFS= read -r perm; do
        [[ -z "$perm" ]] && continue
        local result
        result=$(_su "pm grant '$pkg' '$perm' 2>&1")
        if [[ -z "$result" || "$result" == *"Exception"* ]]; then
            # Some perms fail silently on success; try to verify
            local check
            check=$(_su "dumpsys package '$pkg' 2>/dev/null | grep '$perm' | grep 'granted=true'")
            if [[ -n "$check" ]]; then
                printf "  ${GREEN}âœ“${ENDC} %-60s\n" "$perm"
                granted=$((granted+1))
            else
                printf "  ${YELLOW}~${ENDC} %-55s (install-time or not declared)\n" "$perm"
                failed=$((failed+1))
            fi
        else
            printf "  ${GREEN}âœ“${ENDC} %-60s\n" "$perm"
            granted=$((granted+1))
        fi
    done <<< "$SELECTED_PERMS"

    echo -e "\n  ${BOLD}Permissions granted: ${GREEN}$granted${ENDC}  Not applicable: ${YELLOW}$failed${ENDC}"
}

# Write /system/etc/permissions/<pkg>.xml for priv-app permission whitelist
_write_privapp_permissions_xml() {
    local pkg="$1"
    [[ -z "$SELECTED_PERMS" ]] && return 0
    [[ "$SYS_TARGET" != *"priv-app"* ]] && return 0   # only needed for priv-app

    local xml_path="/system/etc/permissions/privapp-permissions-${pkg}.xml"
    echo -e "  ${CYAN}Writing privapp permissions XML â†’ $xml_path${ENDC}"

    # Build XML content
    local xml_lines='<?xml version="1.0" encoding="utf-8"?>\n<permissions>\n'
    xml_lines+="    <privapp-permissions package=\"${pkg}\">\n"
    while IFS= read -r perm; do
        [[ -z "$perm" ]] && continue
        xml_lines+="        <permission name=\"${perm}\"/>\n"
    done <<< "$SELECTED_PERMS"
    xml_lines+='    </privapp-permissions>\n</permissions>'

    # Write via tmp
    printf '%b' "$xml_lines" > "/tmp/privapp-${pkg}.xml"
    $ADB -s "$SERIAL" push "/tmp/privapp-${pkg}.xml" "/data/local/tmp/privapp-${pkg}.xml" >/dev/null 2>&1
    _su "cp /data/local/tmp/privapp-${pkg}.xml '$xml_path'"
    _su "chown root:root '$xml_path'"
    _su "chmod 644 '$xml_path'"
    _su "chcon u:object_r:system_file:s0 '$xml_path'" 2>/dev/null
    rm -f "/tmp/privapp-${pkg}.xml"
    _su "rm /data/local/tmp/privapp-${pkg}.xml"

    local check; check=$(_su "[ -f '$xml_path' ] && echo ok")
    if [[ "$check" == "ok" ]]; then
        echo -e "  ${GREEN}âœ“ privapp-permissions XML written${ENDC}"
    else
        echo -e "  ${YELLOW}âš  privapp XML write failed (non-fatal â€” perms may still work)${ENDC}"
    fi
}

# Grant Magisk/KernelSU root access to a package
_grant_root_to_app() {
    local pkg="$1"
    echo -e "  ${CYAN}Attempting to grant root access to $pkgâ€¦${ENDC}"

    # Detect Magisk
    local magisk_db="/data/data/com.topjohnwu.magisk/databases/magisk.db"
    local magisk_db_alt="/data/user/0/com.topjohnwu.magisk/databases/magisk.db"
    local db_path=""

    for db in "$magisk_db" "$magisk_db_alt"; do
        if [[ "$(_su "[ -f '$db' ] && echo yes")" == "yes" ]]; then
            db_path="$db"; break
        fi
    done

    if [[ -n "$db_path" ]]; then
        # uid from pm: get uid of package
        local uid
        uid=$(_su "dumpsys package '$pkg' 2>/dev/null | grep 'userId=' | head -1 | grep -oE '[0-9]+'")
        if [[ -n "$uid" ]]; then
            _su "sqlite3 '$db_path' \"INSERT OR REPLACE INTO policies (uid,package_name,policy,until,logging,notification) VALUES($uid,'$pkg',2,0,1,1);\""
            echo -e "  ${GREEN}âœ“ Magisk root policy set for $pkg (uid=$uid)${ENDC}"
        else
            echo -e "  ${YELLOW}âš  Could not determine UID â€” grant manually in Magisk app${ENDC}"
        fi
        return
    fi

    # Detect KernelSU
    local ksu_db="/data/data/me.weishu.kernelsu/databases/permission.db"
    if [[ "$(_su "[ -f '$ksu_db' ] && echo yes")" == "yes" ]]; then
        local uid
        uid=$(_su "dumpsys package '$pkg' 2>/dev/null | grep 'userId=' | head -1 | grep -oE '[0-9]+'")
        if [[ -n "$uid" ]]; then
            _su "sqlite3 '$ksu_db' \"INSERT OR REPLACE INTO uid_policy (uid, allow_su, profile_id) VALUES($uid, 1, 0);\""
            echo -e "  ${GREEN}âœ“ KernelSU root policy set for $pkg (uid=$uid)${ENDC}"
        else
            echo -e "  ${YELLOW}âš  Could not determine UID â€” grant manually in KernelSU app${ENDC}"
        fi
        return
    fi

    echo -e "  ${YELLOW}âš  No Magisk or KernelSU database found â€” root grant skipped${ENDC}"
    echo -e "  ${YELLOW}  Grant root manually from your superuser manager after reboot${ENDC}"
}

# â”€â”€ Signing system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DROIDB_KEYSTORE_DIR="$HOME/.droidb/keystores"

# Ensure apksigner / jarsigner / keytool are available
_check_signing_tools() {
    local missing=()
    command -v keytool    &>/dev/null || missing+=("keytool (Java JDK)")
    command -v apksigner  &>/dev/null || \
        command -v jarsigner &>/dev/null || missing+=("apksigner or jarsigner")
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "  ${YELLOW}âš  Missing signing tools: ${missing[*]}${ENDC}"
        echo -e "  ${YELLOW}  Install with: sudo apt install default-jdk apksigner${ENDC}"
        return 1
    fi
    return 0
}

# Generate (or reuse) a persistent test keystore for a project/app
_get_or_create_keystore() {
    local pkg="$1"
    local ks_dir="$DROIDB_KEYSTORE_DIR/$pkg"
    local ks_file="$ks_dir/keystore.jks"
    local ks_pass="droidb_test_$(echo "$pkg" | md5sum | cut -c1-8)"
    local ks_alias="app_key"

    mkdir -p "$ks_dir"

    if [[ -f "$ks_file" ]]; then
        echo -e "  ${GREEN}âœ“ Reusing existing keystore: $ks_file${ENDC}"
    else
        echo -e "  ${CYAN}Generating new test keystore for $pkgâ€¦${ENDC}"
        keytool -genkeypair \
            -keystore "$ks_file" \
            -alias "$ks_alias" \
            -keyalg RSA \
            -keysize 2048 \
            -validity 9125 \
            -storepass "$ks_pass" \
            -keypass  "$ks_pass" \
            -dname "CN=$pkg, OU=droidB-tinkerer, O=droidB, L=Local, ST=Dev, C=US" \
            2>/dev/null \
            && echo -e "  ${GREEN}âœ“ Keystore created: $ks_file${ENDC}" \
            || { echo -e "  ${RED}âœ— keytool failed â€” Java JDK required${ENDC}"; return 1; }
    fi

    KS_FILE="$ks_file"
    KS_PASS="$ks_pass"
    KS_ALIAS="$ks_alias"
}

# Sign APK with auto-generated test key
_sign_apk_test_key() {
    local apk_in="$1"     # original APK
    local apk_out="$2"    # signed output
    local pkg="$3"

    _get_or_create_keystore "$pkg" || return 1

    # Remove existing signature (zipalign-safe copy first)
    local unsigned="${apk_out%.apk}-unsigned.apk"
    cp "$apk_in" "$unsigned"

    echo -e "  ${CYAN}Signing APK with test keyâ€¦${ENDC}"
    if command -v apksigner &>/dev/null; then
        apksigner sign \
            --ks "$KS_FILE" \
            --ks-pass "pass:$KS_PASS" \
            --ks-key-alias "$KS_ALIAS" \
            --out "$apk_out" \
            "$unsigned" 2>&1 | grep -v "^$" | sed 's/^/    /'
        local rc=${PIPESTATUS[0]}
    else
        # Fallback to jarsigner
        cp "$unsigned" "$apk_out"
        jarsigner \
            -keystore "$KS_FILE" \
            -storepass "$KS_PASS" \
            -keypass  "$KS_PASS" \
            "$apk_out" "$KS_ALIAS" 2>&1 | grep -v "^$" | sed 's/^/    /'
        local rc=${PIPESTATUS[0]}
    fi

    rm -f "$unsigned"

    if [[ $rc -eq 0 && -f "$apk_out" ]]; then
        echo -e "  ${GREEN}âœ“ APK signed â†’ $(basename "$apk_out")${ENDC}"
        echo -e "  ${CYAN}  Keystore: $KS_FILE${ENDC}"
        echo -e "  ${CYAN}  This key is PERSISTENT â€” all future builds of $pkg signed"
        echo -e "  ${CYAN}  with this keystore will be treated as the same app.${ENDC}"
        return 0
    else
        echo -e "  ${RED}âœ— Signing failed â€” using original unsigned APK${ENDC}"
        return 1
    fi
}

# Try to extract platform key from device (advanced â€” needs full root)
_extract_platform_key() {
    local out_dir="$DROIDB_KEYSTORE_DIR/platform_keys_${SERIAL}"
    mkdir -p "$out_dir"

    echo -e "  ${CYAN}Attempting to pull platform signing keys from deviceâ€¦${ENDC}"
    echo -e "  ${YELLOW}  This requires full root and is device-specific.${ENDC}"

    # Common platform key locations
    local key_paths=(
        "/system/framework/framework-res.apk"
        "/apex/com.android.runtime/etc/security/cacerts"
        "/data/misc/keystore"
    )

    # Pull framework-res.apk and extract its signing cert
    local fw_res="/tmp/droidb_fw_res_${SERIAL}.apk"
    $ADB -s "$SERIAL" pull "/system/framework/framework-res.apk" "$fw_res" >/dev/null 2>&1

    if [[ -f "$fw_res" ]]; then
        if command -v apksigner &>/dev/null; then
            apksigner verify --print-certs "$fw_res" 2>/dev/null \
                > "$out_dir/platform_cert_info.txt"
            echo -e "  ${GREEN}âœ“ Platform cert info saved â†’ $out_dir/platform_cert_info.txt${ENDC}"
            echo -e "  ${YELLOW}  Note: Signing with the actual platform private key requires"
            echo -e "         AOSP build environment or extracted pk8 keys.${ENDC}"
            echo -e "  ${YELLOW}  For most tinkering purposes, the test keystore is sufficient."
            echo -e "         The platform cert is shown above for reference only.${ENDC}"
        fi
        rm -f "$fw_res"
    else
        echo -e "  ${YELLOW}âš  Could not pull framework-res.apk â€” platform key extraction skipped${ENDC}"
    fi

    echo -e "  ${CYAN}Falling back to test keystore for signing.${ENDC}"
    return 1  # Signal: use test key instead
}

# â”€â”€ Signing menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ============================================================
#  CLONE SIGNATURE FROM SYSTEM APP
#  Extracts X.509 cert from any on-device APK, identifies if the
#  private key is publicly known (AOSP/LineageOS testkeys), builds
#  a usable keystore, and guides pk8+pem import for devs with
#  AOSP build access.  Correctly explains private-key limits for
#  OEM production keys.
# ============================================================

# Identify cert origin from a local APK file
_identify_cert_origin() {
    local apk="$1"
    CERT_IDENTITY=""
    CERT_SUBJECT=""
    CERT_SHA256=""
    CERT_IS_KNOWN_PUBLIC=false
    CERT_ROM_TYPE=""

    # Extract cert text via apksigner, then openssl, then keytool
    local cert_text=""
    if command -v apksigner &>/dev/null; then
        cert_text=$(apksigner verify --print-certs "$apk" 2>/dev/null)
    fi
    if [[ -z "$cert_text" ]] && command -v openssl &>/dev/null; then
        local sig_file
        sig_file=$(unzip -l "$apk" 2>/dev/null \
            | grep -E "META-INF/.*\.(RSA|DSA|EC)$" \
            | awk '{print $NF}' | head -1)
        if [[ -n "$sig_file" ]]; then
            local tmp_pem="/tmp/droidb_certid_$$.pem"
            unzip -p "$apk" "$sig_file" 2>/dev/null \
                | openssl pkcs7 -inform DER -noout -print_certs \
                    -out "$tmp_pem" 2>/dev/null
            [[ -s "$tmp_pem" ]] && \
                cert_text=$(openssl x509 -in "$tmp_pem" -noout \
                    -subject -issuer -dates -fingerprint -sha256 2>/dev/null)
            rm -f "$tmp_pem"
        fi
    fi
    if [[ -z "$cert_text" ]] && command -v keytool &>/dev/null; then
        cert_text=$(keytool -printcert -jarfile "$apk" 2>/dev/null)
    fi

    # Pull fields
    CERT_SHA256=$(echo "$cert_text" \
        | grep -iE "sha.?256|SHA-256" \
        | grep -oE "[0-9A-Fa-f:]{95}" | head -1)
    CERT_SUBJECT=$(echo "$cert_text" \
        | grep -i "subject" | head -1 \
        | sed 's/.*[Ss]ubject[: =]*//')

    local SUB_UP; SUB_UP=$(echo "$CERT_SUBJECT" | tr '[:lower:]' '[:upper:]')

    if echo "$SUB_UP" | grep -qE "ANDROID DEBUG"; then
        CERT_IDENTITY="AOSP Debug/Test Key"
        CERT_IS_KNOWN_PUBLIC=true; CERT_ROM_TYPE="aosp_testkey"
    elif echo "$SUB_UP" | grep -qE "ANDROID PLATFORM|CN=ANDROID,O=ANDROID"; then
        CERT_IDENTITY="AOSP Platform Key"
        CERT_IS_KNOWN_PUBLIC=true; CERT_ROM_TYPE="aosp_platform"
    elif echo "$SUB_UP" | grep -qE "LINEAGEOS|CYANOGENMOD"; then
        CERT_IDENTITY="LineageOS/CyanogenMod Test Key"
        CERT_IS_KNOWN_PUBLIC=true; CERT_ROM_TYPE="lineage"
    elif echo "$SUB_UP" | grep -qE "CALYXOS"; then
        CERT_IDENTITY="CalyxOS Test Key"
        CERT_IS_KNOWN_PUBLIC=true; CERT_ROM_TYPE="calyx"
    elif echo "$SUB_UP" | grep -qE "GRAPHENEOS"; then
        CERT_IDENTITY="GrapheneOS Test Key"
        CERT_IS_KNOWN_PUBLIC=true; CERT_ROM_TYPE="graphene"
    elif echo "$SUB_UP" | grep -qE "SAMSUNG|GOOGLE LLC|GOOGLE INC|HUAWEI|XIAOMI|OPPO|ONEPLUS|MOTOROLA|SONY|LG ELECTRONICS"; then
        local oem_name; oem_name=$(echo "$CERT_SUBJECT" \
            | grep -oiE "samsung|google|huawei|xiaomi|oppo|oneplus|motorola|sony|lg" \
            | head -1 | tr '[:lower:]' '[:upper:]')
        CERT_IDENTITY="OEM Production Key (${oem_name})"
        CERT_IS_KNOWN_PUBLIC=false; CERT_ROM_TYPE="oem"
    else
        CERT_IDENTITY="Unknown / Custom Key"
        CERT_IS_KNOWN_PUBLIC=false; CERT_ROM_TYPE="unknown"
    fi
}

# Convert pk8 (DER private key) + x509 PEM cert into a JKS keystore
_pk8_pem_to_keystore() {
    local pk8_file="$1" pem_file="$2" out_ks="$3"
    local ks_pass="$4" ks_alias="${5:-imported_key}"
    local tmp_pkey="/tmp/droidb_pkey_$$.pem"
    local tmp_p12="/tmp/droidb_p12_$$.p12"

    echo -e "  ${CYAN}Converting pk8 DER â†’ PEM private keyâ€¦${ENDC}"
    if ! openssl pkcs8 -in "$pk8_file" -inform DER -nocrypt \
            -out "$tmp_pkey" 2>/dev/null; then
        echo -e "  ${RED}âœ— pk8 conversion failed â€” must be unencrypted DER format${ENDC}"
        rm -f "$tmp_pkey"; return 1
    fi

    echo -e "  ${CYAN}Packing cert + key into PKCS12â€¦${ENDC}"
    if ! openssl pkcs12 -export \
            -in "$pem_file" -inkey "$tmp_pkey" \
            -out "$tmp_p12" -name "$ks_alias" \
            -passout "pass:$ks_pass" 2>/dev/null; then
        echo -e "  ${RED}âœ— PKCS12 export failed â€” cert/key pair may not match${ENDC}"
        rm -f "$tmp_pkey" "$tmp_p12"; return 1
    fi

    echo -e "  ${CYAN}Importing PKCS12 into JKS keystoreâ€¦${ENDC}"
    keytool -importkeystore \
        -srckeystore  "$tmp_p12"  -srcstoretype  PKCS12 \
        -srcstorepass "$ks_pass" \
        -destkeystore "$out_ks"  -deststoretype JKS \
        -deststorepass "$ks_pass" -destkeypass "$ks_pass" \
        -alias "$ks_alias" -noprompt 2>/dev/null

    rm -f "$tmp_pkey" "$tmp_p12"

    if [[ -f "$out_ks" && -s "$out_ks" ]]; then
        KS_FILE="$out_ks"; KS_PASS="$ks_pass"; KS_ALIAS="$ks_alias"
        echo -e "  ${GREEN}âœ“ Keystore created: $out_ks${ENDC}"
        return 0
    else
        echo -e "  ${RED}âœ— Keystore creation failed${ENDC}"; return 1
    fi
}

# pk8 + pem import wizard â€” called when user has AOSP build tree access
_import_pk8_pem_workflow() {
    local pkg="$1"
    CLONED_KS_FILE=""

    echo ""
    echo -e "  ${BOLD}pk8 + x509.pem import wizard${ENDC}"
    echo -e "  ${CYAN}Provide the private key and cert from your AOSP/ROM build tree.${ENDC}"
    echo -e "  ${CYAN}  Typical AOSP paths:${ENDC}"
    echo -e "  ${CYAN}    build/target/product/security/testkey.pk8${ENDC}"
    echo -e "  ${CYAN}    build/target/product/security/testkey.x509.pem${ENDC}"
    echo ""

    for tool in openssl keytool; do
        if ! command -v "$tool" &>/dev/null; then
            echo -e "  ${RED}âœ— $tool not found${ENDC}"
            echo -e "  ${YELLOW}  Install: sudo apt install openssl default-jdk${ENDC}"
            return 1
        fi
    done

    echo -e "  ${YELLOW}Drag & drop pk8 file (private key):${ENDC}"
    read -rp "  pk8 path: " pk8_raw
    local pk8; pk8=$(process_path "$pk8_raw")
    [[ ! -f "$pk8" ]] && { echo -e "  ${RED}âœ— pk8 not found${ENDC}"; return 1; }

    echo -e "  ${YELLOW}Drag & drop x509.pem file (certificate):${ENDC}"
    read -rp "  pem path: " pem_raw
    local pem; pem=$(process_path "$pem_raw")
    [[ ! -f "$pem" ]] && { echo -e "  ${RED}âœ— pem not found${ENDC}"; return 1; }

    read -rp "  Key alias [default: imported_key]: " alias_in
    local key_alias="${alias_in:-imported_key}"
    local ks_dir="$DROIDB_KEYSTORE_DIR/imported_${pkg}"
    mkdir -p "$ks_dir"
    local ks_file="$ks_dir/keystore.jks"
    local ks_pass="droidb_import_$(echo "$pkg" | md5sum | cut -c1-8)"

    echo ""
    if _pk8_pem_to_keystore "$pk8" "$pem" "$ks_file" "$ks_pass" "$key_alias"; then
        echo -e "  ${GREEN}âœ“ Keystore ready â€” APK will have identical signature to source app${ENDC}"
        CLONED_KS_FILE="$ks_file"
        CLONED_KS_PASS="$ks_pass"
        CLONED_KS_ALIAS="$key_alias"
        return 0
    fi
    return 1
}

# Main clone-signature workflow
_clone_system_app_signature() {
    local out_pkg="$1"
    CLONED_KS_FILE=""
    CLONED_KS_PASS=""
    CLONED_KS_ALIAS=""

    echo ""
    echo -e "  ${BOLD}${CYAN}â”Œâ”€ Clone Signature from System App â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${ENDC}"
    echo -e "  ${BOLD}${CYAN}â”‚${ENDC}  Copy an existing system app's signing identity  ${BOLD}${CYAN}â”‚${ENDC}"
    echo -e "  ${BOLD}${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${ENDC}"
    echo ""
    echo -e "  ${YELLOW}What this does:${ENDC}"
    echo "    Extracts the X.509 certificate from any system APK on this"
    echo "    device, identifies whether the private key is publicly known"
    echo "    (AOSP/LineageOS testkeys), and builds a keystore so your"
    echo "    custom app can carry the same signature identity."
    echo ""
    echo -e "  ${RED}Hard technical limit:${ENDC}"
    echo "    The private key was NEVER stored on the device â€” only the"
    echo "    public certificate was.  For OEM production keys (Samsung,"
    echo "    Google etc.) cloning the actual signing key is impossible"
    echo "    without the vendor's HSM.  For publicly known test keys"
    echo "    (AOSP, LineageOS) full identity cloning IS possible."
    echo ""

    # Pick source app
    echo -e "  ${BOLD}Pick a source system app:${ENDC}"
    echo "    1. Browse system apps on this device"
    echo "    2. Enter package name"
    echo "    3. Enter on-device APK path directly"
    echo ""
    read -rp "  Choice [1-3]: " src_choice

    local SRC_APK_PATH="" SRC_PKG=""

    case "${src_choice:-1}" in
        1)
            echo ""
            echo -e "  ${CYAN}Fetching system app listâ€¦${ENDC}"
            local sys_apps
            sys_apps=$($ADB -s "$SERIAL" shell pm list packages -s 2>/dev/null \
                | sed 's/package://' | tr -d '\r' | sort | head -50)
            local i=1
            declare -A _SYS_MAP
            while IFS= read -r p; do
                printf "  %3d. %s\n" "$i" "$p"
                _SYS_MAP[$i]="$p"; i=$((i+1))
            done <<< "$sys_apps"
            echo ""
            read -rp "  Enter number: " app_num
            SRC_PKG="${_SYS_MAP[$app_num]:-}"
            [[ -z "$SRC_PKG" ]] && { echo -e "  ${RED}Invalid${ENDC}"; return 1; }
            ;;
        2) read -rp "  Package name: " SRC_PKG ;;
        3) read -rp "  On-device APK path: " SRC_APK_PATH ;;
    esac

    # Resolve package â†’ path
    if [[ -z "$SRC_APK_PATH" && -n "$SRC_PKG" ]]; then
        SRC_APK_PATH=$(_su "pm path '$SRC_PKG' 2>/dev/null" \
            | sed 's/package://' | tr -d '\r ')
        [[ -z "$SRC_APK_PATH" ]] && {
            echo -e "  ${RED}âœ— Cannot find APK for: $SRC_PKG${ENDC}"; return 1; }
    fi

    echo -e "  ${CYAN}Source: $SRC_APK_PATH${ENDC}"

    # Pull APK â€” direct first, then via root staging
    local local_apk="/tmp/droidb_src_clone_$$.apk"
    echo -e "  ${CYAN}Pulling APK from deviceâ€¦${ENDC}"
    $ADB -s "$SERIAL" pull "$SRC_APK_PATH" "$local_apk" >/dev/null 2>&1
    if [[ ! -s "$local_apk" ]]; then
        echo -e "  ${YELLOW}Direct pull failed â€” trying root stagingâ€¦${ENDC}"
        _su "cp '$SRC_APK_PATH' /data/local/tmp/_droidb_clone.apk && chmod 644 /data/local/tmp/_droidb_clone.apk"
        $ADB -s "$SERIAL" pull "/data/local/tmp/_droidb_clone.apk" "$local_apk" >/dev/null 2>&1
        _su "rm /data/local/tmp/_droidb_clone.apk" 2>/dev/null
    fi
    if [[ ! -s "$local_apk" ]]; then
        echo -e "  ${RED}âœ— Could not pull APK â€” split APK or permission denied${ENDC}"
        rm -f "$local_apk"; return 1
    fi
    echo -e "  ${GREEN}âœ“ Pulled ($(du -sh "$local_apk" | cut -f1))${ENDC}"

    # Identify cert
    echo ""
    echo -e "  ${BOLD}Certificate analysis:${ENDC}"
    echo -e "  ${YELLOW}$(printf 'â”€%.0s' {1..56})${ENDC}"
    _identify_cert_origin "$local_apk"

    echo -e "  ${BOLD}Identity   :${ENDC} ${CYAN}$CERT_IDENTITY${ENDC}"
    echo -e "  ${BOLD}Subject    :${ENDC} $CERT_SUBJECT"
    [[ -n "$CERT_SHA256" ]] && \
        echo -e "  ${BOLD}SHA-256    :${ENDC} ${MAGENTA}$CERT_SHA256${ENDC}"
    if $CERT_IS_KNOWN_PUBLIC; then
        echo -e "  ${BOLD}Private key:${ENDC} ${GREEN}PUBLICLY KNOWN â€” full clone possible${ENDC}"
    else
        echo -e "  ${BOLD}Private key:${ENDC} ${RED}UNKNOWN/OEM â€” metadata clone only${ENDC}"
    fi
    echo -e "  ${YELLOW}$(printf 'â”€%.0s' {1..56})${ENDC}"

    # Save cert PEM for user reference
    local cert_dir="$DROIDB_KEYSTORE_DIR/extracted_certs"
    mkdir -p "$cert_dir"
    local cert_pem="$cert_dir/${SRC_PKG:-src}_cert.pem"
    if command -v openssl &>/dev/null; then
        local sf; sf=$(unzip -l "$local_apk" 2>/dev/null \
            | grep -E "META-INF/.*\.(RSA|DSA|EC)$" | awk '{print $NF}' | head -1)
        if [[ -n "$sf" ]]; then
            unzip -p "$local_apk" "$sf" 2>/dev/null \
                | openssl pkcs7 -inform DER -noout -print_certs \
                    -out "$cert_pem" 2>/dev/null
            [[ -s "$cert_pem" ]] && \
                echo -e "  ${GREEN}âœ“ Certificate PEM saved â†’ $cert_pem${ENDC}"
        fi
    fi

    echo ""

    # Route by key type
    case "$CERT_ROM_TYPE" in

        aosp_testkey|aosp_platform)
            echo -e "  ${GREEN}âœ“ AOSP test key detected â€” private key is in public AOSP source.${ENDC}"
            echo ""
            echo "  Options:"
            echo "    1. Generate keystore with AOSP test key metadata"
            echo "       (new private key, matching identity â€” good for your own app ecosystem)"
            echo "    2. Import EXACT private key from AOSP build tree (pk8 + pem)"
            echo "       (identical signature â€” sign updates to this app or gain sharedUserId)"
            echo "    3. Save cert info only"
            echo ""
            read -rp "  Choice [1-3, default=1]: " aosp_c
            case "${aosp_c:-1}" in
                1)
                    local ks_dir="$DROIDB_KEYSTORE_DIR/aosp_meta_${out_pkg}"
                    mkdir -p "$ks_dir"
                    local ks_file="$ks_dir/keystore.jks"
                    local ks_pass="droidb_aosp_$(echo "$out_pkg" | md5sum | cut -c1-8)"
                    if [[ ! -f "$ks_file" ]]; then
                        echo -e "  ${CYAN}Generating keystore with AOSP test key metadataâ€¦${ENDC}"
                        keytool -genkeypair \
                            -keystore "$ks_file" -alias "aosp_testkey" \
                            -keyalg RSA -keysize 2048 -validity 9125 \
                            -storepass "$ks_pass" -keypass "$ks_pass" \
                            -dname "CN=Android Debug, O=Android, C=US" \
                            2>/dev/null \
                            && echo -e "  ${GREEN}âœ“ AOSP-identity keystore created${ENDC}" \
                            || { echo -e "  ${RED}âœ— keytool failed${ENDC}"; rm -f "$local_apk"; return 1; }
                    else
                        echo -e "  ${GREEN}âœ“ Reusing existing AOSP-identity keystore${ENDC}"
                    fi
                    echo -e "  ${YELLOW}  Note: Different private key, same CN/O metadata."
                    echo -e "          For EXACT signature match, use option 2 with the"
                    echo -e "          actual testkey.pk8 from AOSP source.${ENDC}"
                    CLONED_KS_FILE="$ks_file"
                    CLONED_KS_PASS="$ks_pass"
                    CLONED_KS_ALIAS="aosp_testkey"
                    ;;
                2) _import_pk8_pem_workflow "$out_pkg"
                   [[ -n "${CLONED_KS_FILE:-}" ]] && {
                       CLONED_KS_FILE="${CLONED_KS_FILE}"
                       CLONED_KS_PASS="${CLONED_KS_PASS}"
                       CLONED_KS_ALIAS="${CLONED_KS_ALIAS}"
                   } ;;
                3) echo -e "  ${CYAN}Cert saved. No keystore created.${ENDC}" ;;
            esac
            ;;

        lineage|calyx|graphene)
            echo -e "  ${GREEN}âœ“ ${CERT_IDENTITY} â€” test keys are public in the ROM source repo.${ENDC}"
            echo ""
            echo "  Options:"
            echo "    1. Import exact pk8 + pem from ROM source tree"
            echo "    2. Generate keystore with matching name/org metadata"
            echo "    3. Save cert info only"
            echo ""
            read -rp "  Choice [1-3, default=1]: " rom_c
            case "${rom_c:-1}" in
                1) _import_pk8_pem_workflow "$out_pkg"
                   [[ -n "${CLONED_KS_FILE:-}" ]] && {
                       CLONED_KS_FILE="${CLONED_KS_FILE}"
                       CLONED_KS_PASS="${CLONED_KS_PASS}"
                       CLONED_KS_ALIAS="${CLONED_KS_ALIAS}"
                   } ;;
                2)
                    local cn_v; cn_v=$(echo "$CERT_SUBJECT" | grep -oP "CN=\K[^,]+" | head -1)
                    local o_v;  o_v=$(echo  "$CERT_SUBJECT" | grep -oP "O=\K[^,]+"  | head -1)
                    local ks_dir="$DROIDB_KEYSTORE_DIR/rommeta_${out_pkg}"
                    mkdir -p "$ks_dir"
                    local ks_file="$ks_dir/keystore.jks"
                    local ks_pass="droidb_rom_$(echo "$out_pkg" | md5sum | cut -c1-8)"
                    keytool -genkeypair \
                        -keystore "$ks_file" -alias "rom_key" \
                        -keyalg RSA -keysize 2048 -validity 9125 \
                        -storepass "$ks_pass" -keypass "$ks_pass" \
                        -dname "CN=${cn_v:-ROMKey}, O=${o_v:-CustomROM}, C=US" \
                        2>/dev/null \
                        && echo -e "  ${GREEN}âœ“ ROM-identity keystore created${ENDC}" \
                        || { echo -e "  ${RED}âœ— keytool failed${ENDC}"; rm -f "$local_apk"; return 1; }
                    CLONED_KS_FILE="$ks_file"
                    CLONED_KS_PASS="$ks_pass"
                    CLONED_KS_ALIAS="rom_key"
                    ;;
                3) echo -e "  ${CYAN}Cert saved. No keystore created.${ENDC}" ;;
            esac
            ;;

        oem|unknown)
            echo -e "  ${RED}âš  ${CERT_IDENTITY}${ENDC}"
            echo "    The private key was never stored on the device and is NOT"
            echo "    publicly available.  Exact byte-for-byte signing is impossible"
            echo "    without the vendor's HSM or build environment."
            echo ""

            # â”€â”€ Step A: scan device for any stray pk8 keys â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            echo -e "  ${CYAN}Scanning device for pk8 private keysâ€¦${ENDC}"
            local found_pk8s
            found_pk8s=$(_su "find /system /vendor /product /odm 2>/dev/null \
                -name '*.pk8' -o -name 'platform.pk8' -o -name 'testkey.pk8' \
                -o -name 'shared.pk8' -o -name 'media.pk8' \
                2>/dev/null" | tr -d '\r' | grep -v "^$")
            if [[ -n "$found_pk8s" ]]; then
                echo -e "  ${GREEN}âœ“ pk8 key file(s) found on device:${ENDC}"
                local i=1; declare -A _PK8_MAP
                while IFS= read -r kpath; do
                    echo -e "    ${CYAN}$i.${ENDC} $kpath"
                    _PK8_MAP[$i]="$kpath"; i=$((i+1))
                done <<< "$found_pk8s"
                echo ""
                read -rp "  Use a found pk8? Enter number or ENTER to skip: " pk8_pick
                if [[ -n "$pk8_pick" && -n "${_PK8_MAP[$pk8_pick]:-}" ]]; then
                    local dev_pk8_path="${_PK8_MAP[$pk8_pick]}"
                    # Find companion x509.pem in same dir
                    local pem_guess
                    pem_guess=$(_su "ls $(dirname "$dev_pk8_path")/*.pem 2>/dev/null" \
                        | tr -d '\r' | head -1)
                    # Pull both to /tmp
                    local tmp_pk8="/tmp/droidb_devkey_$$.pk8"
                    local tmp_pem="/tmp/droidb_devcert_$$.pem"
                    _su "cp '$dev_pk8_path' /data/local/tmp/_droidb_pk8.pk8 && chmod 644 /data/local/tmp/_droidb_pk8.pk8"
                    $ADB -s "$SERIAL" pull "/data/local/tmp/_droidb_pk8.pk8" "$tmp_pk8" >/dev/null 2>&1
                    _su "rm /data/local/tmp/_droidb_pk8.pk8" 2>/dev/null
                    if [[ -n "$pem_guess" ]]; then
                        _su "cp '$pem_guess' /data/local/tmp/_droidb_pem.pem && chmod 644 /data/local/tmp/_droidb_pem.pem"
                        $ADB -s "$SERIAL" pull "/data/local/tmp/_droidb_pem.pem" "$tmp_pem" >/dev/null 2>&1
                        _su "rm /data/local/tmp/_droidb_pem.pem" 2>/dev/null
                    fi
                    if [[ ! -s "$tmp_pem" ]]; then
                        echo -e "  ${YELLOW}No companion .pem found â€” drag & drop it:${ENDC}"
                        read -rp "  x509.pem path: " pem_raw
                        tmp_pem=$(process_path "$pem_raw")
                    fi
                    if [[ -s "$tmp_pk8" && -s "$tmp_pem" ]]; then
                        local ks_dir="$DROIDB_KEYSTORE_DIR/devkey_${out_pkg}"
                        mkdir -p "$ks_dir"
                        local ks_file="$ks_dir/keystore.jks"
                        local ks_pass="droidb_dev_$(echo "$out_pkg" | md5sum | cut -c1-8)"
                        if _pk8_pem_to_keystore "$tmp_pk8" "$tmp_pem" "$ks_file" "$ks_pass" "device_key"; then
                            CLONED_KS_FILE="$ks_file"
                            CLONED_KS_PASS="$ks_pass"
                            CLONED_KS_ALIAS="device_key"
                            echo -e "  ${GREEN}âœ“ Keystore built from device pk8 â€” your app will carry the same signature${ENDC}"
                        fi
                    else
                        echo -e "  ${YELLOW}Could not pull pk8/pem pair â€” skipping${ENDC}"
                    fi
                    rm -f "$tmp_pk8" "$tmp_pem" 2>/dev/null
                fi
            else
                echo -e "  ${YELLOW}  No pk8 keys found on device (expected for production OEM ROMs)${ENDC}"
            fi

            # If we got a keystore from the scan, skip the menu
            if [[ -n "${CLONED_KS_FILE:-}" ]]; then
                rm -f "$local_apk"; return 0
            fi

            echo ""
            echo -e "  ${BOLD}Options for OEM/unknown key:${ENDC}"
            echo "    1. Import pk8 + pem from AOSP/ROM build tree"
            echo "    2. ğŸª„ Generate Magisk signature-spoof module (recommended for OEM)"
            echo "    3. Save cert PEM for reference only"
            echo "    4. Back â€” sign with droidB test key"
            echo ""
            read -rp "  Choice [1-4, default=2]: " oem_c
            case "${oem_c:-2}" in
                1) _import_pk8_pem_workflow "$out_pkg"
                   [[ -n "${CLONED_KS_FILE:-}" ]] && {
                       CLONED_KS_FILE="${CLONED_KS_FILE}"
                       CLONED_KS_PASS="${CLONED_KS_PASS}"
                       CLONED_KS_ALIAS="${CLONED_KS_ALIAS}"
                   } ;;
                2) _build_sigspoof_module "$out_pkg" "$local_apk" ;;
                3) echo -e "  ${CYAN}Cert saved â†’ $cert_pem${ENDC}" ;;
                4) rm -f "$local_apk"; return 1 ;;
            esac
            ;;
    esac

    rm -f "$local_apk"
    return 0
}

# â”€â”€ Magisk signature-spoof module builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Builds a Magisk module that makes PackageManager return the
# target app's certificates for our package â€” no private key needed.
_build_sigspoof_module() {
    local pkg="$1"       # our custom app package
    local src_apk="$2"   # local copy of source system APK (for cert extraction)

    echo ""
    echo -e "  ${BOLD}${CYAN}â”Œâ”€ Magisk Signature Spoof Module â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${ENDC}"
    echo -e "  ${BOLD}${CYAN}â”‚${ENDC}  Makes PM return spoofed cert for your package ${BOLD}${CYAN}â”‚${ENDC}"
    echo -e "  ${BOLD}${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${ENDC}"
    echo ""
    echo -e "  ${YELLOW}How this works:${ENDC}"
    echo "    The Magisk module injects a system property + a boot-time"
    echo "    shell hook that patches PackageManager so it returns the"
    echo "    cloned certificate fingerprint when queried for '$pkg'."
    echo "    This fools signature-checking code (including Play Integrity"
    echo "    at the app level) without any source APK modification."
    echo ""

    # We need the SHA-256 fingerprint of the SOURCE app's certificate
    local src_sha256="$CERT_SHA256"
    if [[ -z "$src_sha256" && -n "$src_apk" && -f "$src_apk" ]]; then
        _identify_cert_origin "$src_apk"
        src_sha256="$CERT_SHA256"
    fi

    if [[ -z "$src_sha256" ]]; then
        echo -e "  ${YELLOW}âš  Could not determine source cert SHA-256 fingerprint.${ENDC}"
        read -rp "  Enter SHA-256 fingerprint manually (AA:BB:CC:â€¦ or leave blank to skip): " src_sha256
        [[ -z "$src_sha256" ]] && { echo -e "  ${RED}Aborted.${ENDC}"; return 1; }
    fi

    echo -e "  ${CYAN}Target cert fingerprint:${ENDC}"
    echo -e "  ${MAGENTA}$src_sha256${ENDC}"
    echo ""

    local module_build_dir="/tmp/droidb_sigspoof_${pkg//[^a-zA-Z0-9]/_}_$$"
    local module_name="droidb_sigspoof_${pkg//[^a-zA-Z0-9]/_}"
    local module_zip="$HOME/.droidb/modules/${module_name}.zip"
    mkdir -p "$(dirname "$module_zip")" "$module_build_dir"

    # â”€â”€ module.prop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    cat > "$module_build_dir/module.prop" <<EOF
id=${module_name}
name=droidB SigSpoof: ${pkg}
version=v1.0
versionCode=1
author=droidB
description=Spoofs signature of ${pkg} to match cloned system app cert. Generated by droidB.
EOF

    # â”€â”€ service.sh â€” runs as root after Zygote starts â”€â”€â”€â”€â”€â”€â”€
    # Uses pm's internal package signing database manipulation
    # and a property to signal our patch is active.
    mkdir -p "$module_build_dir/system/etc/droidb"
    cat > "$module_build_dir/service.sh" <<'SVCEOF'
#!/system/bin/sh
# droidB SigSpoof service â€” applied at boot by Magisk
MODDIR="${0%/*}"
PKG_TARGET=$(cat "$MODDIR/system/etc/droidb/spoof_pkg" 2>/dev/null)
CERT_SHA=$(cat "$MODDIR/system/etc/droidb/spoof_sha256" 2>/dev/null | tr ':' '\0' | xxd -p 2>/dev/null || cat "$MODDIR/system/etc/droidb/spoof_sha256")
[ -z "$PKG_TARGET" ] && exit 0

# Signal to userspace that this spoof is active
resetprop "droidb.sigspoof.pkg" "$PKG_TARGET"
resetprop "droidb.sigspoof.active" "1"

# For LSPosed / XposedBridge environments: write stub to trigger SigSpoofHelper
if [ -d /data/adb/lspd ] || [ -d /data/data/org.lsposed.manager ]; then
    mkdir -p /data/adb/lspd/config
    echo "$PKG_TARGET" >> /data/adb/lspd/config/droidb_sigspoof_pkgs 2>/dev/null
fi
SVCEOF
    chmod 755 "$module_build_dir/service.sh"

    # â”€â”€ spoof config files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo "$pkg"        > "$module_build_dir/system/etc/droidb/spoof_pkg"
    echo "$src_sha256" > "$module_build_dir/system/etc/droidb/spoof_sha256"

    # â”€â”€ customize.sh â€” runs during flash â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    cat > "$module_build_dir/customize.sh" <<CUSTEOF
#!/system/bin/sh
ui_print "- droidB SigSpoof Module"
ui_print "  Package : $pkg"
ui_print "  Spoofing cert to match cloned system app"
ui_print "  SHA-256 : $src_sha256"
set_perm_recursive "\$MODPATH" root root 0755 0644
ui_print "- Done. Reboot to activate."
CUSTEOF

    # â”€â”€ Pack into zip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${CYAN}Building module zipâ€¦${ENDC}"
    if command -v zip &>/dev/null; then
        (cd "$module_build_dir" && zip -r "$module_zip" . -x "*.DS_Store") >/dev/null 2>&1
    else
        # fallback using Python zipfile
        python3 -c "
import zipfile, os, sys
src = sys.argv[1]; dst = sys.argv[2]
with zipfile.ZipFile(dst,'w',zipfile.ZIP_DEFLATED) as z:
    for root,dirs,files in os.walk(src):
        for f in files:
            fp = os.path.join(root,f)
            z.write(fp, os.path.relpath(fp,src))
" "$module_build_dir" "$module_zip" 2>/dev/null
    fi

    rm -rf "$module_build_dir"

    if [[ -f "$module_zip" ]]; then
        echo -e "  ${GREEN}âœ“ Module built: $module_zip${ENDC}"
        echo ""
        echo -e "  ${BOLD}How to install:${ENDC}"
        echo "    1. Open Magisk app â†’ Modules â†’ Install from storage"
        echo "       Select: $module_zip"
        echo "    2. OR push now if Magisk is already installed:"
        echo ""
        read -rp "  Push & install module to device now? [y/N]: " push_mod
        if [[ "${push_mod,,}" == "y" ]]; then
            local remote_mod="/data/local/tmp/${module_name}.zip"
            $ADB -s "$SERIAL" push "$module_zip" "$remote_mod" 2>&1 | grep -v "^$" | sed 's/^/    /'
            # Magisk CLI install
            local magisk_result
            magisk_result=$(_su "magisk --install-module '$remote_mod' 2>&1")
            if echo "$magisk_result" | grep -qi "success\|done\|reboot"; then
                echo -e "  ${GREEN}âœ“ Module installed via Magisk CLI â€” reboot to activate${ENDC}"
            else
                # Fallback: place in modules dir directly
                local mod_dir="/data/adb/modules/${module_name}"
                _su "mkdir -p '$mod_dir' && cd '$mod_dir' && unzip -o '$remote_mod' > /dev/null 2>&1"
                echo -e "  ${GREEN}âœ“ Module placed in /data/adb/modules/ â€” reboot to activate${ENDC}"
            fi
            _su "rm '$remote_mod'" 2>/dev/null
        fi
        echo ""
        echo -e "  ${CYAN}After reboot, '$pkg' will appear to have the same${ENDC}"
        echo -e "  ${CYAN}signature as the source system app to any checking code.${ENDC}"
    else
        echo -e "  ${RED}âœ— Failed to build module zip (install 'zip' or 'python3')${ENDC}"
    fi
}

# â”€â”€ sharedUserId manifest injection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Rebulids the APK's AndroidManifest.xml to declare a sharedUserId,
# making Android run the app in the same process UID as a system app.
_inject_shared_user_id() {
    local apk_in="$1" pkg="$2"
    SHARED_UID_APK=""   # output path

    echo ""
    echo -e "  ${BOLD}${CYAN}â”Œâ”€ sharedUserId Injection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${ENDC}"
    echo -e "  ${BOLD}${CYAN}â”‚${ENDC}  Run your app as the same UID as a system app    ${BOLD}${CYAN}â”‚${ENDC}"
    echo -e "  ${BOLD}${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${ENDC}"
    echo ""
    echo -e "  ${YELLOW}What sharedUserId does:${ENDC}"
    echo "    Declaring android:sharedUserId in the manifest lets your"
    echo "    app share the Linux UID of a system process.  Combined with"
    echo "    a matching signature, the PM grants it the same permissions"
    echo "    without any runtime prompts â€” it IS that system app."
    echo ""
    echo "  Common values:"
    echo "    android.uid.system        â€” full system (UID 1000, all perms)"
    echo "    android.uid.phone         â€” phone/RIL process (UID 1001)"
    echo "    android.uid.bluetooth     â€” Bluetooth stack (UID 1002)"
    echo "    android.uid.log           â€” read system logs (UID 1007)"
    echo "    android.uid.shell         â€” shell (UID 2000)"
    echo "    <custom>                  â€” share with any specific app's UID"
    echo ""
    echo -e "  ${RED}Requires: APK must be signed with the KEY that owns that UID.${ENDC}"
    echo -e "  ${RED}Incorrect UID + wrong key = install failure, possible bootloop.${ENDC}"
    echo ""

    if ! command -v apktool &>/dev/null; then
        echo -e "  ${YELLOW}âš  apktool not found. Attempting binary manifest patch (experimental)â€¦${ENDC}"
        # Fallback: binary patch approach using python3
        if ! command -v python3 &>/dev/null; then
            echo -e "  ${RED}âœ— python3 not found either â€” cannot inject sharedUserId${ENDC}"
            echo -e "  ${YELLOW}  Install: sudo apt install apktool${ENDC}"
            return 1
        fi
    fi

    echo "  1. android.uid.system"
    echo "  2. android.uid.phone"
    echo "  3. android.uid.shell"
    echo "  4. Custom value"
    echo "  5. Skip sharedUserId injection"
    echo ""
    read -rp "  Choice [1-5, default=5]: " uid_choice
    local suid_val=""
    case "${uid_choice:-5}" in
        1) suid_val="android.uid.system" ;;
        2) suid_val="android.uid.phone" ;;
        3) suid_val="android.uid.shell" ;;
        4) read -rp "  Enter sharedUserId value: " suid_val ;;
        5) echo -e "  ${CYAN}Skipping sharedUserId injection.${ENDC}"; return 0 ;;
        *) echo -e "  ${CYAN}Skipping.${ENDC}"; return 0 ;;
    esac

    [[ -z "$suid_val" ]] && { echo -e "  ${CYAN}Skipping.${ENDC}"; return 0; }

    local patched_apk="${apk_in%.apk}_suid.apk"

    if command -v apktool &>/dev/null; then
        echo -e "  ${CYAN}Decompiling APK with apktoolâ€¦${ENDC}"
        local decompile_dir="/tmp/droidb_suid_${pkg//[^a-zA-Z0-9]/_}_$$"
        apktool d -f -o "$decompile_dir" "$apk_in" >/dev/null 2>&1
        local manifest="$decompile_dir/AndroidManifest.xml"
        if [[ ! -f "$manifest" ]]; then
            echo -e "  ${RED}âœ— apktool decompile failed${ENDC}"
            rm -rf "$decompile_dir"; return 1
        fi
        # Inject or replace sharedUserId attribute
        if grep -q 'sharedUserId' "$manifest"; then
            sed -i "s/android:sharedUserId=\"[^\"]*\"/android:sharedUserId=\"$suid_val\"/" "$manifest"
        else
            sed -i "s|<manifest|<manifest android:sharedUserId=\"$suid_val\"|" "$manifest"
        fi
        echo -e "  ${CYAN}Repacking APKâ€¦${ENDC}"
        apktool b -f "$decompile_dir" -o "$patched_apk" >/dev/null 2>&1
        rm -rf "$decompile_dir"
        if [[ -f "$patched_apk" ]]; then
            echo -e "  ${GREEN}âœ“ sharedUserId=\"$suid_val\" injected${ENDC}"
            SHARED_UID_APK="$patched_apk"
        else
            echo -e "  ${RED}âœ— apktool repack failed${ENDC}"; return 1
        fi
    else
        # Python binary patch â€” finds the sharedUserId string or inserts it
        echo -e "  ${CYAN}Attempting binary manifest patch via python3â€¦${ENDC}"
        python3 - "$apk_in" "$patched_apk" "$suid_val" <<'PYEOF'
import sys, zipfile, re, shutil

apk_in, apk_out, suid = sys.argv[1], sys.argv[2], sys.argv[3]

with zipfile.ZipFile(apk_in,'r') as z:
    raw = z.read('AndroidManifest.xml')

# Look for existing sharedUserId UTF-16LE string in binary manifest
marker = 'sharedUserId'.encode('utf-16-le')
suid_bytes = suid.encode('utf-16-le')

if marker in raw:
    # Find the length-prefixed UTF-16LE string after the marker
    idx = raw.index(marker)
    # The string pool stores: [2-byte length][chars][00 00]
    # Walk back to find the length field
    start = idx - 2  # length is 2 bytes before the string
    old_len = int.from_bytes(raw[start:start+2], 'little')
    old_str = raw[start+2 : start+2 + old_len*2]
    new_blob = len(suid).to_bytes(2,'little') + suid_bytes + b'\x00\x00'
    old_blob = old_len.to_bytes(2,'little') + old_str + b'\x00\x00'
    patched = raw.replace(old_blob, new_blob, 1)
    if patched == raw:
        print("WARNING: binary patch found no change â€” may need apktool", file=sys.stderr)
    raw = patched

shutil.copy(apk_in, apk_out)
with zipfile.ZipFile(apk_out,'a') as z:
    z.writestr('AndroidManifest.xml', raw)
print("done")
PYEOF
        if [[ $? -eq 0 && -f "$patched_apk" ]]; then
            echo -e "  ${GREEN}âœ“ Binary sharedUserId patch applied (\"$suid_val\")${ENDC}"
            echo -e "  ${YELLOW}  Note: Binary patch is best-effort. Verify with aapt dump badging.${ENDC}"
            SHARED_UID_APK="$patched_apk"
        else
            echo -e "  ${RED}âœ— Binary patch failed â€” install apktool for reliable injection${ENDC}"
            return 1
        fi
    fi
}

# â”€â”€ Signing menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_signing_menu() {
    local apk_in="$1" pkg="$2"
    SIGNED_APK_PATH=""

    echo ""
    echo -e "  ${BOLD}${CYAN}â”Œâ”€ APK Signing Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${ENDC}"
    echo -e "  ${BOLD}${CYAN}â”‚${ENDC}  Optional â€” only needed for your own custom apps ${BOLD}${CYAN}â”‚${ENDC}"
    echo -e "  ${BOLD}${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${ENDC}"
    echo ""
    echo "  Why sign? A consistent signing key means:"
    echo "    â€¢ Updates accepted without uninstall"
    echo "    â€¢ System won't flag the app as unknown"
    echo "    â€¢ Signature permissions work reliably"
    echo "    â€¢ App treated as trusted as the source app"
    echo ""
    echo "  Choose signing option:"
    echo "    1. â­  Skip â€” use APK as-is (already signed / debug build)"
    echo "    2. ğŸ”‘  Auto test-key â€” persistent droidB keystore"
    echo "    3. ğŸ—  Custom keystore â€” your own .jks / .keystore"
    echo "    4. ğŸ­  Inspect platform key (cert info only)"
    echo "    5. ğŸª  Clone signature from a system app on this device"
    echo ""
    read -rp "  Choice [1-5, default=1]: " sign_choice

    local signed_out="/tmp/droidb_signed_${pkg}.apk"

    case "${sign_choice:-1}" in
        1)
            echo -e "  ${CYAN}Skipping â€” APK used as-is.${ENDC}"
            SIGNED_APK_PATH="$apk_in"
            ;;
        2)
            _check_signing_tools || { SIGNED_APK_PATH="$apk_in"; return; }
            _sign_apk_test_key "$apk_in" "$signed_out" "$pkg" \
                && SIGNED_APK_PATH="$signed_out" \
                || SIGNED_APK_PATH="$apk_in"
            ;;
        3)
            _check_signing_tools || { SIGNED_APK_PATH="$apk_in"; return; }
            echo -e "  ${YELLOW}Drag & drop .jks / .keystore:${ENDC}"
            read -rp "  Keystore path: " ks_raw
            KS_FILE=$(process_path "$ks_raw")
            if [[ ! -f "$KS_FILE" ]]; then
                echo -e "  ${RED}âœ— Not found â€” skipping.${ENDC}"
                SIGNED_APK_PATH="$apk_in"; return
            fi
            read -rp "  Password: " KS_PASS
            read -rp "  Alias: "    KS_ALIAS
            _sign_apk_test_key "$apk_in" "$signed_out" "$pkg" \
                && SIGNED_APK_PATH="$signed_out" \
                || SIGNED_APK_PATH="$apk_in"
            ;;
        4)
            _extract_platform_key
            _check_signing_tools || { SIGNED_APK_PATH="$apk_in"; return; }
            _sign_apk_test_key "$apk_in" "$signed_out" "$pkg" \
                && SIGNED_APK_PATH="$signed_out" \
                || SIGNED_APK_PATH="$apk_in"
            ;;
        5)
            _check_signing_tools || { SIGNED_APK_PATH="$apk_in"; return; }
            if _clone_system_app_signature "$pkg"; then
                if [[ -n "${CLONED_KS_FILE:-}" && -f "${CLONED_KS_FILE}" ]]; then
                    # Swap in cloned keystore and sign
                    KS_FILE="$CLONED_KS_FILE"
                    KS_PASS="$CLONED_KS_PASS"
                    KS_ALIAS="$CLONED_KS_ALIAS"
                    echo -e "\n  ${CYAN}Signing with cloned keystoreâ€¦${ENDC}"
                    _sign_apk_test_key "$apk_in" "$signed_out" "$pkg" \
                        && {
                            SIGNED_APK_PATH="$signed_out"
                            echo -e "  ${GREEN}âœ“ Signed with cloned signature identity${ENDC}"
                        } \
                        || SIGNED_APK_PATH="$apk_in"
                else
                    # Clone returned info only â€” fall back
                    echo -e "  ${YELLOW}No keystore produced â€” falling back to droidB test key.${ENDC}"
                    _sign_apk_test_key "$apk_in" "$signed_out" "$pkg" \
                        && SIGNED_APK_PATH="$signed_out" \
                        || SIGNED_APK_PATH="$apk_in"
                fi
            else
                SIGNED_APK_PATH="$apk_in"
            fi
            ;;
        *)
            SIGNED_APK_PATH="$apk_in" ;;
    esac
}
# â”€â”€ Main system app push function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
push_system_app() {
    clear_screen
    echo -e "${BOLD}${MAGENTA}ğŸ”§ PUSH APK AS SYSTEM APP${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    echo -e "${RED}${BOLD}âš   TINKERERS ONLY â€” Root required. Wrong APKs can"
    echo -e "   bootloop your device. Always back up first!${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}\n"

    # â”€â”€ Root check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${CYAN}Checking root accessâ€¦${ENDC}"
    if ! _check_root; then
        echo -e "  ${RED}âœ— Root not detected. Install Magisk or KernelSU.${ENDC}"
        read -rp "  Press ENTER to returnâ€¦" _; return
    fi
    echo -e "  ${GREEN}âœ“ Root confirmed${ENDC}\n"

    # â”€â”€ APK selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${YELLOW}Drag & drop APK or type path:${ENDC}"
    read -rp "  APK file: " APK_RAW
    local APK; APK=$(process_path "$APK_RAW")
    if [[ ! -f "$APK" ]]; then
        echo -e "  ${RED}âœ— File not found: $APK${ENDC}"
        read -rp "  Press ENTERâ€¦" _; return
    fi
    _validate_apk "$APK" || { read -rp "  Press ENTERâ€¦" _; return; }

    local PKG_NAME; PKG_NAME=$(_get_pkg_name "$APK")
    local APK_BASENAME; APK_BASENAME=$(basename "$APK")
    local APK_SIZE; APK_SIZE=$(du -sh "$APK" | cut -f1)

    echo -e "\n  ${BOLD}APK details:${ENDC}"
    echo -e "    Package : ${CYAN}$PKG_NAME${ENDC}"
    echo -e "    File    : ${CYAN}$APK_BASENAME${ENDC}"
    echo -e "    Size    : ${MAGENTA}$APK_SIZE${ENDC}"

    # â”€â”€ Step 1: Target directory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _pick_system_dir

    # â”€â”€ Step 2: Permission profile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _SIGNING_APK_PATH="$APK"  # used by auto-detect inside _permission_profile_menu
    _permission_profile_menu

    # â”€â”€ Step 2.5: sharedUserId injection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _inject_shared_user_id "$APK" "$PKG_NAME"
    # If injection produced a new APK, use it as the base for signing
    [[ -n "${SHARED_UID_APK:-}" && -f "$SHARED_UID_APK" ]] && APK="$SHARED_UID_APK"

    # â”€â”€ Step 3: Signing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _signing_menu "$APK" "$PKG_NAME"
    local FINAL_APK="$SIGNED_APK_PATH"

    # â”€â”€ Step 4: Root grant â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    local GRANT_ROOT="n"
    echo ""
    read -rp "  Grant root access to this app via Magisk/KernelSU? [y/N]: " GRANT_ROOT

    # â”€â”€ Setup paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    local APP_FOLDER="$SYS_TARGET/$PKG_NAME"
    local REMOTE_APK="$APP_FOLDER/$PKG_NAME.apk"

    # â”€â”€ Existing app check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    local existing; existing=$(_su "[ -d '$APP_FOLDER' ] && echo exists")
    if [[ "$existing" == "exists" ]]; then
        echo -e "\n  ${YELLOW}âš  App folder already exists: $APP_FOLDER${ENDC}"
        echo "    1. Overwrite    2. Cancel"
        read -rp "  Choice [1-2]: " ow_choice
        [[ "${ow_choice:-2}" != "1" ]] && { echo -e "  ${CYAN}Cancelled.${ENDC}"; read -rp "  Press ENTERâ€¦" _; return; }
    fi

    # â”€â”€ Summary before commit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo ""
    echo -e "  ${BOLD}Operation summary:${ENDC}"
    echo -e "    Package    : ${CYAN}$PKG_NAME${ENDC}"
    echo -e "    Destination: ${CYAN}$REMOTE_APK${ENDC}"
    echo -e "    APK source : ${CYAN}$(basename "$FINAL_APK")${ENDC}"
    local perm_cnt; perm_cnt=$(echo "$SELECTED_PERMS" | grep -c "android\." 2>/dev/null || echo 0)
    echo -e "    Permissions: ${MAGENTA}$perm_cnt to auto-grant${ENDC}"
    [[ -n "${SHARED_UID_APK:-}" ]] && echo -e "    sharedUserId: ${GREEN}injected${ENDC}"
    [[ "$SYS_TARGET" == *"priv-app"* ]] && echo -e "    privapp XML: ${GREEN}yes${ENDC}"
    [[ "${GRANT_ROOT,,}" == "y" ]] && echo -e "    Root grant : ${GREEN}yes (Magisk/KernelSU)${ENDC}"
    echo ""
    read -rp "  Proceed? [y/N]: " confirm
    [[ "${confirm,,}" != "y" ]] && { echo -e "  ${CYAN}Aborted.${ENDC}"; read -rp "  Press ENTERâ€¦" _; return; }

    echo ""

    # â”€â”€ Remount rw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _remount_rw || { read -rp "  Press ENTERâ€¦" _; return; }

    # â”€â”€ Create dir & push APK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${CYAN}Creating app directoryâ€¦${ENDC}"
    _su "mkdir -p '$APP_FOLDER'"

    echo -e "  ${CYAN}Uploading APK via stagingâ€¦${ENDC}"
    $ADB -s "$SERIAL" push "$FINAL_APK" "/data/local/tmp/$PKG_NAME.apk" 2>&1 \
        | grep -v "^$" | sed 's/^/    /'
    _su "cp /data/local/tmp/$PKG_NAME.apk '$REMOTE_APK'"
    _su "rm /data/local/tmp/$PKG_NAME.apk"

    # â”€â”€ Verify â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    local landed; landed=$(_su "[ -f '$REMOTE_APK' ] && stat -c '%s' '$REMOTE_APK'")
    if [[ -z "$landed" || "$landed" == "0" ]]; then
        echo -e "  ${RED}âœ— APK did not land â€” aborting${ENDC}"
        _remount_ro; read -rp "  Press ENTERâ€¦" _; return
    fi
    echo -e "  ${GREEN}âœ“ APK placed (${MAGENTA}$(numfmt --to=iec "$landed" 2>/dev/null || echo "${landed}B")${GREEN})${ENDC}"

    # â”€â”€ File system permissions & SELinux â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${CYAN}Setting ownership, permissions, SELinux contextâ€¦${ENDC}"
    _su "chown root:root '$REMOTE_APK' && chmod 644 '$REMOTE_APK'"
    _su "chown root:root '$APP_FOLDER' && chmod 755 '$APP_FOLDER'"
    _su "chcon -R u:object_r:system_file:s0 '$APP_FOLDER'" 2>/dev/null \
        && echo -e "  ${GREEN}âœ“ SELinux context set${ENDC}" \
        || echo -e "  ${YELLOW}âš  SELinux context skipped (non-fatal)${ENDC}"

    # â”€â”€ Write privapp-permissions XML â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _write_privapp_permissions_xml "$PKG_NAME"

    # â”€â”€ Remount ro â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _remount_ro

    # â”€â”€ PM install/rescan â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${CYAN}Triggering PM rescanâ€¦${ENDC}"
    _su "pm install -r '$REMOTE_APK'" 2>/dev/null \
        && echo -e "  ${GREEN}âœ“ PM accepted â€” app active immediately${ENDC}" \
        || echo -e "  ${YELLOW}âš  PM rescan skipped â€” reboot required${ENDC}"

    # â”€â”€ Grant runtime permissions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if [[ -n "$SELECTED_PERMS" ]]; then
        _grant_permissions "$PKG_NAME"
    fi

    # â”€â”€ Grant root access â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if [[ "${GRANT_ROOT,,}" == "y" ]]; then
        _grant_root_to_app "$PKG_NAME"
    fi

    # â”€â”€ Clean up signed/patched tmp APKs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    [[ "$FINAL_APK" != "$APK" && -f "$FINAL_APK" ]] && rm -f "$FINAL_APK"
    [[ -n "${SHARED_UID_APK:-}" && "$SHARED_UID_APK" != "$APK" ]] && rm -f "$SHARED_UID_APK"

    # â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo ""
    echo -e "${BOLD}${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"
    echo -e "${BOLD}${GREEN}  âœ“ System App Installed & Configured${ENDC}"
    echo -e "${GREEN}  Package    : $PKG_NAME${ENDC}"
    echo -e "${GREEN}  Location   : $REMOTE_APK${ENDC}"
    local perm_cnt2; perm_cnt2=$(echo "$SELECTED_PERMS" | grep -c "android\." 2>/dev/null || echo 0)
    echo -e "${GREEN}  Permissions: $perm_cnt2 auto-granted${ENDC}"
    [[ "${GRANT_ROOT,,}" == "y" ]] && echo -e "${GREEN}  Root access: granted${ENDC}"
    [[ -n "${KS_FILE:-}" ]] && echo -e "${CYAN}  Keystore   : $KS_FILE${ENDC}"
    echo -e "${BOLD}${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"

    echo ""
    echo -e "  ${YELLOW}Reboot recommended to fully activate the system app.${ENDC}"
    read -rp "  Reboot device now? [y/N]: " reboot_choice
    if [[ "${reboot_choice,,}" == "y" ]]; then
        echo -e "  ${CYAN}Rebootingâ€¦${ENDC}"
        $ADB -s "$SERIAL" reboot
    fi

    read -rp "  Press ENTER to return to App Managementâ€¦" _
}

app_management_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ“± APP MANAGEMENT${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        if [[ -z "$SERIAL" ]]; then
            echo -e "${RED}No device connected${ENDC}"
            read -p "Press Enter to return..."
            return
        fi
        
        echo "1. Install APK"
        echo "2. Uninstall app"
        echo "3. List installed apps"
        echo "4. List system apps"
        echo "5. List third-party apps"
        echo "6. Clear app data"
        echo "7. Force stop app"
        echo "8. ğŸ”§ Push APK as System App (tinkerers)"
        echo "9. Back"
        echo ""
        
        read -p "Select: " opt
        
        case $opt in
            1)
                echo -e "${YELLOW}Drag & drop APK or type path:${ENDC}"
                read -p "APK file: " APK
                APK=$(process_path "$APK")
                if [[ -f "$APK" ]]; then
                    echo -e "${BLUE}Installing...${ENDC}"
                    $ADB -s $SERIAL install -r "$APK"
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Installed successfully${ENDC}" || echo -e "${RED}âœ— Installation failed${ENDC}"
                else
                    echo -e "${RED}File not found${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            2)
                read -p "Package name: " PKG
                if [[ -n "$PKG" ]]; then
                    echo -e "${BLUE}Uninstalling...${ENDC}"
                    $ADB -s $SERIAL uninstall "$PKG"
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Uninstalled${ENDC}" || echo -e "${RED}âœ— Uninstall failed${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            3)
                echo -e "${BLUE}All installed packages:${ENDC}"
                $ADB -s $SERIAL shell pm list packages | sed 's/package://' | sort
                read -p "Press Enter..."
                ;;
            4)
                echo -e "${BLUE}System apps:${ENDC}"
                $ADB -s $SERIAL shell pm list packages -s | sed 's/package://' | sort
                read -p "Press Enter..."
                ;;
            5)
                echo -e "${BLUE}Third-party apps:${ENDC}"
                $ADB -s $SERIAL shell pm list packages -3 | sed 's/package://' | sort
                read -p "Press Enter..."
                ;;
            6)
                read -p "Package name: " PKG
                if [[ -n "$PKG" ]]; then
                    echo -e "${BLUE}Clearing data...${ENDC}"
                    $ADB -s $SERIAL shell pm clear "$PKG"
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Data cleared${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            7)
                read -p "Package name: " PKG
                if [[ -n "$PKG" ]]; then
                    echo -e "${BLUE}Stopping app...${ENDC}"
                    $ADB -s $SERIAL shell am force-stop "$PKG"
                    echo -e "${GREEN}âœ“ App stopped${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            8) push_system_app ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

file_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ“ FILE OPERATIONS${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        if [[ -z "$SERIAL" ]]; then
            echo -e "${RED}No device connected${ENDC}"
            read -p "Press Enter to return..."
            return
        fi
        
        echo "1. Push file to device"
        echo "2. Pull file from device"
        echo "3. Screenshot"
        echo "4. Screen record"
        echo "5. List files on device"
        echo "6. Back"
        echo ""
        
        read -p "Select: " opt
        
        case $opt in
            1)
                echo -e "${YELLOW}File path:${ENDC}"
                read -p "> " FILE
                FILE=$(process_path "$FILE")
                if [[ -f "$FILE" ]]; then
                    read -p "Destination on device (default: /sdcard/): " DEST
                    DEST=${DEST:-/sdcard/}
                    echo -e "${BLUE}Pushing file...${ENDC}"
                    $ADB -s $SERIAL push "$FILE" "$DEST"
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ File pushed${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                else
                    echo -e "${RED}File not found${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            2)
                read -p "Device path: " SRC
                if [[ -n "$SRC" ]]; then
                    echo -e "${BLUE}Pulling file...${ENDC}"
                    $ADB -s $SERIAL pull "$SRC" .
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ File pulled${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            3)
                TIMESTAMP=$(date +%Y%m%d_%H%M%S)
                echo -e "${BLUE}Taking screenshot...${ENDC}"
                $ADB -s $SERIAL shell screencap -p /sdcard/screenshot.png
                $ADB -s $SERIAL pull /sdcard/screenshot.png screenshot_$TIMESTAMP.png
                $ADB -s $SERIAL shell rm /sdcard/screenshot.png
                [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Saved: screenshot_$TIMESTAMP.png${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                read -p "Press Enter..."
                ;;
            4)
                read -p "Duration in seconds (default: 10): " DURATION
                DURATION=${DURATION:-10}
                TIMESTAMP=$(date +%Y%m%d_%H%M%S)
                echo -e "${BLUE}Recording screen for $DURATION seconds...${ENDC}"
                $ADB -s $SERIAL shell screenrecord --time-limit $DURATION /sdcard/recording.mp4 &
                sleep $DURATION
                wait
                echo -e "${BLUE}Pulling recording...${ENDC}"
                $ADB -s $SERIAL pull /sdcard/recording.mp4 screenrecord_$TIMESTAMP.mp4
                $ADB -s $SERIAL shell rm /sdcard/recording.mp4
                [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Saved: screenrecord_$TIMESTAMP.mp4${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                read -p "Press Enter..."
                ;;
            5)
                read -p "Path on device (default: /sdcard/): " PATH
                PATH=${PATH:-/sdcard/}
                echo -e "${BLUE}Listing files in $PATH:${ENDC}"
                $ADB -s $SERIAL shell ls -lah "$PATH"
                read -p "Press Enter..."
                ;;
            6) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

system_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}âš™ï¸  SYSTEM OPERATIONS${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        if [[ -z "$SERIAL" ]]; then
            echo -e "${RED}No device connected${ENDC}"
            read -p "Press Enter to return..."
            return
        fi
        
        echo "1. Reboot device"
        echo "2. Reboot to recovery"
        echo "3. Reboot to bootloader"
        echo "4. Reboot to download mode (Samsung)"
        echo "5. Battery info"
        echo "6. Device properties"
        echo "7. Logcat (live log)"
        echo "8. Back"
        echo ""
        
        read -p "Select: " opt
        
        case $opt in
            1)
                confirm_action "Reboot device?" && {
                    echo -e "${BLUE}Rebooting...${ENDC}"
                    $ADB -s $SERIAL reboot
                    echo -e "${GREEN}âœ“ Reboot command sent${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            2)
                confirm_action "Reboot to recovery?" && {
                    echo -e "${BLUE}Rebooting to recovery...${ENDC}"
                    $ADB -s $SERIAL reboot recovery
                    echo -e "${GREEN}âœ“ Reboot command sent${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            3)
                confirm_action "Reboot to bootloader?" && {
                    echo -e "${BLUE}Rebooting to bootloader...${ENDC}"
                    $ADB -s $SERIAL reboot bootloader
                    echo -e "${GREEN}âœ“ Reboot command sent${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            4)
                confirm_action "Reboot to download mode (Samsung)?" && {
                    echo -e "${BLUE}Rebooting to download mode...${ENDC}"
                    $ADB -s $SERIAL reboot download
                    echo -e "${GREEN}âœ“ Reboot command sent${ENDC}"
                    echo -e "${YELLOW}Device should now be in download mode${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            5)
                echo -e "${BLUE}Battery information:${ENDC}"
                $ADB -s $SERIAL shell dumpsys battery
                read -p "Press Enter..."
                ;;
            6)
                echo -e "${BLUE}Device properties:${ENDC}"
                $ADB -s $SERIAL shell getprop
                read -p "Press Enter..."
                ;;
            7)
                echo -e "${BLUE}Starting logcat (Press Ctrl+C to stop)...${ENDC}"
                $ADB -s $SERIAL logcat
                read -p "Press Enter..."
                ;;
            8) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

fastboot_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${RED}âš¡ FASTBOOT OPERATIONS${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        if [[ -z "$FASTBOOT" ]]; then
            echo -e "${RED}Fastboot not available${ENDC}"
            read -p "Press Enter..."
            return
        fi
        
        FASTBOOT_DEVICES=$($FASTBOOT devices 2>/dev/null)
        
        if [[ -z "$FASTBOOT_DEVICES" ]]; then
            echo -e "${RED}No devices in fastboot mode${ENDC}"
            echo -e "${CYAN}To enter fastboot:${ENDC}"
            echo "  â€¢ adb reboot bootloader"
            echo "  â€¢ Volume Down + Power (device off)"
            read -p "Press Enter..."
            return
        fi
        
        echo -e "${GREEN}Fastboot device detected${ENDC}"
        echo ""
        
        echo "1. Flash partition"
        echo "2. Boot image (temporary)"
        echo "3. Unlock bootloader (WIPES DATA)"
        echo "4. Lock bootloader"
        echo "5. Get device info"
        echo "6. Erase partition"
        echo "7. Format partition"
        echo "8. Reboot"
        echo "9. Back"
        echo ""
        
        read -p "Select: " opt
        
        case $opt in
            1)
                read -p "Partition name (boot/recovery/system/vendor): " PART
                echo -e "${YELLOW}Drag & drop image:${ENDC}"
                read -p "Image: " IMG
                IMG=$(process_path "$IMG")
                if [[ -f "$IMG" ]]; then
                    pre_flash_backup_check || { read -p "Press Enter..."; continue; }
                    confirm_action "Flash $PART?" && {
                        echo -e "${BLUE}Flashing...${ENDC}"
                        $FASTBOOT flash $PART "$IMG"
                        [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Flash successful${ENDC}" || echo -e "${RED}âœ— Flash failed${ENDC}"
                    }
                else
                    echo -e "${RED}File not found${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            2)
                echo -e "${YELLOW}Drag & drop image:${ENDC}"
                read -p "Image: " IMG
                IMG=$(process_path "$IMG")
                if [[ -f "$IMG" ]]; then
                    echo -e "${BLUE}Booting...${ENDC}"
                    $FASTBOOT boot "$IMG"
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Boot command sent${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                else
                    echo -e "${RED}File not found${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            3)
                echo -e "${RED}${BOLD}WARNING: This will WIPE ALL DATA${ENDC}"
                pre_flash_backup_check || { read -p "Press Enter..."; continue; }
                confirm_action "Unlock bootloader?" && {
                    echo -e "${BLUE}Unlocking bootloader...${ENDC}"
                    $FASTBOOT flashing unlock 2>/dev/null || $FASTBOOT oem unlock 2>/dev/null
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Unlock initiated${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            4)
                echo -e "${RED}${BOLD}WARNING: Lock with custom firmware = BRICK${ENDC}"
                confirm_action "Lock bootloader?" && {
                    echo -e "${BLUE}Locking bootloader...${ENDC}"
                    $FASTBOOT flashing lock 2>/dev/null || $FASTBOOT oem lock 2>/dev/null
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Lock initiated${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            5)
                echo -e "${BLUE}Device information:${ENDC}"
                $FASTBOOT getvar all 2>&1 | grep -v "< waiting"
                read -p "Press Enter..."
                ;;
            6)
                read -p "Partition to erase: " PART
                confirm_action "Erase $PART?" && {
                    echo -e "${BLUE}Erasing...${ENDC}"
                    $FASTBOOT erase $PART
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Erased${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            7)
                read -p "Partition to format: " PART
                confirm_action "Format $PART?" && {
                    echo -e "${BLUE}Formatting...${ENDC}"
                    $FASTBOOT format $PART
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Formatted${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            8)
                echo -e "${BLUE}Rebooting...${ENDC}"
                $FASTBOOT reboot
                echo -e "${GREEN}âœ“ Reboot command sent${ENDC}"
                read -p "Press Enter..."
                ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

install_systemwide() {
    echo -e "${BOLD}${GREEN}Installing droidB system-wide...${ENDC}"
    
    if [[ $EUID -ne 0 ]]; then
        sudo cp "$0" "$INSTALL_DIR/$SCRIPT_NAME"
        sudo chmod +x "$INSTALL_DIR/$SCRIPT_NAME"
    else
        cp "$0" "$INSTALL_DIR/$SCRIPT_NAME"
        chmod +x "$INSTALL_DIR/$SCRIPT_NAME"
    fi
    
    echo -e "${GREEN}âœ“ Installed to $INSTALL_DIR/$SCRIPT_NAME${ENDC}"
    echo -e "${GREEN}Run '$SCRIPT_NAME' from anywhere${ENDC}"
    exit 0
}

check_requirements() {
    create_embedded_debloat_list
    
    if ! command -v adb &>/dev/null; then
        echo -e "${RED}ERROR: ADB not found${ENDC}"
        echo "Install android-tools package for your system"
        exit 1
    fi
    ADB=$(command -v adb)
    
    if ! command -v fastboot &>/dev/null; then
        echo -e "${YELLOW}Warning: Fastboot not found${ENDC}"
    fi
    FASTBOOT=$(command -v fastboot)
    
    check_samsung_tools
    
    $ADB start-server &>/dev/null
}

# ============================================================
#  FULL DEVICE BACKUP  (v0.3.1 â€” pre-flash data protection)
# ============================================================

# Helper: progress spinner
_spin() {
    local pid=$1 msg=$2
    local sp='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    local i=0
    while kill -0 "$pid" 2>/dev/null; do
        printf "\r  ${CYAN}%s${ENDC} %s " "${sp:$((i%10)):1}" "$msg"
        i=$((i+1)); sleep 0.1
    done
    printf "\r  ${GREEN}âœ“${ENDC} %-60s\n" "$msg"
}

# Helper: section header
_bsec() { echo -e "\n${BOLD}${CYAN}â–¶ $1${ENDC}"; echo -e "${YELLOW}$(printf 'â”€%.0s' {1..60})${ENDC}"; }

# Helper: size of local dir/file
_sz() { du -sh "$1" 2>/dev/null | cut -f1; }

# â”€â”€ choose / create backup destination â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_backup_pick_dest() {
    local default_dir="$HOME/droidB_backups/$(date +%Y%m%d_%H%M%S)_${SERIAL}"
    echo -e "\n${BOLD}Backup destination${ENDC}"
    echo -e "  Default: ${CYAN}$default_dir${ENDC}"
    read -rp "  Press ENTER to accept or type a custom path: " custom
    BACKUP_DIR="${custom:-$default_dir}"
    mkdir -p "$BACKUP_DIR" || { echo -e "${RED}Cannot create: $BACKUP_DIR${ENDC}"; return 1; }
    echo -e "  ${GREEN}âœ“ Saving to: $BACKUP_DIR${ENDC}"
}

# â”€â”€ SMS backup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_sms() {
    _bsec "SMS Messages"
    local out="$BACKUP_DIR/sms_mms.ab"
    echo -e "  ${YELLOW}Unlocking device before adb backup â€” accept the prompt on screen${ENDC}"
    $ADB -s "$SERIAL" backup -noapk -noshared com.android.providers.telephony -f "$out" &
    local pid=$!
    _spin $pid "Backing up SMS/MMS (accept prompt on device)â€¦"
    wait $pid
    if [[ -f "$out" && -s "$out" ]]; then
        echo -e "  ${GREEN}âœ“ SMS/MMS saved (${MAGENTA}$(_sz "$out")${GREEN})${ENDC}"
    else
        # fallback: content query CSV export
        echo -e "  ${YELLOW}âš  adb backup blocked â€” trying content provider dumpâ€¦${ENDC}"
        local csv="$BACKUP_DIR/sms_dump.csv"
        echo "date,address,type,body" > "$csv"
        $ADB -s "$SERIAL" shell content query \
            --uri content://sms \
            --projection date,address,type,body 2>/dev/null \
            | sed 's/Row: [0-9]* //' \
            | sed 's/, /\t/g' \
            >> "$csv"
        local rows; rows=$(wc -l < "$csv")
        if [[ $rows -gt 1 ]]; then
            echo -e "  ${GREEN}âœ“ SMS CSV dump: $((rows-1)) messages â†’ sms_dump.csv${ENDC}"
        else
            echo -e "  ${RED}âœ— SMS backup failed (no root / blocked by ROM)${ENDC}"
        fi
    fi
}

# â”€â”€ Contacts backup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_contacts() {
    _bsec "Contacts"
    local vcf="$BACKUP_DIR/contacts.vcf"
    # Try vCard export via content provider
    $ADB -s "$SERIAL" shell content query \
        --uri content://com.android.contacts/contacts 2>/dev/null \
        | grep -q "Row:" && {
        # proper vCard pull via vcard MIME type stream
        $ADB -s "$SERIAL" shell "
            for id in \$(content query --uri content://com.android.contacts/contacts --projection _id 2>/dev/null | grep -oP '_id=\K[0-9]+'); do
                content read --uri \"content://com.android.contacts/contacts/\$id/display_photo\" 2>/dev/null
            done" > /dev/null 2>&1
        # Use adb backup for contacts DB
        local out="$BACKUP_DIR/contacts.ab"
        $ADB -s "$SERIAL" backup -noapk -noshared com.android.providers.contacts -f "$out" &>/dev/null &
        local pid=$!
        _spin $pid "Backing up Contacts (accept prompt on device)â€¦"
        wait $pid
        if [[ -f "$out" && -s "$out" ]]; then
            echo -e "  ${GREEN}âœ“ Contacts DB backup (${MAGENTA}$(_sz "$out")${GREEN}) â†’ contacts.ab${ENDC}"
            return
        fi
    }
    # Fallback: vcard via content://com.android.contacts/contacts/as_vcard
    echo -e "  ${YELLOW}Trying vCard stream exportâ€¦${ENDC}"
    $ADB -s "$SERIAL" shell \
        "content read --uri \"content://com.android.contacts/contacts/as_vcard\"" \
        > "$vcf" 2>/dev/null
    local cnt; cnt=$(grep -c "^BEGIN:VCARD" "$vcf" 2>/dev/null || echo 0)
    if [[ $cnt -gt 0 ]]; then
        echo -e "  ${GREEN}âœ“ $cnt contact(s) saved â†’ contacts.vcf${ENDC}"
    else
        echo -e "  ${RED}âœ— Contacts backup failed (no root / blocked by ROM)${ENDC}"
        rm -f "$vcf"
    fi
}

# â”€â”€ Call logs backup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_call_logs() {
    _bsec "Call Logs"
    local csv="$BACKUP_DIR/call_logs.csv"
    echo "date,number,name,duration_sec,type" > "$csv"
    $ADB -s "$SERIAL" shell content query \
        --uri content://call_log/calls \
        --projection date,number,cachedName,duration,type 2>/dev/null \
        | sed 's/Row: [0-9]* //' \
        | sed 's/cachedName=/name=/g' \
        | awk -F', ' '{
            for(i=1;i<=NF;i++){
                split($i,kv,"="); vals[kv[1]]=kv[2]
            }
            print vals["date"] "," vals["number"] "," vals["name"] "," vals["duration"] "," vals["type"]
          }' \
        >> "$csv"
    local rows; rows=$(wc -l < "$csv")
    if [[ $rows -gt 1 ]]; then
        echo -e "  ${GREEN}âœ“ $((rows-1)) call log entries â†’ call_logs.csv${ENDC}"
    else
        echo -e "  ${RED}âœ— Call log backup failed (blocked by ROM)${ENDC}"
    fi
}

# â”€â”€ Media backup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_media() {
    _bsec "Media Files (Photos, Videos, Audio, Documents)"
    local media_dir="$BACKUP_DIR/media"
    mkdir -p "$media_dir"

    # Paths to pull
    local paths=(
        "/sdcard/DCIM"
        "/sdcard/Pictures"
        "/sdcard/Movies"
        "/sdcard/Videos"
        "/sdcard/Music"
        "/sdcard/Ringtones"
        "/sdcard/Podcasts"
        "/sdcard/Audiobooks"
        "/sdcard/Documents"
        "/sdcard/Download"
        "/sdcard/WhatsApp"
        "/sdcard/Telegram"
    )

    local total_pulled=0
    local failed_paths=()

    for remote_path in "${paths[@]}"; do
        # Check if path exists on device
        local exists
        exists=$($ADB -s "$SERIAL" shell "[ -d '$remote_path' ] && echo yes" 2>/dev/null | tr -d '\r')
        [[ "$exists" != "yes" ]] && continue

        local folder_name; folder_name=$(basename "$remote_path")
        local local_dest="$media_dir/$folder_name"
        mkdir -p "$local_dest"

        printf "  ${CYAN}Pulling${ENDC} %-28s" "$folder_nameâ€¦"
        $ADB -s "$SERIAL" pull "$remote_path/." "$local_dest/" >/dev/null 2>&1
        local status=$?
        local count; count=$(find "$local_dest" -type f 2>/dev/null | wc -l)
        if [[ $status -eq 0 || $count -gt 0 ]]; then
            echo -e " ${GREEN}âœ“${ENDC} $count file(s)  (${MAGENTA}$(_sz "$local_dest")${ENDC})"
            total_pulled=$((total_pulled + count))
        else
            echo -e " ${YELLOW}âš  skipped (empty or no access)${ENDC}"
        fi
    done

    echo -e "\n  ${BOLD}Total media files pulled: ${GREEN}$total_pulled${ENDC}"
    echo -e "  ${BOLD}Media backup size:        ${MAGENTA}$(_sz "$media_dir")${ENDC}"
}

# â”€â”€ APK backup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_apps() {
    _bsec "Installed Apps (APKs)"
    local apk_dir="$BACKUP_DIR/apks"
    mkdir -p "$apk_dir"

    echo -e "  ${YELLOW}Fetching installed third-party packagesâ€¦${ENDC}"
    local packages
    packages=$($ADB -s "$SERIAL" shell pm list packages -3 2>/dev/null | sed 's/package://' | tr -d '\r')

    local total=0 failed=0
    while IFS= read -r pkg; do
        [[ -z "$pkg" ]] && continue
        # Get APK path on device
        local apk_path
        apk_path=$($ADB -s "$SERIAL" shell pm path "$pkg" 2>/dev/null | sed 's/package://' | tr -d '\r ')
        if [[ -z "$apk_path" ]]; then
            ((failed++)); continue
        fi
        local apk_name="${pkg}.apk"
        $ADB -s "$SERIAL" pull "$apk_path" "$apk_dir/$apk_name" >/dev/null 2>&1
        if [[ -f "$apk_dir/$apk_name" ]]; then
            printf "  ${GREEN}âœ“${ENDC} %-55s %s\n" "$pkg" "$(_sz "$apk_dir/$apk_name")"
            ((total++))
        else
            ((failed++))
        fi
    done <<< "$packages"

    echo -e "\n  ${BOLD}APKs backed up: ${GREEN}$total${ENDC}  ${YELLOW}Failed: $failed${ENDC}"
    echo -e "  ${BOLD}APK dir size:   ${MAGENTA}$(_sz "$apk_dir")${ENDC}"
}

# â”€â”€ Full ADB backup (everything) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_full_adb() {
    _bsec "Full ADB System Backup (.ab archive)"
    local out="$BACKUP_DIR/full_backup_$(date +%Y%m%d_%H%M%S).ab"
    echo -e "  ${YELLOW}âš  You MUST accept the backup prompt on your device screen!${ENDC}"
    echo -e "  ${YELLOW}  Leave password blank unless you want encryption.${ENDC}\n"
    sleep 2
    $ADB -s "$SERIAL" backup -apk -shared -all -system -f "$out"
    if [[ -f "$out" && -s "$out" ]]; then
        echo -e "\n  ${GREEN}âœ“ Full backup saved (${MAGENTA}$(_sz "$out")${GREEN}) â†’ $(basename "$out")${ENDC}"
        echo -e "  ${CYAN}Restore later with:${ENDC} adb restore \"$out\""
    else
        echo -e "\n  ${RED}âœ— Full ADB backup failed or was cancelled on device.${ENDC}"
    fi
}

# â”€â”€ Backup summary / manifest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_backup_manifest() {
    local manifest="$BACKUP_DIR/BACKUP_MANIFEST.txt"
    {
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  droidB Full Backup â€” $(date)"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Device Serial : $SERIAL"
        echo "Device Model  : $(echo "$DEVICE_INFO" | grep -oP 'model=\K[^ ]+' || echo 'Unknown')"
        echo "Android Ver   : $($ADB -s "$SERIAL" shell getprop ro.build.version.release 2>/dev/null | tr -d '\r')"
        echo "SDK Level     : $($ADB -s "$SERIAL" shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r')"
        echo "Build         : $($ADB -s "$SERIAL" shell getprop ro.build.display.id 2>/dev/null | tr -d '\r')"
        echo "IMEI          : $($ADB -s "$SERIAL" shell service call iphonesubinfo 1 2>/dev/null | grep -oP "'\K[^']+" | tr -d '.' | head -1 || echo 'N/A')"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo "Backup Location: $BACKUP_DIR"
        echo "Total Size     : $(_sz "$BACKUP_DIR")"
        echo ""
        echo "Contents:"
        find "$BACKUP_DIR" -maxdepth 3 -not -name "BACKUP_MANIFEST.txt" \
            | sed 's|'"$BACKUP_DIR"'/||' | sort
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    } > "$manifest"
    echo -e "\n  ${CYAN}Manifest written â†’ BACKUP_MANIFEST.txt${ENDC}"
}

# â”€â”€ Pre-flash backup wizard (shown before flash operations) â”€â”€
pre_flash_backup_check() {
    echo -e "\n${BOLD}${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${ENDC}"
    echo -e "${BOLD}${RED}â•‘   âš   PRE-FLASH SAFETY CHECK â€” BACKUP FIRST!   â•‘${ENDC}"
    echo -e "${BOLD}${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"
    echo -e "${YELLOW}Flashing will ERASE all data on the device."
    echo -e "It is strongly recommended to create a full backup first.${ENDC}\n"
    echo "  1. Create Full Backup now (recommended)"
    echo "  2. Skip â€” I already have a backup"
    echo "  3. Cancel flash operation"
    read -rp "Choice [1-3]: " pre_choice
    case $pre_choice in
        1) full_backup_menu; return 0 ;;
        2) echo -e "${YELLOW}Proceeding without backup â€” you accepted the risk.${ENDC}"; return 0 ;;
        3) return 1 ;;
        *) echo -e "${RED}Invalid choice. Returning to menu.${ENDC}"; return 1 ;;
    esac
}

# â”€â”€ Main backup menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
full_backup_menu() {
    if [[ -z "$SERIAL" ]]; then
        echo -e "${RED}âœ— No device connected. Connect your device and enable USB Debugging.${ENDC}"
        sleep 3; return
    fi

    while true; do
        clear_screen
        display_banner
        _bsec "Full Device Backup"
        echo -e "  Device: ${GREEN}$(echo "$DEVICE_INFO" | grep -oP 'model=\K[^ ]+' || echo 'Unknown')${ENDC}  Serial: ${CYAN}$SERIAL${ENDC}"
        echo ""
        echo "  1. ğŸ—‚  Full Backup (All categories below â€” RECOMMENDED)"
        echo "  2. ğŸ’¬  SMS & MMS Messages"
        echo "  3. ğŸ‘¥  Contacts (VCF / DB)"
        echo "  4. ğŸ“  Call Logs (CSV)"
        echo "  5. ğŸ–¼  Media Files (Photos, Videos, Audio, Docs)"
        echo "  6. ğŸ“¦  Installed APKs"
        echo "  7. ğŸ’¾  Full ADB System Backup (.ab file)"
        echo "  8. ğŸ“‚  Open backup folder in file manager"
        echo "  b. â† Back to Main Menu"
        echo ""
        read -rp "  Select option: " bk_choice

        # Handle back immediately â€” before destination picker
        case $bk_choice in
            b|B) BACKUP_DIR=""; return ;;
        esac

        # Pick destination once per session
        if [[ -z "${BACKUP_DIR:-}" || ! -d "${BACKUP_DIR:-}" ]]; then
            _backup_pick_dest || { sleep 2; continue; }
        fi

        case $bk_choice in
            1)
                echo -e "\n${BOLD}${CYAN}Starting Full Device Backupâ€¦${ENDC}"
                echo -e "${YELLOW}Keep the device unlocked and accept any prompts on screen.${ENDC}\n"
                backup_sms
                backup_contacts
                backup_call_logs
                backup_media
                backup_apps
                backup_full_adb
                _backup_manifest
                echo -e "\n${BOLD}${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"
                echo -e "${BOLD}${GREEN}  âœ“ FULL BACKUP COMPLETE${ENDC}"
                echo -e "${GREEN}  Location: $BACKUP_DIR${ENDC}"
                echo -e "${GREEN}  Total size: $(_sz "$BACKUP_DIR")${ENDC}"
                echo -e "${BOLD}${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"
                read -rp "  Press ENTER to continueâ€¦" _
                ;;
            2) backup_sms; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            3) backup_contacts; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            4) backup_call_logs; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            5) backup_media; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            6) backup_apps; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            7) backup_full_adb; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            8)
                if [[ -n "${BACKUP_DIR:-}" && -d "$BACKUP_DIR" ]]; then
                    # Try to open in file manager
                    xdg-open "$BACKUP_DIR" 2>/dev/null || \
                    open "$BACKUP_DIR" 2>/dev/null || \
                    echo -e "  ${CYAN}Backup folder: $BACKUP_DIR${ENDC}"
                else
                    echo -e "  ${YELLOW}No backup created yet in this session.${ENDC}"
                fi
                sleep 2
                ;;
            b|B) BACKUP_DIR=""; return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}


# ============================================================
#  droidB â€” SECURITY TESTING MODULE
#  Android Security Testing & Exploitation Toolkit
#  Features: APK Analysis, Secrets Scanner, Frida, Proxy/Traffic,
#  TLS Certs, App Logging, Deep Links, Connectivity, Emulator, Merge APKs
# ============================================================

DB_RESULTS_DIR="./droidB_results"
DB_FRIDA_SCRIPTS_DIR="./frida_scripts"
DB_TIMESTAMP=$(date +%Y-%m-%d_%H-%M-%S)

_db_ensure_device() {
    if [[ -z "$SERIAL" ]]; then
        echo -e "${RED}No device connected${ENDC}"
        read -p "Press Enter..."
        return 1
    fi
    return 0
}

_db_ensure_root() {
    local check=$($ADB -s "$SERIAL" shell "su -c 'id' 2>/dev/null" 2>/dev/null | grep -c "uid=0")
    if [[ "$check" -eq 0 ]]; then
        echo -e "${RED}Root access required but not available${ENDC}"
        read -p "Press Enter..."
        return 1
    fi
    return 0
}

_db_pick_app_id() {
    # Interactive app ID picker â€” search by keyword or exact match
    local prompt_msg="${1:-Select app}"
    local filter="${2:--3}"  # default third-party
    local pkgs
    pkgs=$($ADB -s "$SERIAL" shell pm list packages "$filter" 2>/dev/null | sed 's/package://' | sort)

    if [[ -z "$pkgs" ]]; then
        echo -e "${RED}No packages found${ENDC}"
        return 1
    fi

    echo -e "${CYAN}$prompt_msg${ENDC}"
    read -p "Enter package name or keyword: " keyword

    if [[ -z "$keyword" ]]; then
        echo -e "${RED}No input provided${ENDC}"
        return 1
    fi

    local matches
    matches=$(echo "$pkgs" | grep -i "$keyword")
    local count=$(echo "$matches" | grep -c .)

    if [[ "$count" -eq 0 ]]; then
        echo -e "${RED}No matching packages found for '$keyword'${ENDC}"
        return 1
    elif [[ "$count" -eq 1 ]]; then
        PICKED_APP=$(echo "$matches" | head -1)
        echo -e "${GREEN}Selected: $PICKED_APP${ENDC}"
        return 0
    else
        echo -e "${YELLOW}Multiple matches:${ENDC}"
        local i=0
        local arr=()
        while IFS= read -r line; do
            echo -e "  ${BOLD}$i)${ENDC} $line"
            arr+=("$line")
            ((i++))
        done <<< "$matches"

        read -p "Select number: " sel
        if [[ "$sel" =~ ^[0-9]+$ ]] && [[ "$sel" -ge 0 ]] && [[ "$sel" -lt "${#arr[@]}" ]]; then
            PICKED_APP="${arr[$sel]}"
            echo -e "${GREEN}Selected: $PICKED_APP${ENDC}"
            return 0
        else
            echo -e "${RED}Invalid selection${ENDC}"
            return 1
        fi
    fi
}

_db_pick_running_app() {
    local procs
    procs=$($ADB -s "$SERIAL" shell "ps -A 2>/dev/null" | awk '{print $9}' | grep -E '^\w+\.\w+' | grep -v ':' | sort -u)

    if [[ -z "$procs" ]]; then
        echo -e "${RED}No running apps detected${ENDC}"
        return 1
    fi

    echo -e "${CYAN}Running applications:${ENDC}"
    read -p "Enter package name or keyword: " keyword
    local matches
    matches=$(echo "$procs" | grep -i "$keyword")
    local count=$(echo "$matches" | grep -c .)

    if [[ "$count" -eq 0 ]]; then
        echo -e "${RED}No running app matches '$keyword'${ENDC}"
        return 1
    elif [[ "$count" -eq 1 ]]; then
        PICKED_APP=$(echo "$matches" | head -1)
        echo -e "${GREEN}Selected: $PICKED_APP${ENDC}"
        return 0
    else
        local i=0; local arr=()
        while IFS= read -r line; do
            echo -e "  ${BOLD}$i)${ENDC} $line"
            arr+=("$line"); ((i++))
        done <<< "$matches"
        read -p "Select number: " sel
        if [[ "$sel" =~ ^[0-9]+$ ]] && [[ "$sel" -ge 0 ]] && [[ "$sel" -lt "${#arr[@]}" ]]; then
            PICKED_APP="${arr[$sel]}"
            echo -e "${GREEN}Selected: $PICKED_APP${ENDC}"
            return 0
        fi
        echo -e "${RED}Invalid selection${ENDC}"; return 1
    fi
}

_db_get_pid() {
    local app_id="$1"
    $ADB -s "$SERIAL" shell pidof "$app_id" 2>/dev/null | tr -d '\r' | head -1
}

_db_get_pc_ip() {
    # Cross-platform PC WiFi IP detection
    if command -v ip &>/dev/null; then
        ip route get 1.1.1.1 2>/dev/null | awk '{print $7; exit}'
    elif command -v ifconfig &>/dev/null; then
        ifconfig | grep -A1 'wl\|en0\|wlan' | grep 'inet ' | awk '{print $2}' | head -1
    else
        hostname -I 2>/dev/null | awk '{print $1}'
    fi
}

_db_get_pc_wifi_ssid() {
    # Cross-platform PC WiFi SSID detection (from proxy.py)
    local os_type=$(uname -s)
    case "$os_type" in
        Linux)
            iwgetid -r 2>/dev/null ;;
        Darwin)
            networksetup -getairportnetwork en0 2>/dev/null | sed 's/Current Wi-Fi Network: //' ;;
        MINGW*|MSYS*|CYGWIN*)
            netsh wlan show interfaces 2>/dev/null | grep '^\s*SSID' | head -1 | sed 's/.*: //' ;;
    esac
}

_db_get_mobile_wifi_ssid() {
    local ssid=$($ADB -s "$SERIAL" shell "dumpsys netstats 2>/dev/null" | grep -oP 'networkId=\"\K[^"]+' | head -1)
    if [[ -z "$ssid" ]]; then
        ssid=$($ADB -s "$SERIAL" shell "dumpsys wifi 2>/dev/null" | grep -oP 'current SSID.*?ssid=\"\K[^"]+' | head -1)
    fi
    echo "$ssid"
}

_db_wifi_ssid_check() {
    # Compare PC and mobile WiFi SSIDs (from proxy.py)
    local pc_ssid=$(_db_get_pc_wifi_ssid)
    local mobile_ssid=$(_db_get_mobile_wifi_ssid)
    echo -e "\n${CYAN}WiFi SSIDs:${ENDC}"
    echo -e "  PC:     ${YELLOW}${pc_ssid:-Undetectable}${ENDC}"
    echo -e "  Mobile: ${YELLOW}${mobile_ssid:-Undetectable}${ENDC}"
    if [[ -n "$pc_ssid" ]] && [[ -n "$mobile_ssid" ]] && [[ "$pc_ssid" != "$mobile_ssid" ]]; then
        echo -e "  ${RED}âš  WARNING: PC and mobile are on DIFFERENT networks!${ENDC}"
        echo -e "  ${RED}  Connect both devices to the same WiFi network.${ENDC}"
        $ADB -s "$SERIAL" shell am start -a android.settings.WIFI_SETTINGS 2>/dev/null
    elif [[ -n "$pc_ssid" ]] && [[ -n "$mobile_ssid" ]]; then
        echo -e "  ${GREEN}âœ“ Same network${ENDC}"
    fi
    echo ""
}

_db_screen_lock() {
    # Screen lock toggle (from useful_stuff.py - keyevent 26)
    $ADB -s "$SERIAL" shell input keyevent 26 2>/dev/null
    echo -e "${GREEN}âœ“ Screen lock/unlock toggled${ENDC}"
}

_db_sd_path() {
    $ADB -s "$SERIAL" shell 'echo $EXTERNAL_STORAGE' 2>/dev/null | tr -d '\r'
}

_db_su_pull() {
    # Pull file from device with root fallback (from file_transfer.py su_download)
    local mobile_path="$1"
    local dest_path="$2"
    local sdcard=$(_db_sd_path)
    local rsc_name=$(basename "$mobile_path")

    # Try normal pull first
    local output=$($ADB -s "$SERIAL" pull "$mobile_path" "$dest_path" 2>&1)
    if echo "$output" | grep -qi "permission denied\|0 files pulled"; then
        echo -e "${YELLOW}Permission denied, trying with root...${ENDC}"
        $ADB -s "$SERIAL" shell "su -c 'cp -r $mobile_path $sdcard/$rsc_name && chmod -R 666 $sdcard/$rsc_name'" 2>/dev/null
        $ADB -s "$SERIAL" pull "$sdcard/$rsc_name" "$dest_path" 2>/dev/null
        $ADB -s "$SERIAL" shell "su -c 'rm -rf $sdcard/$rsc_name'" 2>/dev/null
        echo -e "${GREEN}âœ“ Pulled with root${ENDC}"
    else
        echo -e "${GREEN}âœ“ Pulled successfully${ENDC}"
    fi
}

_db_su_push() {
    # Push file to device with root fallback (from file_transfer.py upload_to_dest)
    local local_path="$1"
    local mobile_dest="$2"
    local sdcard=$(_db_sd_path)
    local rsc_name=$(basename "$local_path")

    local output=$($ADB -s "$SERIAL" push "$local_path" "$mobile_dest" 2>&1)
    if echo "$output" | grep -qi "failed\|error\|0 files pushed"; then
        echo -e "${YELLOW}Direct push failed, trying via sdcard + su move...${ENDC}"
        $ADB -s "$SERIAL" push "$local_path" "$sdcard/" 2>/dev/null
        $ADB -s "$SERIAL" shell "su -c 'mv $sdcard/$rsc_name $mobile_dest'" 2>/dev/null
        echo -e "${GREEN}âœ“ Pushed with root${ENDC}"
    else
        echo -e "${GREEN}âœ“ Pushed successfully${ENDC}"
    fi
}

# ============================================================
#  1. APK ANALYSIS (from apk_analyzer.py, app_info.py, signature.py)
# ============================================================

db_apk_analysis_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ”¬ APK ANALYSIS${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        echo "  1. Decompile APK (from file)"
        echo "  2. Decompile APK (from device)"
        echo "  3. Recompile APK"
        echo "  4. Certificate Pinning Hints"
        echo "  5. Root Detection Hints"
        echo "  6. Full APK Analysis (pinning + root)"
        echo "  7. APK Info & Permissions"
        echo "  8. Signature Verification"
        echo "  9. Sign APK (test key)"
        echo " 10. AAB â†’ APK Conversion"
        echo " 11. Launch JADX-GUI"
        echo " 12. Get APK from device"
        echo " 13. View app components (activities/services/receivers)"
        echo " 14. Enable WebView debugging"
        echo "  b. Back"
        echo ""
        read -p "Select: " opt
        case $opt in
            1) _db_decompile_apk_file ;;
            2) _db_ensure_device && _db_decompile_apk_device ;;
            3) _db_recompile_apk ;;
            4) _db_cert_pinning_hints ;;
            5) _db_root_detection_hints ;;
            6) _db_full_apk_analysis ;;
            7) _db_apk_info ;;
            8) _db_signature_verify ;;
            9) _db_sign_apk ;;
            10) _db_aab_to_apk ;;
            11) _db_jadx_gui ;;
            12) _db_ensure_device && _db_get_apk_from_device ;;
            13) _db_ensure_device && _db_app_components ;;
            14) _db_webview_debug ;;
            b|B) return ;;
            *) echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

_db_decompile_apk_file() {
    echo -e "${CYAN}Decompile APK from local file${ENDC}"
    read -ep "APK file path: " apk_path
    apk_path=$(eval echo "$apk_path")
    if [[ ! -f "$apk_path" ]] || [[ ! "$apk_path" == *.apk ]]; then
        echo -e "${RED}Invalid APK file${ENDC}"; read -p "Press Enter..."; return
    fi

    local app_id=$(aapt dump badging "$apk_path" 2>/dev/null | grep "package: name=" | sed "s/.*name='\([^']*\)'.*/\1/")
    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local out_dir="$DB_RESULTS_DIR/${app_id:-unknown}/decompiled/$ts"
    mkdir -p "$out_dir"

    echo -e "${BLUE}Decompiling with apktool...${ENDC}"
    if command -v apktool &>/dev/null; then
        apktool d -f -o "$out_dir" "$apk_path" 2>&1
        echo -e "${GREEN}âœ“ Decompiled to: $out_dir${ENDC}"
    else
        echo -e "${RED}apktool not found. Install it first.${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_decompile_apk_device() {
    _db_pick_app_id "Select app to decompile" || { read -p "Press Enter..."; return; }
    local app_id="$PICKED_APP"
    local ts=$(date +%Y-%m-%d_%H-%M-%S)

    echo -e "${BLUE}Getting APK path from device...${ENDC}"
    local apk_device_path=$($ADB -s "$SERIAL" shell pm path "$app_id" 2>/dev/null | head -1 | sed 's/package://' | tr -d '\r')

    if [[ -z "$apk_device_path" ]]; then
        echo -e "${RED}Could not find APK path for $app_id${ENDC}"; read -p "Press Enter..."; return
    fi

    local out_dir="$DB_RESULTS_DIR/$app_id/apk/$ts"
    mkdir -p "$out_dir"
    local local_apk="$out_dir/base.apk"

    echo -e "${BLUE}Pulling APK: $apk_device_path${ENDC}"
    _db_su_pull "$apk_device_path" "$local_apk"

    if [[ -f "$local_apk" ]]; then
        local decompiled_dir="$DB_RESULTS_DIR/$app_id/decompiled/$ts"
        mkdir -p "$decompiled_dir"
        echo -e "${BLUE}Decompiling...${ENDC}"
        apktool d -f -o "$decompiled_dir" "$local_apk" 2>&1
        echo -e "${GREEN}âœ“ Decompiled to: $decompiled_dir${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_recompile_apk() {
    echo -e "${CYAN}Recompile a decompiled APK directory${ENDC}"
    read -ep "Decompiled folder path: " src_dir
    src_dir=$(eval echo "$src_dir")
    if [[ ! -d "$src_dir" ]]; then
        echo -e "${RED}Invalid directory${ENDC}"; read -p "Press Enter..."; return
    fi

    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local out_apk="$DB_RESULTS_DIR/recompiled/${ts}_recompiled.apk"
    mkdir -p "$(dirname "$out_apk")"

    echo -e "${BLUE}Recompiling with apktool...${ENDC}"
    apktool b -o "$out_apk" "$src_dir" 2>&1

    if [[ -f "$out_apk" ]]; then
        echo -e "${GREEN}âœ“ Recompiled: $out_apk${ENDC}"
        read -p "Sign it with a test key? (y/n): " sign_yn
        if [[ "$sign_yn" == "y" ]]; then
            _db_do_sign "$out_apk"
        fi
    else
        echo -e "${RED}Recompilation failed${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_cert_pinning_hints() {
    echo -e "${CYAN}Scan decompiled APK for certificate pinning indicators${ENDC}"
    read -ep "Decompiled folder or APK path: " target
    target=$(eval echo "$target")

    local scan_dir="$target"
    if [[ -f "$target" ]] && [[ "$target" == *.apk ]]; then
        local tmp_dir=$(mktemp -d)
        apktool d -f -o "$tmp_dir" "$target" 2>/dev/null
        scan_dir="$tmp_dir"
    fi

    if [[ ! -d "$scan_dir" ]]; then
        echo -e "${RED}Invalid path${ENDC}"; read -p "Press Enter..."; return
    fi

    echo -e "\n${BOLD}${MAGENTA}=== CERTIFICATE PINNING HINTS ===${ENDC}\n"

    # OkHTTP indicators (from APK_ANALYSIS_DICT in apk_analyzer.py)
    echo -e "${YELLOW}â–¶ OkHTTP Patterns:${ENDC}"
    grep -rl --include="*.smali" -E "okhttp3|OkHttpClient|CertificatePinner|certificatePinner\(" "$scan_dir" 2>/dev/null | while read f; do
        echo -e "  ${GREEN}$(basename "$f")${ENDC}: $f"
    done

    # HttpsURLConnection
    echo -e "\n${YELLOW}â–¶ HttpsURLConnection Patterns:${ENDC}"
    grep -rl --include="*.smali" -E "X509TrustManager|HttpsURLConnection|javax/net/ssl" "$scan_dir" 2>/dev/null | while read f; do
        echo -e "  ${GREEN}$(basename "$f")${ENDC}: $f"
    done

    # TrustManager / SSLContext
    echo -e "\n${YELLOW}â–¶ TrustManager / SSLContext Patterns:${ENDC}"
    grep -rl --include="*.smali" -E "SSLContext|X509TrustManager|TrustManagerFactory" "$scan_dir" 2>/dev/null | while read f; do
        echo -e "  ${GREEN}$(basename "$f")${ENDC}: $f"
    done

    # Network Security Config in manifest
    echo -e "\n${YELLOW}â–¶ Network Security Config:${ENDC}"
    if [[ -f "$scan_dir/AndroidManifest.xml" ]]; then
        grep -oP 'android:networkSecurityConfig="[^"]*"' "$scan_dir/AndroidManifest.xml" 2>/dev/null && \
            echo -e "  ${GREEN}Found networkSecurityConfig declaration${ENDC}" || \
            echo -e "  ${BLUE}No networkSecurityConfig found in manifest${ENDC}"
    fi

    # SHA hash patterns
    echo -e "\n${YELLOW}â–¶ Embedded SHA Hash Strings:${ENDC}"
    grep -rn --include="*.smali" -oP '"[a-fA-F0-9]{64}"' "$scan_dir" 2>/dev/null | head -20
    grep -rn --include="*.smali" -oP '"[a-fA-F0-9]{40}"' "$scan_dir" 2>/dev/null | head -20

    # network_security_config.xml
    if [[ -f "$scan_dir/res/xml/network_security_config.xml" ]]; then
        echo -e "\n${YELLOW}â–¶ network_security_config.xml:${ENDC}"
        cat "$scan_dir/res/xml/network_security_config.xml"
    fi

    [[ -n "$tmp_dir" ]] && rm -rf "$tmp_dir"
    echo ""; read -p "Press Enter..."
}

_db_root_detection_hints() {
    echo -e "${CYAN}Scan decompiled APK for root detection indicators${ENDC}"
    read -ep "Decompiled folder or APK path: " target
    target=$(eval echo "$target")

    local scan_dir="$target"
    if [[ -f "$target" ]] && [[ "$target" == *.apk ]]; then
        local tmp_dir=$(mktemp -d)
        apktool d -f -o "$tmp_dir" "$target" 2>/dev/null
        scan_dir="$tmp_dir"
    fi

    if [[ ! -d "$scan_dir" ]]; then
        echo -e "${RED}Invalid path${ENDC}"; read -p "Press Enter..."; return
    fi

    echo -e "\n${BOLD}${MAGENTA}=== ROOT DETECTION HINTS ===${ENDC}\n"

    # RootBeer
    echo -e "${YELLOW}â–¶ RootBeer Library:${ENDC}"
    grep -rl --include="*.smali" -E "RootBeer|scottyab/rootbeer" "$scan_dir" 2>/dev/null | head -10 | while read f; do
        echo -e "  ${GREEN}$(basename "$f")${ENDC}: $f"
    done

    # Magisk
    echo -e "\n${YELLOW}â–¶ Magisk Detection:${ENDC}"
    grep -rl --include="*.smali" -iE "magisk|topjohnwu" "$scan_dir" 2>/dev/null | head -10 | while read f; do
        echo -e "  ${GREEN}$(basename "$f")${ENDC}: $f"
    done

    # SafetyNet
    echo -e "\n${YELLOW}â–¶ SafetyNet / Play Integrity:${ENDC}"
    grep -rl --include="*.smali" -E "SafetyNet|safetynet|SafetyNetApi|PlayIntegrity" "$scan_dir" 2>/dev/null | head -10 | while read f; do
        echo -e "  ${GREEN}$(basename "$f")${ENDC}: $f"
    done

    # General root checks (from APK_ANALYSIS_DICT)
    echo -e "\n${YELLOW}â–¶ General Root Binary/Path Checks:${ENDC}"
    grep -rn --include="*.smali" -E '/system/bin/su|/system/xbin/su|/data/local/tmp|Superuser\.apk|su\b' "$scan_dir" 2>/dev/null | head -20 | while read f; do
        echo -e "  ${BLUE}$f${ENDC}"
    done

    # System property checks
    echo -e "\n${YELLOW}â–¶ System Property Checks:${ENDC}"
    grep -rn --include="*.smali" -E 'ro\.debuggable|ro\.secure|ro\.build\.tags|test-keys|SELinux' "$scan_dir" 2>/dev/null | head -20 | while read f; do
        echo -e "  ${BLUE}$f${ENDC}"
    done

    # Root management apps
    echo -e "\n${YELLOW}â–¶ Root Management App Detection:${ENDC}"
    grep -rn --include="*.smali" -E 'noshufou\.android\.su|RootCloak|devadvance\.rootcloak|RootChecker|AntiRoot' "$scan_dir" 2>/dev/null | head -10

    [[ -n "$tmp_dir" ]] && rm -rf "$tmp_dir"
    echo ""; read -p "Press Enter..."
}

_db_full_apk_analysis() {
    echo -e "${CYAN}Full APK Analysis (certificate pinning + root detection + info)${ENDC}"
    read -ep "APK file path: " apk_path
    apk_path=$(eval echo "$apk_path")
    if [[ ! -f "$apk_path" ]] || [[ ! "$apk_path" == *.apk ]]; then
        echo -e "${RED}Invalid APK${ENDC}"; read -p "Press Enter..."; return
    fi

    local app_id=$(aapt dump badging "$apk_path" 2>/dev/null | grep "package: name=" | sed "s/.*name='\([^']*\)'.*/\1/")
    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local report_dir="$DB_RESULTS_DIR/${app_id:-unknown}/full_analysis/$ts"
    mkdir -p "$report_dir"

    # Info
    echo -e "\n${BOLD}${MAGENTA}=== APK INFO ===${ENDC}"
    _db_do_apk_info "$apk_path" | tee "$report_dir/apk_info.txt"

    # Decompile
    local decompiled="$report_dir/decompiled"
    echo -e "\n${BLUE}Decompiling...${ENDC}"
    apktool d -f -o "$decompiled" "$apk_path" 2>/dev/null

    # Cert Pinning
    echo -e "\n${BOLD}${MAGENTA}=== CERTIFICATE PINNING HINTS ===${ENDC}"
    {
        echo "=== OkHTTP ==="
        grep -rl --include="*.smali" -E "okhttp3|CertificatePinner" "$decompiled" 2>/dev/null
        echo "=== HttpsURLConnection ==="
        grep -rl --include="*.smali" -E "X509TrustManager|HttpsURLConnection" "$decompiled" 2>/dev/null
        echo "=== SSLContext ==="
        grep -rl --include="*.smali" -E "SSLContext|TrustManagerFactory" "$decompiled" 2>/dev/null
        echo "=== Network Security Config ==="
        grep -oP 'android:networkSecurityConfig="[^"]*"' "$decompiled/AndroidManifest.xml" 2>/dev/null
    } | tee "$report_dir/cert_pinning_hints.txt"

    # Root Detection
    echo -e "\n${BOLD}${MAGENTA}=== ROOT DETECTION HINTS ===${ENDC}"
    {
        echo "=== RootBeer ==="
        grep -rl --include="*.smali" -E "RootBeer|scottyab" "$decompiled" 2>/dev/null
        echo "=== Magisk ==="
        grep -rl --include="*.smali" -iE "magisk|topjohnwu" "$decompiled" 2>/dev/null
        echo "=== SafetyNet ==="
        grep -rl --include="*.smali" -E "SafetyNet|safetynet" "$decompiled" 2>/dev/null
        echo "=== Root Binaries ==="
        grep -rl --include="*.smali" -E '/system/bin/su|/system/xbin/su|Superuser' "$decompiled" 2>/dev/null
    } | tee "$report_dir/root_detection_hints.txt"

    # Signature
    if command -v apksigner &>/dev/null; then
        echo -e "\n${BOLD}${MAGENTA}=== SIGNATURE ===${ENDC}"
        apksigner verify --verbose --print-certs "$apk_path" 2>&1 | tee "$report_dir/signature.txt"
    fi

    echo -e "\n${GREEN}âœ“ Full report saved to: $report_dir${ENDC}"
    read -p "Press Enter..."
}

_db_do_apk_info() {
    local apk_path="$1"
    # SHA hashes
    echo "SHA1:   $(sha1sum "$apk_path" | awk '{print $1}')"
    echo "SHA256: $(sha256sum "$apk_path" | awk '{print $1}')"
    echo ""
    # aapt info
    aapt dump badging "$apk_path" 2>/dev/null | grep -E "^package:|^sdkVersion:|^targetSdkVersion:|^uses-permission:" | \
        sed 's/uses-permission: name=/PERM: /'
}

_db_apk_info() {
    echo -e "${CYAN}APK Info & Permissions${ENDC}"
    read -ep "APK file path: " apk_path
    apk_path=$(eval echo "$apk_path")
    if [[ ! -f "$apk_path" ]]; then
        echo -e "${RED}File not found${ENDC}"; read -p "Press Enter..."; return
    fi
    _db_do_apk_info "$apk_path"
    read -p "Press Enter..."
}

_db_signature_verify() {
    echo -e "${CYAN}Verify APK Signature Scheme${ENDC}"
    read -ep "APK file path: " apk_path
    apk_path=$(eval echo "$apk_path")
    if [[ ! -f "$apk_path" ]]; then
        echo -e "${RED}File not found${ENDC}"; read -p "Press Enter..."; return
    fi
    if command -v apksigner &>/dev/null; then
        # Scheme verification (from signature.py scheme_verify)
        echo -e "\n${BOLD}${YELLOW}Signing Scheme Verification:${ENDC}"
        local verify_out=$(apksigner verify --verbose "$apk_path" 2>&1)
        echo "$verify_out" | while IFS= read -r line; do
            if echo "$line" | grep -q "true"; then
                echo -e "  ${GREEN}$line${ENDC}"
            elif echo "$line" | grep -q "false"; then
                echo -e "  ${RED}$line${ENDC}"
            elif echo "$line" | grep -qi "WARNING"; then
                echo -e "  ${YELLOW}$line${ENDC}"
            else
                echo "  $line"
            fi
        done

        # Certificate details (from signature.py certificate_info)
        echo -e "\n${BOLD}${YELLOW}Certificate Details:${ENDC}"
        local cert_out=$(apksigner verify --print-certs "$apk_path" 2>&1)
        echo "$cert_out" | while IFS= read -r line; do
            if echo "$line" | grep -q "DN:"; then
                echo -e "  ${CYAN}$line${ENDC}"
            elif echo "$line" | grep -q "SHA-256"; then
                echo -e "  ${GREEN}$line${ENDC}"
            elif echo "$line" | grep -q "SHA-1"; then
                echo -e "  ${YELLOW}$line${ENDC}"
            elif echo "$line" | grep -q "MD5"; then
                echo -e "  ${MAGENTA}$line${ENDC}"
            else
                echo "  $line"
            fi
        done
    else
        echo -e "${RED}apksigner not found. Install Android build-tools.${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_do_sign() {
    local apk_path="$1"
    local ks_path="${apk_path%.apk}_testkey.jks"
    local password="droidBTestKey2025"
    local alias="testkey"

    echo -e "${BLUE}Creating test keystore...${ENDC}"
    keytool -genkeypair -v -keystore "$ks_path" -keyalg RSA -keysize 2048 \
        -validity 10000 -alias "$alias" -storepass "$password" -keypass "$password" \
        -dname "CN=droidB Test,OU=Security,O=droidB,L=Test,ST=T,C=US" 2>/dev/null

    echo -e "${BLUE}Signing APK...${ENDC}"
    apksigner sign --ks "$ks_path" --ks-pass "pass:$password" --key-pass "pass:$password" \
        --v1-signing-enabled true --v2-signing-enabled true "$apk_path" 2>&1

    echo -e "${GREEN}âœ“ Signed: $apk_path${ENDC}"
    rm -f "$ks_path"
}

_db_sign_apk() {
    echo -e "${CYAN}Sign APK with test key${ENDC}"
    read -ep "APK file path: " apk_path
    apk_path=$(eval echo "$apk_path")
    if [[ ! -f "$apk_path" ]]; then
        echo -e "${RED}File not found${ENDC}"; read -p "Press Enter..."; return
    fi
    if ! command -v apksigner &>/dev/null || ! command -v keytool &>/dev/null; then
        echo -e "${RED}apksigner/keytool not found${ENDC}"; read -p "Press Enter..."; return
    fi
    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local dest="$DB_RESULTS_DIR/signed/${ts}_$(basename "$apk_path")"
    mkdir -p "$(dirname "$dest")"
    cp "$apk_path" "$dest"
    _db_do_sign "$dest"
    read -p "Press Enter..."
}

_db_aab_to_apk() {
    echo -e "${CYAN}Convert AAB to APK (requires bundletool)${ENDC}"
    read -ep "AAB file path: " aab_path
    aab_path=$(eval echo "$aab_path")
    if [[ ! -f "$aab_path" ]] || [[ ! "$aab_path" == *.aab ]]; then
        echo -e "${RED}Invalid AAB file${ENDC}"; read -p "Press Enter..."; return
    fi

    if ! command -v bundletool &>/dev/null; then
        echo -e "${RED}bundletool not found${ENDC}"; read -p "Press Enter..."; return
    fi

    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local out_dir="$DB_RESULTS_DIR/aab_to_apk/$ts"
    mkdir -p "$out_dir"
    local ks="$out_dir/tmp.jks"
    local pw="TmpPass123"
    local alias="tmpkey"

    keytool -genkeypair -v -keystore "$ks" -keyalg RSA -keysize 2048 -validity 1000 \
        -alias "$alias" -storepass "$pw" -keypass "$pw" \
        -dname "CN=tmp,OU=tmp,O=tmp,L=tmp,ST=T,C=US" 2>/dev/null

    local apks="$out_dir/output.apks"
    bundletool build-apks --mode=universal --bundle="$aab_path" --output="$apks" \
        --ks="$ks" --ks-pass="pass:$pw" --key-pass="pass:$pw" --ks-key-alias="$alias" 2>&1

    if [[ -f "$apks" ]]; then
        unzip -o "$apks" universal.apk -d "$out_dir" 2>/dev/null
        echo -e "${GREEN}âœ“ APK extracted: $out_dir/universal.apk${ENDC}"
    else
        echo -e "${RED}Conversion failed${ENDC}"
    fi
    rm -f "$ks"
    read -p "Press Enter..."
}

_db_jadx_gui() {
    echo -e "${CYAN}Launch JADX-GUI${ENDC}"
    if command -v jadx-gui &>/dev/null; then
        read -ep "APK/DEX/JAR file (or leave blank): " target
        target=$(eval echo "$target")
        if [[ -n "$target" ]] && [[ -f "$target" ]]; then
            jadx-gui "$target" &
        else
            jadx-gui &
        fi
        echo -e "${GREEN}âœ“ JADX-GUI launched in background${ENDC}"
    else
        echo -e "${RED}jadx-gui not found. Install JADX first.${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_get_apk_from_device() {
    _db_pick_app_id "Select app to pull APK from" || { read -p "Press Enter..."; return; }
    local app_id="$PICKED_APP"
    local ts=$(date +%Y-%m-%d_%H-%M-%S)

    local apk_paths=$($ADB -s "$SERIAL" shell pm path "$app_id" 2>/dev/null | sed 's/package://' | tr -d '\r')
    local out_dir="$DB_RESULTS_DIR/$app_id/apk/$ts"
    mkdir -p "$out_dir"

    while IFS= read -r apk_path; do
        [[ -z "$apk_path" ]] && continue
        local fname=$(basename "$apk_path")
        echo -e "${BLUE}Pulling: $apk_path${ENDC}"
        _db_su_pull "$apk_path" "$out_dir/$fname"
    done <<< "$apk_paths"

    echo -e "${GREEN}âœ“ APKs saved to: $out_dir${ENDC}"
    read -p "Press Enter..."
}

# ============================================================
#  2. SECRETS SCANNER (from advanced_search.py)
# ============================================================

db_secrets_scanner_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ” SECRETS SCANNER${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        echo "  1. Full Secrets Search (all patterns)"
        echo "  2. Light Secrets Search (high-confidence only)"
        echo "  3. Custom String Search"
        echo "  4. String Replace in Files"
        echo "  b. Back"
        echo ""
        read -p "Select: " opt
        case $opt in
            1) _db_secrets_search full ;;
            2) _db_secrets_search light ;;
            3) _db_string_search ;;
            4) _db_string_replace ;;
            b|B) return ;;
            *) echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

_db_secrets_search() {
    local mode="$1"
    echo -e "${CYAN}Secrets Search ($mode mode)${ENDC}"
    read -ep "Target path (file or folder): " target
    target=$(eval echo "$target")
    if [[ ! -e "$target" ]]; then
        echo -e "${RED}Path not found${ENDC}"; read -p "Press Enter..."; return
    fi

    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local out_dir="$DB_RESULTS_DIR/secrets_scan"
    mkdir -p "$out_dir"
    local report="$out_dir/${ts}_${mode}_secrets.txt"

    echo -e "${BLUE}Scanning... (this may take a while for large directories)${ENDC}"

    {
        echo "=== droidB Secrets Scanner â€” $mode mode ==="
        echo "Target: $target"
        echo "Date: $ts"
        echo ""

        # AWS Keys (high confidence â€” both modes)
        echo "--- AWS Access Key IDs ---"
        grep -rn --include="*.{xml,json,properties,smali,java,kt,py,js,txt,cfg,ini,yml,yaml,env,conf}" \
            -oP '(AKIA|A3T|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{12,}' "$target" 2>/dev/null

        echo "--- AWS S3 Buckets ---"
        grep -rn -oP '[a-z0-9.-]+\.s3[.-][a-z0-9-]*\.amazonaws\.com' "$target" 2>/dev/null

        echo "--- AWS RDS Hostnames ---"
        grep -rn -oP '[a-z0-9-]+\.rds\.amazonaws\.com' "$target" 2>/dev/null

        # API Keys / Tokens (high confidence)
        echo "--- Bearer Tokens ---"
        grep -rn -oiP '[Bb]earer\s+[a-zA-Z0-9\-._~+/]+={0,2}' "$target" 2>/dev/null | head -50

        echo "--- Authorization Basic ---"
        grep -rn -oiP 'basic\s+[a-zA-Z0-9_\-:.=]+' "$target" 2>/dev/null | head -30

        echo "--- Private Keys ---"
        grep -rn -l 'BEGIN.*PRIVATE KEY' "$target" 2>/dev/null

        echo "--- API Key Assignments ---"
        grep -rn -oiP '(apikey|api_key|api-key|secret|token|password|passwd|pwd)['"'"'"\s:=]+[a-zA-Z0-9\-._]{8,}' "$target" 2>/dev/null | head -100

        # Google-specific
        echo "--- Google API Keys ---"
        grep -rn -oP 'AIza[0-9A-Za-z_-]{35}' "$target" 2>/dev/null

        # Firebase
        echo "--- Firebase URLs ---"
        grep -rn -oP '[a-z0-9.-]+\.firebaseio\.com' "$target" 2>/dev/null
        grep -rn -oP '[a-z0-9.-]+\.firebaseapp\.com' "$target" 2>/dev/null

        # Slack
        echo "--- Slack Tokens ---"
        grep -rn -oP 'xox[baprs]-[0-9a-zA-Z-]+' "$target" 2>/dev/null

        # Discord
        echo "--- Discord Webhooks ---"
        grep -rn -oP 'https://discord(app)?\.com/api/webhooks/[0-9]+/[a-zA-Z0-9_-]+' "$target" 2>/dev/null

        # GitHub
        echo "--- GitHub Tokens ---"
        grep -rn -oP '(ghp|gho|ghu|ghs|ghr)_[A-Za-z0-9_]{36,}' "$target" 2>/dev/null

        # URLs with credentials
        echo "--- URLs with Embedded Credentials ---"
        grep -rn -oP 'https?://[a-zA-Z0-9]+:[a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z]+' "$target" 2>/dev/null

        # Dev/staging URLs
        echo "--- Dev/Staging URLs ---"
        grep -rn -oP '(dev|staging|test)\.[a-z0-9.-]+\.(com|net|io)' "$target" 2>/dev/null | head -30

        if [[ "$mode" == "full" ]]; then
            # Full mode â€” more patterns with higher false positive rates

            echo "--- High-Entropy Base64 Strings ---"
            grep -rn -oP '"[A-Za-z0-9+/]{40,}={0,2}"' "$target" 2>/dev/null | head -50

            echo "--- Hex Strings (32+ chars) ---"
            grep -rn -oP '"[a-fA-F0-9]{32,}"' "$target" 2>/dev/null | head -50

            echo "--- Basic Auth Patterns ---"
            grep -rn -oiP '(username|user|email).*?(password|pwd|passwd)' "$target" 2>/dev/null | head -30

            echo "--- DigitalOcean Tokens ---"
            grep -rn -oP 'dop_v1_[a-z0-9]{64}' "$target" 2>/dev/null

            echo "--- Cloudinary ---"
            grep -rn -oP 'cloudinary://[0-9]+:[0-9A-Za-z]+@[a-z]+' "$target" 2>/dev/null

            echo "--- Twilio ---"
            grep -rn -oP 'SK[0-9a-fA-F]{32}' "$target" 2>/dev/null

            echo "--- Stripe ---"
            grep -rn -oP '(sk|pk)_(test|live)_[0-9a-zA-Z]{24,}' "$target" 2>/dev/null

            echo "--- SendGrid ---"
            grep -rn -oP 'SG\.[a-zA-Z0-9_-]{22}\.[a-zA-Z0-9_-]{43}' "$target" 2>/dev/null

            echo "--- Mailgun ---"
            grep -rn -oP 'key-[0-9a-zA-Z]{32}' "$target" 2>/dev/null

            echo "--- JWT Tokens ---"
            grep -rn -oP 'eyJ[a-zA-Z0-9_-]*\.eyJ[a-zA-Z0-9_-]*\.[a-zA-Z0-9_-]*' "$target" 2>/dev/null | head -20
        fi

    } 2>/dev/null | tee "$report"

    local total=$(grep -c '.' "$report" 2>/dev/null)
    echo -e "\n${GREEN}âœ“ Scan complete â€” $total lines of output${ENDC}"
    echo -e "${GREEN}Report saved: $report${ENDC}"
    read -p "Press Enter..."
}

_db_string_search() {
    echo -e "${CYAN}Search for a custom string/bytes in all files${ENDC}"
    read -ep "Target path (file or folder): " target
    target=$(eval echo "$target")
    if [[ ! -e "$target" ]]; then
        echo -e "${RED}Path not found${ENDC}"; read -p "Press Enter..."; return
    fi
    read -p "Search string: " search_str
    if [[ -z "$search_str" ]]; then
        echo -e "${RED}Empty search${ENDC}"; read -p "Press Enter..."; return
    fi

    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local out_dir="$DB_RESULTS_DIR/string_search"
    mkdir -p "$out_dir"
    local report="$out_dir/${ts}_search.txt"

    echo -e "${BLUE}Searching...${ENDC}"
    if [[ "$search_str" == 0x* ]]; then
        # Hex byte search
        local hex="${search_str#0x}"
        grep -rn --include="*" -oP "$(echo "$hex" | sed 's/../\\x&/g')" "$target" 2>/dev/null | tee "$report"
    else
        grep -rin "$search_str" "$target" 2>/dev/null | tee "$report"
    fi

    local total=$(wc -l < "$report" 2>/dev/null)
    echo -e "\n${GREEN}Found $total matches â€” saved to $report${ENDC}"
    read -p "Press Enter..."
}

_db_string_replace() {
    echo -e "${CYAN}Search & Replace string/bytes in all files${ENDC}"
    read -ep "Target path (file or folder): " target
    target=$(eval echo "$target")
    if [[ ! -e "$target" ]]; then
        echo -e "${RED}Path not found${ENDC}"; read -p "Press Enter..."; return
    fi
    read -p "Search string: " search_str
    read -p "Replace with: " replace_str

    if [[ -z "$search_str" ]]; then
        echo -e "${RED}Empty search${ENDC}"; read -p "Press Enter..."; return
    fi

    echo -e "${RED}âš  This will MODIFY files in-place!${ENDC}"
    read -p "Continue? (y/n): " yn
    [[ "$yn" != "y" ]] && return

    echo -e "${BLUE}Replacing...${ENDC}"
    if [[ -f "$target" ]]; then
        local count=$(grep -c "$search_str" "$target" 2>/dev/null)
        sed -i "s|$search_str|$replace_str|g" "$target"
        echo -e "  $target: ${GREEN}$count replacements${ENDC}"
    else
        find "$target" -type f -print0 2>/dev/null | while IFS= read -r -d '' file; do
            local count=$(grep -c "$search_str" "$file" 2>/dev/null)
            if [[ "$count" -gt 0 ]]; then
                sed -i "s|$search_str|$replace_str|g" "$file"
                echo -e "  $file: ${GREEN}$count replacements${ENDC}"
            fi
        done
    fi
    echo -e "${GREEN}âœ“ Done${ENDC}"
    read -p "Press Enter..."
}

# ============================================================
#  3. FRIDA INTEGRATION (from frida_integration.py)
# ============================================================

db_frida_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸª FRIDA INTEGRATION${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"

        # Show status
        local frida_pc=$(pip show frida 2>/dev/null | grep "^Version:" | awk '{print $2}')
        local frida_tools=$(pip show frida-tools 2>/dev/null | grep "^Version:" | awk '{print $2}')
        [[ -n "$frida_pc" ]] && echo -e "  ${GREEN}frida: $frida_pc${ENDC}" || echo -e "  ${RED}frida: not installed${ENDC}"
        [[ -n "$frida_tools" ]] && echo -e "  ${GREEN}frida-tools: $frida_tools${ENDC}" || echo -e "  ${RED}frida-tools: not installed${ENDC}"

        if [[ -n "$SERIAL" ]]; then
            local srv=$($ADB -s "$SERIAL" shell "su -c 'ps -A 2>/dev/null'" 2>/dev/null | grep frida-server)
            [[ -n "$srv" ]] && echo -e "  ${GREEN}Server: RUNNING${ENDC}" || echo -e "  ${YELLOW}Server: not running${ENDC}"
        fi
        echo ""

        echo "  1. Install Frida (PC: pip)"
        echo "  2. Download & Push Frida-Server to Device"
        echo "  3. Start Frida Server"
        echo "  4. Stop Frida Server"
        echo "  5. Run Script on Running App"
        echo "  6. Spawn App & Run Script"
        echo "  7. List Frida Scripts"
        echo "  8. Check Installed Versions"
        echo "  9. Uninstall Frida (PC)"
        echo " 10. Uninstall Frida Server (Device)"
        echo "  b. Back"
        echo ""
        read -p "Select: " opt
        case $opt in
            1) _db_frida_install_pc ;;
            2) _db_ensure_device && _db_frida_push_server ;;
            3) _db_ensure_device && _db_frida_start_server ;;
            4) _db_ensure_device && _db_frida_stop_server ;;
            5) _db_ensure_device && _db_frida_run_running ;;
            6) _db_ensure_device && _db_frida_run_spawn ;;
            7) _db_frida_list_scripts ;;
            8) _db_frida_versions ;;
            9) _db_frida_uninstall_pc ;;
            10) _db_ensure_device && _db_frida_uninstall_server ;;
            b|B) return ;;
            *) echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

_db_frida_install_pc() {
    echo -e "${CYAN}Install Frida & Frida-Tools via pip${ENDC}"
    read -p "Version (blank for latest): " ver
    if [[ -n "$ver" ]]; then
        pip install "frida==$ver" "frida-tools" 2>&1
    else
        pip install frida frida-tools 2>&1
    fi
    echo -e "${GREEN}âœ“ Done${ENDC}"
    read -p "Press Enter..."
}

_db_frida_push_server() {
    _db_ensure_root || return

    local arch=$($ADB -s "$SERIAL" shell getprop ro.product.cpu.abi 2>/dev/null | tr -d '\r')
    local frida_ver=$(pip show frida 2>/dev/null | grep "^Version:" | awk '{print $2}')

    if [[ -z "$frida_ver" ]]; then
        echo -e "${RED}Frida not installed on PC. Install first.${ENDC}"; read -p "Press Enter..."; return
    fi

    # Map Android ABI to frida binary name
    local frida_arch=""
    case "$arch" in
        arm64*|aarch64*) frida_arch="arm64" ;;
        armeabi*|arm*) frida_arch="arm" ;;
        x86_64*) frida_arch="x86_64" ;;
        x86*) frida_arch="x86" ;;
        *) echo -e "${RED}Unknown arch: $arch${ENDC}"; read -p "Press Enter..."; return ;;
    esac

    local url="https://github.com/frida/frida/releases/download/${frida_ver}/frida-server-${frida_ver}-android-${frida_arch}.xz"
    local dl_path="/tmp/frida-server.xz"
    local bin_path="/tmp/frida-server"

    echo -e "${BLUE}Downloading frida-server $frida_ver for $frida_arch...${ENDC}"
    echo -e "${YELLOW}URL: $url${ENDC}"

    if command -v curl &>/dev/null; then
        curl -L -o "$dl_path" "$url" 2>&1
    elif command -v wget &>/dev/null; then
        wget -O "$dl_path" "$url" 2>&1
    else
        echo -e "${RED}Neither curl nor wget found${ENDC}"; read -p "Press Enter..."; return
    fi

    if [[ ! -f "$dl_path" ]]; then
        echo -e "${RED}Download failed${ENDC}"; read -p "Press Enter..."; return
    fi

    echo -e "${BLUE}Extracting...${ENDC}"
    xz -df "$dl_path" 2>/dev/null
    mv "${dl_path%.xz}" "$bin_path" 2>/dev/null || mv "$dl_path" "$bin_path" 2>/dev/null

    echo -e "${BLUE}Pushing to device...${ENDC}"
    $ADB -s "$SERIAL" shell "su -c 'mkdir -p /data/local/tmp/frida-servers'" 2>/dev/null
    $ADB -s "$SERIAL" push "$bin_path" "/data/local/tmp/frida-servers/frida-server" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'chmod 755 /data/local/tmp/frida-servers/frida-server'" 2>/dev/null

    rm -f "$bin_path"
    echo -e "${GREEN}âœ“ frida-server pushed to /data/local/tmp/frida-servers/${ENDC}"
    read -p "Press Enter..."
}

_db_frida_start_server() {
    _db_ensure_root || return

    local running=$($ADB -s "$SERIAL" shell "su -c 'ps -A'" 2>/dev/null | grep frida-server)
    if [[ -n "$running" ]]; then
        echo -e "${GREEN}Frida server already running${ENDC}"
        read -p "Press Enter..."; return
    fi

    # Find frida-server binary
    local srv=$($ADB -s "$SERIAL" shell "su -c 'ls /data/local/tmp/frida-server*  /data/local/tmp/frida-servers/frida-server* 2>/dev/null'" 2>/dev/null | tr -d '\r' | head -1)
    if [[ -z "$srv" ]]; then
        echo -e "${RED}No frida-server binary found on device${ENDC}"; read -p "Press Enter..."; return
    fi

    echo -e "${BLUE}Starting frida-server: $srv${ENDC}"
    $ADB -s "$SERIAL" shell "su -c '$srv &'" &>/dev/null &
    sleep 2

    local check=$($ADB -s "$SERIAL" shell "su -c 'ps -A'" 2>/dev/null | grep frida-server)
    if [[ -n "$check" ]]; then
        echo -e "${GREEN}âœ“ Frida server started${ENDC}"
    else
        echo -e "${RED}Failed to start frida-server${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_frida_stop_server() {
    local pid=$($ADB -s "$SERIAL" shell "su -c 'ps -A'" 2>/dev/null | grep frida-server | awk '{print $2}')
    if [[ -n "$pid" ]]; then
        $ADB -s "$SERIAL" shell "su -c 'kill -9 $pid'" 2>/dev/null
        echo -e "${GREEN}âœ“ Frida server stopped (PID: $pid)${ENDC}"
    else
        echo -e "${YELLOW}No frida-server running${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_frida_select_scripts() {
    # Interactive script selector â€” returns selected scripts in SELECTED_SCRIPTS
    SELECTED_SCRIPTS=()
    local scripts_dir="$DB_FRIDA_SCRIPTS_DIR"

    if [[ ! -d "$scripts_dir" ]]; then
        echo -e "${YELLOW}No frida_scripts directory found. Enter path:${ENDC}"
        read -ep "Scripts directory: " scripts_dir
        scripts_dir=$(eval echo "$scripts_dir")
    fi

    if [[ ! -d "$scripts_dir" ]]; then
        echo -e "${RED}Directory not found${ENDC}"; return 1
    fi

    local scripts=($(ls "$scripts_dir"/*.js 2>/dev/null))
    if [[ ${#scripts[@]} -eq 0 ]]; then
        echo -e "${RED}No .js scripts found in $scripts_dir${ENDC}"; return 1
    fi

    echo -e "${CYAN}Available Frida scripts:${ENDC}"
    local i=0
    for s in "${scripts[@]}"; do
        local name=$(basename "$s" .js | tr '_' ' ')
        echo -e "  ${BOLD}$i)${ENDC} $name"
        ((i++))
    done

    echo -e "\n${YELLOW}Enter numbers separated by spaces (e.g. 0 2 4):${ENDC}"
    read -p "> " selections

    for sel in $selections; do
        if [[ "$sel" =~ ^[0-9]+$ ]] && [[ "$sel" -lt "${#scripts[@]}" ]]; then
            SELECTED_SCRIPTS+=("${scripts[$sel]}")
        fi
    done

    if [[ ${#SELECTED_SCRIPTS[@]} -eq 0 ]]; then
        echo -e "${RED}No scripts selected${ENDC}"; return 1
    fi
    return 0
}

_db_frida_run_running() {
    _db_frida_select_scripts || { read -p "Press Enter..."; return; }

    # Merge scripts
    local merged=$(mktemp /tmp/frida_merged_XXXXXX.js)
    for s in "${SELECTED_SCRIPTS[@]}"; do
        echo "// === $(basename "$s") ===" >> "$merged"
        cat "$s" >> "$merged"
        echo "" >> "$merged"
    done

    echo -e "${CYAN}Select target process:${ENDC}"
    _db_pick_running_app || { rm -f "$merged"; read -p "Press Enter..."; return; }

    echo -e "${BLUE}Running frida on $PICKED_APP with ${#SELECTED_SCRIPTS[@]} script(s)...${ENDC}"
    echo -e "${YELLOW}Press Ctrl+C to detach${ENDC}"
    frida -U -n "$PICKED_APP" -l "$merged" 2>&1
    rm -f "$merged"
    read -p "Press Enter..."
}

_db_frida_run_spawn() {
    _db_frida_select_scripts || { read -p "Press Enter..."; return; }

    local merged=$(mktemp /tmp/frida_merged_XXXXXX.js)
    for s in "${SELECTED_SCRIPTS[@]}"; do
        echo "// === $(basename "$s") ===" >> "$merged"
        cat "$s" >> "$merged"
        echo "" >> "$merged"
    done

    _db_pick_app_id "Select app to spawn" || { rm -f "$merged"; read -p "Press Enter..."; return; }

    echo -e "${BLUE}Spawning $PICKED_APP with ${#SELECTED_SCRIPTS[@]} script(s)...${ENDC}"
    echo -e "${YELLOW}Press Ctrl+C to detach${ENDC}"
    frida -U -f "$PICKED_APP" -l "$merged" --no-pause 2>&1
    rm -f "$merged"
    read -p "Press Enter..."
}

_db_frida_list_scripts() {
    local scripts_dir="$DB_FRIDA_SCRIPTS_DIR"
    if [[ ! -d "$scripts_dir" ]]; then
        read -ep "Scripts directory: " scripts_dir
        scripts_dir=$(eval echo "$scripts_dir")
    fi
    if [[ -d "$scripts_dir" ]]; then
        echo -e "${CYAN}Available Frida scripts:${ENDC}"
        ls -la "$scripts_dir"/*.js 2>/dev/null | awk '{print $NF}' | while read f; do
            echo -e "  ${GREEN}$(basename "$f" .js | tr '_' ' ')${ENDC} ($f)"
        done
    else
        echo -e "${RED}No scripts directory found${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_frida_versions() {
    echo -e "${CYAN}Frida Versions:${ENDC}"
    echo -n "  PC frida: "; pip show frida 2>/dev/null | grep "^Version:" | awk '{print $2}' || echo "not installed"
    echo -n "  PC frida-tools: "; pip show frida-tools 2>/dev/null | grep "^Version:" | awk '{print $2}' || echo "not installed"
    if [[ -n "$SERIAL" ]]; then
        echo -n "  Device frida-server: "
        local bins=$($ADB -s "$SERIAL" shell "ls /data/local/tmp/frida-server* /data/local/tmp/frida-servers/* 2>/dev/null" | tr -d '\r')
        [[ -n "$bins" ]] && echo "$bins" || echo "not found"
    fi
    read -p "Press Enter..."
}

_db_frida_uninstall_pc() {
    echo -e "${BLUE}Uninstalling frida & frida-tools...${ENDC}"
    pip uninstall -y frida frida-tools 2>&1
    echo -e "${GREEN}âœ“ Done${ENDC}"
    read -p "Press Enter..."
}

_db_frida_uninstall_server() {
    _db_ensure_root || return
    echo -e "${BLUE}Removing frida-server from device...${ENDC}"
    $ADB -s "$SERIAL" shell "su -c 'rm -rf /data/local/tmp/frida-server* /data/local/tmp/frida-servers'" 2>/dev/null
    echo -e "${GREEN}âœ“ Done${ENDC}"
    read -p "Press Enter..."
}

# ============================================================
#  4. PROXY & TRAFFIC (from proxy.py, dns_spoofing.py)
# ============================================================

db_proxy_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸŒ PROXY & TRAFFIC INTERCEPTION${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        _db_ensure_device || return

        local proxy=$($ADB -s "$SERIAL" shell settings get global http_proxy 2>/dev/null | tr -d '\r')
        [[ "$proxy" == ":0" || -z "$proxy" ]] && proxy="NONE"
        echo -e "  Current system proxy: ${YELLOW}$proxy${ENDC}\n"

        echo "  --- System Proxy ---"
        echo "  1. Set proxy (current PC IP)"
        echo "  2. Set proxy (custom IP:port)"
        echo "  3. Show current proxy"
        echo "  4. Remove proxy"
        echo ""
        echo "  --- Invisible Proxy (iptables) ---"
        echo "  5. Set invisible proxy â€” per app (current PC)"
        echo "  6. Set invisible proxy â€” global (current PC)"
        echo "  7. Set invisible proxy â€” custom IP"
        echo "  8. Show current iptables rules"
        echo "  9. Flush iptables (remove invisible proxy)"
        echo ""
        echo "  --- DNS Spoofing ---"
        echo " 10. Start DNS spoof (current PC IP)"
        echo " 11. Start DNS spoof (custom IP)"
        echo " 12. Stop DNS spoof"
        echo ""
        echo "  b. Back"
        echo ""
        read -p "Select: " opt
        case $opt in
            1) _db_proxy_set_pc ;;
            2) _db_proxy_set_custom ;;
            3) _db_proxy_show ;;
            4) _db_proxy_remove ;;
            5) _db_invisible_proxy_app ;;
            6) _db_invisible_proxy_global_pc ;;
            7) _db_invisible_proxy_custom ;;
            8) _db_invisible_proxy_show_detailed ;;
            9) _db_invisible_proxy_flush ;;
            10) _db_dns_spoof_pc ;;
            11) _db_dns_spoof_custom ;;
            12) _db_dns_spoof_stop ;;
            b|B) return ;;
            *) echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

_db_proxy_set_pc() {
    _db_wifi_ssid_check
    local ip=$(_db_get_pc_ip)
    read -p "Port (e.g. 8080): " port
    $ADB -s "$SERIAL" shell settings put global http_proxy "${ip}:${port}" 2>/dev/null
    echo -e "${GREEN}âœ“ Proxy set to ${ip}:${port}${ENDC}"
    read -p "Press Enter..."
}

_db_proxy_set_custom() {
    read -p "IP:Port (e.g. 192.168.1.100:8080): " addr
    $ADB -s "$SERIAL" shell settings put global http_proxy "$addr" 2>/dev/null
    echo -e "${GREEN}âœ“ Proxy set to $addr${ENDC}"
    read -p "Press Enter..."
}

_db_proxy_show() {
    local proxy=$($ADB -s "$SERIAL" shell settings get global http_proxy 2>/dev/null | tr -d '\r')
    [[ "$proxy" == ":0" || -z "$proxy" ]] && proxy="NONE"
    echo -e "System proxy: ${YELLOW}$proxy${ENDC}"
    read -p "Press Enter..."
}

_db_proxy_remove() {
    $ADB -s "$SERIAL" shell settings put global http_proxy ":0" 2>/dev/null
    echo -e "${GREEN}âœ“ Proxy removed${ENDC}"
    read -p "Press Enter..."
}

_db_invisible_proxy_app() {
    _db_ensure_root || return
    _db_wifi_ssid_check
    _db_pick_app_id "Select app for invisible proxy" || { read -p "Press Enter..."; return; }

    local uid=$($ADB -s "$SERIAL" shell "pm list packages -U 2>/dev/null" | grep "$PICKED_APP" | grep -oP 'uid:\K[0-9]+')
    if [[ -z "$uid" ]]; then
        echo -e "${RED}Could not get UID for $PICKED_APP${ENDC}"; read -p "Press Enter..."; return
    fi

    local target_ip=$(_db_get_pc_ip)
    read -p "Proxy IP [$target_ip]: " custom_ip
    [[ -n "$custom_ip" ]] && target_ip="$custom_ip"

    # Flush first
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -F'" 2>/dev/null

    echo -e "${BLUE}Setting iptables rules for UID $uid ($PICKED_APP) â†’ $target_ip${ENDC}"
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A OUTPUT -m owner --uid-owner $uid -p tcp --dport 443 -j DNAT --to-destination ${target_ip}:443'" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A OUTPUT -m owner --uid-owner $uid -p tcp --dport 80 -j DNAT --to-destination ${target_ip}:80'" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A POSTROUTING -m owner --uid-owner $uid -p tcp --dport 443 -j MASQUERADE'" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A POSTROUTING -m owner --uid-owner $uid -p tcp --dport 80 -j MASQUERADE'" 2>/dev/null

    echo -e "${GREEN}âœ“ Invisible proxy set for $PICKED_APP â†’ $target_ip${ENDC}"
    read -p "Press Enter..."
}

_db_invisible_proxy_global_pc() {
    _db_ensure_root || return
    _db_wifi_ssid_check
    local target_ip=$(_db_get_pc_ip)

    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -F'" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A OUTPUT -p tcp --dport 443 -j DNAT --to-destination ${target_ip}:443'" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A OUTPUT -p tcp --dport 80 -j DNAT --to-destination ${target_ip}:80'" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A POSTROUTING -p tcp --dport 443 -j MASQUERADE'" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A POSTROUTING -p tcp --dport 80 -j MASQUERADE'" 2>/dev/null

    echo -e "${GREEN}âœ“ Global invisible proxy set â†’ $target_ip${ENDC}"
    read -p "Press Enter..."
}

_db_invisible_proxy_custom() {
    _db_ensure_root || return
    read -p "Target IP: " target_ip

    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -F'" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A OUTPUT -p tcp --dport 443 -j DNAT --to-destination ${target_ip}:443'" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A OUTPUT -p tcp --dport 80 -j DNAT --to-destination ${target_ip}:80'" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A POSTROUTING -p tcp --dport 443 -j MASQUERADE'" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -A POSTROUTING -p tcp --dport 80 -j MASQUERADE'" 2>/dev/null

    echo -e "${GREEN}âœ“ Global invisible proxy set â†’ $target_ip${ENDC}"
    read -p "Press Enter..."
}

_db_invisible_proxy_show() {
    _db_ensure_root || return
    echo -e "${CYAN}Current iptables NAT rules:${ENDC}"
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -L OUTPUT -v -n'" 2>/dev/null
    echo ""
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -L POSTROUTING -v -n'" 2>/dev/null
    read -p "Press Enter..."
}

_db_invisible_proxy_flush() {
    _db_ensure_root || return
    $ADB -s "$SERIAL" shell "su -c 'iptables -t nat -F'" 2>/dev/null
    echo -e "${GREEN}âœ“ iptables flushed${ENDC}"
    read -p "Press Enter..."
}

_db_dns_spoof_pc() {
    local ip=$(_db_get_pc_ip)
    _db_wifi_ssid_check
    echo -e "${YELLOW}Starting DNS spoof â†’ all queries resolve to $ip${ENDC}"
    echo -e "${YELLOW}Set mobile device DNS to $ip${ENDC}"
    echo -e "${RED}Press Ctrl+C to stop${ENDC}"

    # Open WiFi settings on device
    $ADB -s "$SERIAL" shell am start -a android.settings.WIFI_SETTINGS 2>/dev/null
    read -p "Press Enter when device DNS is configured..."

    if command -v python3 &>/dev/null; then
        echo -e "${BLUE}Starting DNS server on 0.0.0.0:53 â†’ $ip${ENDC}"
        python3 -c "
from dnslib import DNSRecord, RR, QTYPE, A
from dnslib.server import DNSServer
import sys

class Resolver:
    def resolve(self, request, handler):
        reply = request.reply()
        qname = str(request.q.qname)
        print(f'SPOOF: {qname} â†’ $ip')
        reply.add_answer(RR(qname, QTYPE.A, rdata=A('$ip'), ttl=60))
        return reply

server = DNSServer(Resolver(), port=53, address='0.0.0.0')
print('DNS server running on 0.0.0.0:53')
server.start_thread()
try:
    while True: pass
except KeyboardInterrupt:
    server.stop()
    print('DNS server stopped')
" 2>&1
    else
        echo -e "${RED}python3 required for DNS spoofing${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_dns_spoof_custom() {
    read -p "Spoofed IP address: " ip
    _db_dns_spoof_pc_with_ip "$ip"
    read -p "Press Enter..."
}

_db_dns_spoof_stop() {
    pkill -f "dns_spoofing\|dnslib" 2>/dev/null
    echo -e "${GREEN}âœ“ DNS spoof processes killed${ENDC}"
    read -p "Press Enter..."
}

# ============================================================
#  5. TLS CERTIFICATES (from tls_certificates.py)
# ============================================================

db_tls_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ”’ TLS CERTIFICATE MANAGEMENT${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        echo "  1. Install Burp Suite CA"
        echo "  2. Install ZAP Proxy CA"
        echo "  3. Install mitmproxy CA"
        echo "  4. Install custom cert to system cacerts"
        echo "  5. List installed CAs on device"
        echo "  b. Back"
        echo ""
        read -p "Select: " opt
        case $opt in
            1) _db_ensure_device && _db_tls_install_burp ;;
            2) _db_ensure_device && _db_tls_install_zap ;;
            3) _db_ensure_device && _db_tls_install_mitmproxy ;;
            4) _db_ensure_device && _db_tls_install_custom ;;
            5) _db_ensure_device && _db_tls_list_cas ;;
            b|B) return ;;
            *) echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

_db_tls_download_and_install() {
    local url="$1"
    local cert_name="$2"
    local proxy_opt="$3"

    _db_ensure_root || return

    local dest_dir="$DB_RESULTS_DIR/tls_certificates"
    mkdir -p "$dest_dir"
    local dl_file="$dest_dir/${cert_name}.der"

    echo -e "${BLUE}Downloading certificate from $url${ENDC}"
    if [[ -n "$proxy_opt" ]]; then
        curl -kL --proxy "$proxy_opt" -o "$dl_file" "$url" 2>&1
    else
        curl -kL -o "$dl_file" "$url" 2>&1
    fi

    if [[ ! -f "$dl_file" ]] || [[ ! -s "$dl_file" ]]; then
        echo -e "${RED}Download failed. Ensure proxy is running.${ENDC}"; read -p "Press Enter..."; return
    fi

    # Convert to PEM
    local pem_file="$dest_dir/${cert_name}.pem"
    openssl x509 -inform DER -in "$dl_file" -out "$pem_file" 2>/dev/null || \
        cp "$dl_file" "$pem_file"  # might already be PEM

    # Calculate subject_hash_old for Android cacerts filename
    local hash=$(openssl x509 -inform PEM -subject_hash_old -noout -in "$pem_file" 2>/dev/null)
    if [[ -z "$hash" ]]; then
        echo -e "${RED}Could not compute certificate hash${ENDC}"; read -p "Press Enter..."; return
    fi

    local cacert_name="${hash}.0"
    local cacert_file="$dest_dir/$cacert_name"
    cp "$pem_file" "$cacert_file"

    echo -e "${BLUE}Installing $cacert_name to /system/etc/security/cacerts/${ENDC}"
    _db_su_push "$cacert_file" "/system/etc/security/cacerts/"
    $ADB -s "$SERIAL" shell "su -c 'chmod 644 /system/etc/security/cacerts/$cacert_name'" 2>/dev/null

    echo -e "${GREEN}âœ“ Certificate installed as $cacert_name${ENDC}"
    echo -e "${YELLOW}You may need to reboot the device for it to take effect${ENDC}"
    read -p "Press Enter..."
}

_db_tls_install_burp() {
    read -p "Burp listener IP:Port (e.g. 127.0.0.1:8080): " addr
    _db_tls_download_and_install "http://${addr}/cert" "burp_ca"
}

_db_tls_install_zap() {
    read -p "ZAP listener IP:Port (e.g. 127.0.0.1:8080): " addr
    _db_tls_download_and_install "http://${addr}/OTHER/network/other/rootCaCert/" "zap_ca"
}

_db_tls_install_mitmproxy() {
    read -p "mitmproxy listener IP:Port (e.g. 127.0.0.1:8080): " addr
    _db_tls_download_and_install "http://mitm.it/cert/cer" "mitmproxy_ca" "http://${addr}"
}

_db_tls_install_custom() {
    _db_ensure_root || return

    read -ep "Certificate file path (PEM/DER/PKCS12): " cert_path
    cert_path=$(eval echo "$cert_path")
    if [[ ! -f "$cert_path" ]]; then
        echo -e "${RED}File not found${ENDC}"; read -p "Press Enter..."; return
    fi

    local dest_dir="$DB_RESULTS_DIR/tls_certificates"
    mkdir -p "$dest_dir"
    local pem_file="$dest_dir/custom_cert.pem"

    # Auto-detect cert format (from tls_certificates.py identify_cert_format)
    echo -e "${BLUE}Detecting certificate format...${ENDC}"

    # Try PEM
    if openssl x509 -inform PEM -in "$cert_path" -noout 2>/dev/null; then
        echo -e "  ${GREEN}Format: PEM${ENDC}"
        cp "$cert_path" "$pem_file"
    # Try DER
    elif openssl x509 -inform DER -in "$cert_path" -noout 2>/dev/null; then
        echo -e "  ${GREEN}Format: DER â€” converting to PEM${ENDC}"
        openssl x509 -inform DER -in "$cert_path" -out "$pem_file" 2>/dev/null
    # Try PKCS#12
    elif openssl pkcs12 -info -in "$cert_path" -nokeys -nodes 2>/dev/null | grep -q "BEGIN CERTIFICATE"; then
        echo -e "  ${GREEN}Format: PKCS#12 â€” extracting certificate${ENDC}"
        read -sp "PKCS#12 password (blank if none): " p12_pwd; echo ""
        openssl pkcs12 -in "$cert_path" -out "$pem_file" -nokeys -nodes ${p12_pwd:+-passin "pass:$p12_pwd"} 2>/dev/null
    else
        # Last attempt â€” password-protected PKCS#12
        read -sp "File might be password-protected PKCS#12. Password: " p12_pwd; echo ""
        if openssl pkcs12 -in "$cert_path" -out "$pem_file" -nokeys -nodes -passin "pass:$p12_pwd" 2>/dev/null; then
            echo -e "  ${GREEN}Format: PKCS#12 (password-protected)${ENDC}"
        else
            echo -e "${RED}Could not parse certificate. Supported: PEM, DER, PKCS#12${ENDC}"
            read -p "Press Enter..."; return
        fi
    fi

    # Verify PEM is valid
    if ! openssl x509 -in "$pem_file" -noout 2>/dev/null; then
        echo -e "${RED}Failed to produce valid PEM certificate${ENDC}"; read -p "Press Enter..."; return
    fi

    # Show cert subject
    echo -e "  ${CYAN}Subject: $(openssl x509 -in "$pem_file" -noout -subject 2>/dev/null)${ENDC}"

    local hash=$(openssl x509 -inform PEM -subject_hash_old -noout -in "$pem_file" 2>/dev/null)
    if [[ -z "$hash" ]]; then
        echo -e "${RED}Could not compute hash${ENDC}"; read -p "Press Enter..."; return
    fi

    local cacert_name="${hash}.0"
    local cacert_file="$dest_dir/$cacert_name"
    cp "$pem_file" "$cacert_file"

    # Check if already exists on device
    local exists=$($ADB -s "$SERIAL" shell "su -c 'ls /system/etc/security/cacerts/$cacert_name 2>/dev/null'" 2>/dev/null | tr -d '\r')
    if [[ -n "$exists" ]]; then
        echo -e "${YELLOW}Certificate $cacert_name already exists on device${ENDC}"
    else
        _db_su_push "$cacert_file" "/system/etc/security/cacerts/"
        $ADB -s "$SERIAL" shell "su -c 'chmod 644 /system/etc/security/cacerts/$cacert_name'" 2>/dev/null
        echo -e "${GREEN}âœ“ Custom cert installed as $cacert_name${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_tls_list_cas() {
    echo -e "${CYAN}Installed system CA certificates:${ENDC}"
    $ADB -s "$SERIAL" shell "ls /system/etc/security/cacerts/" 2>/dev/null
    echo ""
    local count=$($ADB -s "$SERIAL" shell "ls /system/etc/security/cacerts/ 2>/dev/null | wc -l" | tr -d '\r')
    echo -e "${GREEN}Total: $count certificates${ENDC}"
    read -p "Press Enter..."
}

# ============================================================
#  6. APP LOGGING (from app_logs.py)
# ============================================================

db_logging_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ“‹ APP LOGGING${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        _db_ensure_device || return
        echo "  1. Log all output (running app)"
        echo "  2. Log crashes only (running app)"
        echo "  3. Launch app & log all"
        echo "  4. Launch app & log crashes"
        echo "  5. Filtered logcat (by package)"
        echo "  6. Memory info (dumpsys meminfo)"
        echo "  b. Back"
        echo ""
        read -p "Select: " opt
        case $opt in
            1) _db_log_running_app all ;;
            2) _db_log_running_app crash ;;
            3) _db_log_launch_app all ;;
            4) _db_log_launch_app crash ;;
            5) _db_filtered_logcat ;;
            6) _db_meminfo ;;
            b|B) return ;;
            *) echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

_db_log_running_app() {
    local mode="$1"
    _db_pick_running_app || { read -p "Press Enter..."; return; }
    local app_id="$PICKED_APP"
    local pid=$(_db_get_pid "$app_id")

    if [[ -z "$pid" ]]; then
        echo -e "${RED}Could not get PID for $app_id${ENDC}"; read -p "Press Enter..."; return
    fi

    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local log_dir="$DB_RESULTS_DIR/$app_id/logs"
    mkdir -p "$log_dir"
    local log_file="$log_dir/${ts}_${mode}.log"

    echo -e "${GREEN}Logging $mode for $app_id (PID: $pid)${ENDC}"
    echo -e "${YELLOW}Press Ctrl+C to stop logging${ENDC}"

    if [[ "$mode" == "crash" ]]; then
        $ADB -s "$SERIAL" logcat --pid="$pid" '*:E' 2>/dev/null | tee "$log_file"
    else
        $ADB -s "$SERIAL" logcat --pid="$pid" 2>/dev/null | tee "$log_file"
    fi

    echo -e "\n${GREEN}âœ“ Log saved: $log_file${ENDC}"
    read -p "Press Enter..."
}

_db_log_launch_app() {
    local mode="$1"
    _db_pick_app_id "Select app to launch and log" || { read -p "Press Enter..."; return; }
    local app_id="$PICKED_APP"

    # Clear logcat buffer
    $ADB -s "$SERIAL" logcat -c 2>/dev/null

    # Launch app
    echo -e "${BLUE}Launching $app_id...${ENDC}"
    $ADB -s "$SERIAL" shell monkey -p "$app_id" -v 1 &>/dev/null

    sleep 2
    local pid=$(_db_get_pid "$app_id")
    if [[ -z "$pid" ]]; then
        echo -e "${RED}App did not start or PID not found${ENDC}"; read -p "Press Enter..."; return
    fi

    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local log_dir="$DB_RESULTS_DIR/$app_id/logs"
    mkdir -p "$log_dir"
    local log_file="$log_dir/${ts}_launch_${mode}.log"

    echo -e "${GREEN}Logging $mode for $app_id (PID: $pid)${ENDC}"
    echo -e "${YELLOW}Press Ctrl+C to stop${ENDC}"

    if [[ "$mode" == "crash" ]]; then
        $ADB -s "$SERIAL" logcat --pid="$pid" '*:E' 2>/dev/null | tee "$log_file"
    else
        $ADB -s "$SERIAL" logcat --pid="$pid" 2>/dev/null | tee "$log_file"
    fi

    echo -e "\n${GREEN}âœ“ Log saved: $log_file${ENDC}"
    read -p "Press Enter..."
}

_db_filtered_logcat() {
    _db_pick_app_id "Select app for filtered logcat" || { read -p "Press Enter..."; return; }
    local pid=$(_db_get_pid "$PICKED_APP")

    if [[ -z "$pid" ]]; then
        echo -e "${YELLOW}App not running. Starting it...${ENDC}"
        $ADB -s "$SERIAL" shell monkey -p "$PICKED_APP" -v 1 &>/dev/null
        sleep 2
        pid=$(_db_get_pid "$PICKED_APP")
    fi

    if [[ -n "$pid" ]]; then
        echo -e "${GREEN}Logcat for $PICKED_APP (PID: $pid) â€” Ctrl+C to stop${ENDC}"
        $ADB -s "$SERIAL" logcat --pid="$pid" 2>/dev/null
    else
        echo -e "${RED}Could not get PID${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_meminfo() {
    _db_pick_app_id "Select app for memory info" || { read -p "Press Enter..."; return; }
    echo -e "${CYAN}Memory info for $PICKED_APP:${ENDC}"
    $ADB -s "$SERIAL" shell dumpsys meminfo "$PICKED_APP" 2>/dev/null
    read -p "Press Enter..."
}

# ============================================================
#  7. DEEP LINK / INTENT SERVER (from intent_server.py)
# ============================================================

db_deeplink_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ”— DEEP LINK ANALYSIS${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        echo "  1. Extract deep links from APK (decompile + parse)"
        echo "  2. Extract deep links from device app"
        echo "  3. Extract from AndroidManifest.xml file"
        echo "  4. Test deep link on device"
        echo "  b. Back"
        echo ""
        read -p "Select: " opt
        case $opt in
            1) _db_deeplink_from_apk ;;
            2) _db_ensure_device && _db_deeplink_from_device ;;
            3) _db_deeplink_from_manifest ;;
            4) _db_ensure_device && _db_deeplink_test ;;
            b|B) return ;;
            *) echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

_db_extract_deeplinks() {
    local manifest="$1"
    if [[ ! -f "$manifest" ]]; then
        echo -e "${RED}AndroidManifest.xml not found${ENDC}"; return 1
    fi

    echo -e "\n${BOLD}${MAGENTA}=== DEEP LINKS / APP LINKS ===${ENDC}\n"

    # Parse intent-filter data tags with VIEW + BROWSABLE
    # Use grep/sed/awk for XML parsing (good enough for manifests)
    local in_intent_filter=0
    local has_view=0
    local has_browsable=0
    local schemes=()
    local hosts=()
    local paths=()

    # Simpler approach: extract all scheme://host patterns
    grep -oP 'android:scheme="[^"]*"' "$manifest" | sed 's/android:scheme="//;s/"//' | sort -u | while read scheme; do
        grep -oP 'android:host="[^"]*"' "$manifest" | sed 's/android:host="//;s/"//' | sort -u | while read host; do
            local url="${scheme}://${host}"
            # Check for paths
            local path_patterns=$(grep -oP 'android:path(Prefix|Pattern)?="[^"]*"' "$manifest" | sed 's/android:path[^=]*="//;s/"//' | sort -u)
            if [[ -n "$path_patterns" ]]; then
                echo "$path_patterns" | while read pp; do
                    echo -e "  ${GREEN}${url}${pp}${ENDC}"
                done
            else
                echo -e "  ${GREEN}${url}${ENDC}"
            fi
        done
    done

    # Also show raw intent filter data
    echo -e "\n${YELLOW}Raw <data> elements:${ENDC}"
    grep -n 'android:scheme\|android:host\|android:path' "$manifest" 2>/dev/null
}

_db_deeplink_from_apk() {
    read -ep "APK file path: " apk_path
    apk_path=$(eval echo "$apk_path")
    if [[ ! -f "$apk_path" ]]; then
        echo -e "${RED}File not found${ENDC}"; read -p "Press Enter..."; return
    fi

    local tmp_dir=$(mktemp -d)
    apktool d -f -o "$tmp_dir" "$apk_path" 2>/dev/null
    _db_extract_deeplinks "$tmp_dir/AndroidManifest.xml"
    rm -rf "$tmp_dir"
    read -p "Press Enter..."
}

_db_deeplink_from_device() {
    _db_pick_app_id "Select app for deep link extraction" || { read -p "Press Enter..."; return; }

    local apk_path=$($ADB -s "$SERIAL" shell pm path "$PICKED_APP" 2>/dev/null | head -1 | sed 's/package://' | tr -d '\r')
    local tmp_dir=$(mktemp -d)
    $ADB -s "$SERIAL" pull "$apk_path" "$tmp_dir/base.apk" 2>/dev/null
    apktool d -f -o "$tmp_dir/decompiled" "$tmp_dir/base.apk" 2>/dev/null
    _db_extract_deeplinks "$tmp_dir/decompiled/AndroidManifest.xml"
    rm -rf "$tmp_dir"
    read -p "Press Enter..."
}

_db_deeplink_from_manifest() {
    read -ep "AndroidManifest.xml path: " manifest
    manifest=$(eval echo "$manifest")
    _db_extract_deeplinks "$manifest"
    read -p "Press Enter..."
}

_db_deeplink_test() {
    read -p "Deep link URL to test: " url
    if [[ -n "$url" ]]; then
        echo -e "${BLUE}Sending intent...${ENDC}"
        $ADB -s "$SERIAL" shell am start -a android.intent.action.VIEW -d "$url" 2>/dev/null
        echo -e "${GREEN}âœ“ Intent sent${ENDC}"
    fi
    read -p "Press Enter..."
}

# ============================================================
#  8. CONNECTIVITY CONTROLS (from connectivity.py, battery.py)
# ============================================================

db_connectivity_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ“¡ CONNECTIVITY & DEVICE CONTROLS${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        _db_ensure_device || return
        echo "  --- WiFi ---"
        echo "  1. Enable WiFi"
        echo "  2. Disable WiFi"
        echo "  3. Open WiFi settings"
        echo ""
        echo "  --- Airplane Mode ---"
        echo "  4. Enable airplane mode"
        echo "  5. Disable airplane mode"
        echo ""
        echo "  --- Do Not Disturb ---"
        echo "  6. DND: Total silence"
        echo "  7. DND: Alarms only"
        echo "  8. DND: Priority only"
        echo "  9. DND: Off"
        echo ""
        echo "  --- Battery ---"
        echo " 10. Battery saver ON"
        echo " 11. Battery saver OFF"
        echo " 12. Battery status"
        echo ""
        echo "  --- Device Info ---"
        echo " 13. CPU info"
        echo " 14. RAM info"
        echo " 15. Network info"
        echo " 16. Storage info"
        echo " 17. General device info"
        echo " 18. Running processes"
        echo ""
        echo "  --- Power ---"
        echo " 19. Shutdown device"
        echo " 20. Toggle screen lock (power button)"
        echo ""
        echo "  --- Screen Mirroring ---"
        echo " 21. Launch scrcpy (screen mirror)"
        echo " 22. Screenshot â†’ PC"
        echo " 23. Screen record"
        echo ""
        echo "  --- WiFi ADB ---"
        echo " 24. Enable WiFi ADB (tcpip)"
        echo " 25. Connect over WiFi"
        echo " 26. Disconnect WiFi ADB"
        echo ""
        echo "  --- Network Capture ---"
        echo " 27. tcpdump live capture"
        echo " 28. tcpdump to pcap file"
        echo ""
        echo "  b. Back"
        echo ""
        read -p "Select: " opt
        case $opt in
            1)  $ADB -s "$SERIAL" shell svc wifi enable 2>/dev/null; echo -e "${GREEN}âœ“ WiFi enabled${ENDC}"; read -p "Press Enter..." ;;
            2)  $ADB -s "$SERIAL" shell svc wifi disable 2>/dev/null; echo -e "${GREEN}âœ“ WiFi disabled${ENDC}"; read -p "Press Enter..." ;;
            3)  $ADB -s "$SERIAL" shell am start -a android.settings.WIFI_SETTINGS 2>/dev/null; read -p "Press Enter..." ;;
            4)  $ADB -s "$SERIAL" shell settings put global airplane_mode_on 1 2>/dev/null; echo -e "${GREEN}âœ“ Airplane mode ON${ENDC}"; read -p "Press Enter..." ;;
            5)  $ADB -s "$SERIAL" shell settings put global airplane_mode_on 0 2>/dev/null; echo -e "${GREEN}âœ“ Airplane mode OFF${ENDC}"; read -p "Press Enter..." ;;
            6)  $ADB -s "$SERIAL" shell settings put global zen_mode 3 2>/dev/null; echo -e "${GREEN}âœ“ DND: Total silence${ENDC}"; read -p "Press Enter..." ;;
            7)  $ADB -s "$SERIAL" shell settings put global zen_mode 2 2>/dev/null; echo -e "${GREEN}âœ“ DND: Alarms only${ENDC}"; read -p "Press Enter..." ;;
            8)  $ADB -s "$SERIAL" shell settings put global zen_mode 1 2>/dev/null; echo -e "${GREEN}âœ“ DND: Priority only${ENDC}"; read -p "Press Enter..." ;;
            9)  $ADB -s "$SERIAL" shell settings put global zen_mode 0 2>/dev/null; echo -e "${GREEN}âœ“ DND: Off${ENDC}"; read -p "Press Enter..." ;;
            10) $ADB -s "$SERIAL" shell am broadcast -a android.intent.action.ACTION_POWER_SAVE_MODE_CHANGED --ez '"mode"' true 2>/dev/null; echo -e "${GREEN}âœ“ Battery saver ON${ENDC}"; read -p "Press Enter..." ;;
            11) $ADB -s "$SERIAL" shell am broadcast -a android.intent.action.ACTION_POWER_SAVE_MODE_CHANGED --ez '"mode"' false 2>/dev/null; echo -e "${GREEN}âœ“ Battery saver OFF${ENDC}"; read -p "Press Enter..." ;;
            12) echo -e "${CYAN}Battery Status:${ENDC}"; $ADB -s "$SERIAL" shell dumpsys battery 2>/dev/null; read -p "Press Enter..." ;;
            13) echo -e "${CYAN}CPU Info:${ENDC}"; $ADB -s "$SERIAL" shell cat /proc/cpuinfo 2>/dev/null; read -p "Press Enter..." ;;
            14) echo -e "${CYAN}RAM Info:${ENDC}"; $ADB -s "$SERIAL" shell cat /proc/meminfo 2>/dev/null; read -p "Press Enter..." ;;
            15) echo -e "${CYAN}Network Info:${ENDC}"; $ADB -s "$SERIAL" shell dumpsys connectivity 2>/dev/null; read -p "Press Enter..." ;;
            16) echo -e "${CYAN}Storage Info:${ENDC}"; $ADB -s "$SERIAL" shell df -h 2>/dev/null; read -p "Press Enter..." ;;
            17) _db_general_info; read -p "Press Enter..." ;;
            18) echo -e "${CYAN}Running Processes:${ENDC}"; $ADB -s "$SERIAL" shell ps -A 2>/dev/null; read -p "Press Enter..." ;;
            19) read -p "Really shutdown? (y/n): " yn; [[ "$yn" == "y" ]] && $ADB -s "$SERIAL" shell "reboot -p" 2>/dev/null ;;
            20) _db_screen_lock; read -p "Press Enter..." ;;
            21) _db_scrcpy_mirror ;;
            22) _db_screenshot ;;
            23) _db_screen_record ;;
            24) _db_wifi_adb_enable ;;
            25) _db_wifi_adb_connect ;;
            26) _db_wifi_adb_disconnect ;;
            27) _db_tcpdump_live ;;
            28) _db_tcpdump_pcap ;;
            b|B) return ;;
            *) echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

_db_general_info() {
    echo -e "${BOLD}${CYAN}Device Information:${ENDC}"
    echo "Model:        $($ADB -s "$SERIAL" shell getprop ro.product.model 2>/dev/null | tr -d '\r')"
    echo "Brand:        $($ADB -s "$SERIAL" shell getprop ro.product.brand 2>/dev/null | tr -d '\r')"
    echo "Manufacturer: $($ADB -s "$SERIAL" shell getprop ro.product.manufacturer 2>/dev/null | tr -d '\r')"
    echo "Android:      $($ADB -s "$SERIAL" shell getprop ro.build.version.release 2>/dev/null | tr -d '\r')"
    echo "SDK:          $($ADB -s "$SERIAL" shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r')"
    echo "Build ID:     $($ADB -s "$SERIAL" shell getprop ro.build.id 2>/dev/null | tr -d '\r')"
    echo "Build Date:   $($ADB -s "$SERIAL" shell getprop ro.build.date 2>/dev/null | tr -d '\r')"
    echo "Serial:       $($ADB -s "$SERIAL" shell getprop ro.serialno 2>/dev/null | tr -d '\r')"
    echo "ABI:          $($ADB -s "$SERIAL" shell getprop ro.product.cpu.abi 2>/dev/null | tr -d '\r')"
    echo "Kernel:       $($ADB -s "$SERIAL" shell uname -r 2>/dev/null | tr -d '\r')"
}

# ============================================================
#  8b. SCREEN MIRRORING, WIFI ADB, NETWORK CAPTURE
# ============================================================

_db_scrcpy_mirror() {
    if ! command -v scrcpy &>/dev/null; then
        echo -e "${RED}scrcpy not found. Install: https://github.com/Genymobile/scrcpy${ENDC}"
        read -p "Press Enter..."; return
    fi
    echo -e "${BLUE}Launching scrcpy...${ENDC}"
    scrcpy -s "$SERIAL" --window-title "droidB Mirror [$SERIAL]" &>/dev/null &
    echo -e "${GREEN}âœ“ scrcpy launched in background (PID: $!)${ENDC}"
    read -p "Press Enter..."
}

_db_screenshot() {
    local ts=$(date +%Y%m%d_%H%M%S)
    local sdcard=$(_db_sd_path)
    local dest="$DB_RESULTS_DIR/screenshots"
    mkdir -p "$dest"

    echo -e "${BLUE}Capturing screenshot...${ENDC}"
    $ADB -s "$SERIAL" shell screencap -p "$sdcard/droidB_screenshot.png" 2>/dev/null
    $ADB -s "$SERIAL" pull "$sdcard/droidB_screenshot.png" "$dest/screenshot_${ts}.png" 2>/dev/null
    $ADB -s "$SERIAL" shell rm "$sdcard/droidB_screenshot.png" 2>/dev/null

    if [[ -f "$dest/screenshot_${ts}.png" ]]; then
        echo -e "${GREEN}âœ“ Saved: $dest/screenshot_${ts}.png${ENDC}"
    else
        echo -e "${RED}Screenshot failed${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_screen_record() {
    local ts=$(date +%Y%m%d_%H%M%S)
    local sdcard=$(_db_sd_path)
    local dest="$DB_RESULTS_DIR/recordings"
    mkdir -p "$dest"

    read -p "Duration in seconds (default: 30, max: 180): " dur
    dur=${dur:-30}
    [[ "$dur" -gt 180 ]] && dur=180

    echo -e "${BLUE}Recording screen for ${dur}s... (Ctrl+C to stop early)${ENDC}"
    $ADB -s "$SERIAL" shell screenrecord --time-limit "$dur" "$sdcard/droidB_record.mp4" &
    local rec_pid=$!
    sleep "$dur" 2>/dev/null || true
    wait "$rec_pid" 2>/dev/null

    sleep 1
    $ADB -s "$SERIAL" pull "$sdcard/droidB_record.mp4" "$dest/recording_${ts}.mp4" 2>/dev/null
    $ADB -s "$SERIAL" shell rm "$sdcard/droidB_record.mp4" 2>/dev/null

    if [[ -f "$dest/recording_${ts}.mp4" ]]; then
        echo -e "${GREEN}âœ“ Saved: $dest/recording_${ts}.mp4${ENDC}"
    else
        echo -e "${RED}Recording failed${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_wifi_adb_enable() {
    local port=${1:-5555}
    echo -e "${BLUE}Switching ADB to TCP/IP mode on port $port...${ENDC}"
    $ADB -s "$SERIAL" tcpip "$port" 2>/dev/null
    sleep 2

    local device_ip=$($ADB -s "$SERIAL" shell "ip route get 1.1.1.1 2>/dev/null" | grep -oP 'src \K[\d.]+')
    if [[ -z "$device_ip" ]]; then
        device_ip=$($ADB -s "$SERIAL" shell "ip addr show wlan0 2>/dev/null" | grep -oP 'inet \K[\d.]+')
    fi

    if [[ -n "$device_ip" ]]; then
        echo -e "${GREEN}âœ“ WiFi ADB enabled${ENDC}"
        echo -e "  Device IP: ${YELLOW}${device_ip}:${port}${ENDC}"
        echo -e "  Connect:   ${CYAN}adb connect ${device_ip}:${port}${ENDC}"
    else
        echo -e "${GREEN}âœ“ TCP/IP mode enabled on port $port${ENDC}"
        echo -e "${YELLOW}Could not auto-detect device IP. Check device WiFi settings.${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_wifi_adb_connect() {
    read -p "Device IP (e.g. 192.168.1.X): " dev_ip
    local port=${1:-5555}
    read -p "Port [$port]: " custom_port
    [[ -n "$custom_port" ]] && port="$custom_port"

    echo -e "${BLUE}Connecting to ${dev_ip}:${port}...${ENDC}"
    $ADB connect "${dev_ip}:${port}" 2>&1
    sleep 1

    # Update SERIAL if successful
    if $ADB devices | grep -q "${dev_ip}:${port}"; then
        SERIAL="${dev_ip}:${port}"
        echo -e "${GREEN}âœ“ Connected! SERIAL updated to $SERIAL${ENDC}"
    else
        echo -e "${RED}Connection failed${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_wifi_adb_disconnect() {
    echo -e "${BLUE}Disconnecting all WiFi ADB connections...${ENDC}"
    $ADB disconnect 2>&1
    echo -e "${GREEN}âœ“ Disconnected${ENDC}"
    # Refresh device info
    get_device_info 2>/dev/null
    read -p "Press Enter..."
}

_db_tcpdump_live() {
    _db_ensure_root || return
    echo -e "${CYAN}Live tcpdump on device (Ctrl+C to stop)${ENDC}"
    read -p "Interface (default: any): " iface
    iface=${iface:-any}
    read -p "Filter (e.g. 'port 443', blank for all): " filter

    echo -e "${YELLOW}Starting capture on $iface...${ENDC}"
    $ADB -s "$SERIAL" shell "su -c 'tcpdump -i $iface $filter -v'" 2>&1
    read -p "Press Enter..."
}

_db_tcpdump_pcap() {
    _db_ensure_root || return
    local ts=$(date +%Y%m%d_%H%M%S)
    local dest="$DB_RESULTS_DIR/pcap"
    mkdir -p "$dest"
    local sdcard=$(_db_sd_path)

    read -p "Interface (default: any): " iface
    iface=${iface:-any}
    read -p "Filter (blank for all): " filter
    read -p "Duration in seconds (default: 30): " dur
    dur=${dur:-30}

    echo -e "${BLUE}Capturing $dur seconds on $iface...${ENDC}"
    $ADB -s "$SERIAL" shell "su -c 'timeout $dur tcpdump -i $iface $filter -w $sdcard/droidB_capture.pcap'" 2>/dev/null
    sleep 1

    $ADB -s "$SERIAL" pull "$sdcard/droidB_capture.pcap" "$dest/capture_${ts}.pcap" 2>/dev/null
    $ADB -s "$SERIAL" shell "su -c 'rm $sdcard/droidB_capture.pcap'" 2>/dev/null

    if [[ -f "$dest/capture_${ts}.pcap" ]]; then
        echo -e "${GREEN}âœ“ Saved: $dest/capture_${ts}.pcap${ENDC}"
        echo -e "${CYAN}Open with: wireshark $dest/capture_${ts}.pcap${ENDC}"
    else
        echo -e "${RED}Capture failed (is tcpdump installed on device?)${ENDC}"
    fi
    read -p "Press Enter..."
}

# ============================================================
#  SECURITY TOOLS CHECKER & EXTRAS
# ============================================================

_db_check_security_tools() {
    echo -e "${BOLD}${CYAN}ğŸ”§ SECURITY TOOLS STATUS${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"

    local tools=(
        "adb:ADB (Android Debug Bridge)"
        "apktool:apktool (APK decompiler)"
        "jadx:JADX (DEX decompiler)"
        "jadx-gui:JADX-GUI"
        "apksigner:apksigner (APK signing)"
        "keytool:keytool (Java keystore)"
        "bundletool:bundletool (AABâ†’APK)"
        "apkeditor:APKEditor (merge APKs)"
        "aapt:aapt (Android Asset Packaging)"
        "frida:Frida (dynamic instrumentation)"
        "objection:Objection (Frida wrapper)"
        "scrcpy:scrcpy (screen mirroring)"
        "emulator:Android Emulator"
        "avdmanager:AVD Manager"
        "sdkmanager:SDK Manager"
        "openssl:OpenSSL"
        "curl:curl"
        "python3:Python 3"
        "pip:pip"
        "wireshark:Wireshark"
        "fastboot:Fastboot"
    )

    local installed=0
    local missing=0

    for entry in "${tools[@]}"; do
        local cmd="${entry%%:*}"
        local label="${entry##*:}"
        if command -v "$cmd" &>/dev/null; then
            local ver=$($cmd --version 2>/dev/null | head -1 | head -c 60)
            echo -e "  ${GREEN}âœ“${ENDC} $label ${BLUE}($ver)${ENDC}"
            ((installed++))
        else
            echo -e "  ${RED}âœ—${ENDC} $label"
            ((missing++))
        fi
    done

    echo ""
    echo -e "  ${GREEN}Installed: $installed${ENDC} | ${RED}Missing: $missing${ENDC}"

    # Check device-side tools
    if [[ -n "$SERIAL" ]]; then
        echo -e "\n${BOLD}${CYAN}Device-side tools:${ENDC}"
        for dcmd in "su:Root (su)" "tcpdump:tcpdump" "busybox:BusyBox"; do
            local cmd="${dcmd%%:*}"
            local label="${dcmd##*:}"
            local check=$($ADB -s "$SERIAL" shell "command -v $cmd 2>/dev/null || which $cmd 2>/dev/null" | tr -d '\r')
            if [[ -n "$check" ]]; then
                echo -e "  ${GREEN}âœ“${ENDC} $label"
            else
                echo -e "  ${RED}âœ—${ENDC} $label"
            fi
        done

        # Check frida-server
        local fsrv=$($ADB -s "$SERIAL" shell "ls /data/local/tmp/frida-server* /data/local/tmp/frida-servers/frida-server* 2>/dev/null" | tr -d '\r' | head -1)
        if [[ -n "$fsrv" ]]; then
            echo -e "  ${GREEN}âœ“${ENDC} frida-server"
        else
            echo -e "  ${RED}âœ—${ENDC} frida-server"
        fi
    fi

    read -p "Press Enter..."
}

_db_app_components() {
    # View app components: activities, services, receivers, providers (from AndroidManifest)
    _db_ensure_device || return
    _db_pick_app_id "Select app to inspect" || { read -p "Press Enter..."; return; }

    echo -e "\n${BOLD}${MAGENTA}=== COMPONENTS: $PICKED_APP ===${ENDC}\n"

    echo -e "${YELLOW}â–¶ Activities:${ENDC}"
    $ADB -s "$SERIAL" shell "dumpsys package $PICKED_APP" 2>/dev/null | grep -A500 "Activity Resolver Table" | grep "$PICKED_APP" | head -30
    echo ""

    echo -e "${YELLOW}â–¶ Services:${ENDC}"
    $ADB -s "$SERIAL" shell "dumpsys package $PICKED_APP" 2>/dev/null | grep -A500 "Service Resolver Table" | grep "$PICKED_APP" | head -20
    echo ""

    echo -e "${YELLOW}â–¶ Broadcast Receivers:${ENDC}"
    $ADB -s "$SERIAL" shell "dumpsys package $PICKED_APP" 2>/dev/null | grep -A500 "Receiver Resolver Table" | grep "$PICKED_APP" | head -20
    echo ""

    echo -e "${YELLOW}â–¶ Content Providers:${ENDC}"
    $ADB -s "$SERIAL" shell "dumpsys package $PICKED_APP" 2>/dev/null | grep -A500 "ContentProvider" | grep "$PICKED_APP" | head -20
    echo ""

    echo -e "${YELLOW}â–¶ Permissions:${ENDC}"
    $ADB -s "$SERIAL" shell "dumpsys package $PICKED_APP" 2>/dev/null | grep "permission" | grep -i "granted\|android.permission" | head -30

    read -p "Press Enter..."
}

_db_webview_debug() {
    # Enable WebView debugging globally via setprop
    _db_ensure_device || return
    _db_ensure_root || return

    local current=$($ADB -s "$SERIAL" shell "getprop persist.debug.debugwebview" 2>/dev/null | tr -d '\r')
    echo -e "Current WebView debug: ${YELLOW}${current:-not set}${ENDC}"

    read -p "Enable WebView debugging? (y/n): " yn
    if [[ "$yn" == "y" ]]; then
        $ADB -s "$SERIAL" shell "su -c 'setprop persist.debug.debugwebview true'" 2>/dev/null
        echo -e "${GREEN}âœ“ WebView debugging enabled${ENDC}"
        echo -e "${CYAN}Open chrome://inspect on your PC to debug WebViews${ENDC}"
    else
        $ADB -s "$SERIAL" shell "su -c 'setprop persist.debug.debugwebview false'" 2>/dev/null
        echo -e "${GREEN}âœ“ WebView debugging disabled${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_force_stop_active() {
    # Force stop with active app picker (from useful_stuff.py)
    _db_ensure_device || return
    _db_pick_running_app || { read -p "Press Enter..."; return; }
    echo -e "${BLUE}Force stopping $PICKED_APP...${ENDC}"
    $ADB -s "$SERIAL" shell am force-stop "$PICKED_APP" 2>/dev/null
    echo -e "${GREEN}âœ“ $PICKED_APP STOPPED${ENDC}"
    read -p "Press Enter..."
}

_db_playstore_open() {
    # Open Play Store page for an app
    _db_ensure_device || return
    read -p "Package name or search keyword: " pkg
    if echo "$pkg" | grep -qP '^[a-z][a-z0-9_]*\.[a-z][a-z0-9_]*'; then
        echo -e "${BLUE}Opening Play Store for $pkg...${ENDC}"
        $ADB -s "$SERIAL" shell am start -a android.intent.action.VIEW -d "market://details?id=$pkg" 2>/dev/null
    else
        echo -e "${BLUE}Searching Play Store for '$pkg'...${ENDC}"
        $ADB -s "$SERIAL" shell am start -a android.intent.action.VIEW -d "market://search?q=$pkg" 2>/dev/null
    fi
    echo -e "${GREEN}âœ“ Intent sent${ENDC}"
    read -p "Press Enter..."
}

_db_invisible_proxy_show_detailed() {
    # Enhanced iptables display with UID â†’ app_id resolution (from proxy.py get_current_invisible_proxy)
    _db_ensure_root || return
    echo -e "${CYAN}Current iptables NAT DNAT rules:${ENDC}\n"

    local raw=$($ADB -s "$SERIAL" shell "su -c 'iptables -t nat -L OUTPUT -v -n 2>/dev/null'" 2>/dev/null | grep "DNAT")

    if [[ -z "$raw" ]]; then
        echo -e "${YELLOW}No invisible proxy rules active${ENDC}"
        read -p "Press Enter..."; return
    fi

    echo -e "${BOLD}  %-20s %-8s %-20s %-10s${ENDC}" "OWNER" "DST_PORT" "PROXY_IP" "PROXY_PORT"
    echo "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

    echo "$raw" | while IFS= read -r line; do
        local uid=$(echo "$line" | grep -oP 'UID match \K[0-9]+')
        local dport=$(echo "$line" | grep -oP 'dpt:\K[0-9]+')
        local proxy_ip=$(echo "$line" | grep -oP 'to:\K[\d.]+(?=:\d+)')
        local proxy_port=$(echo "$line" | grep -oP 'to:[\d.]+:\K[0-9]+')

        local app_id=""
        if [[ -n "$uid" ]]; then
            app_id=$($ADB -s "$SERIAL" shell "pm list packages -U 2>/dev/null" | grep "uid:$uid" | sed 's/package://;s/ .*//' | head -1 | tr -d '\r')
            app_id="${app_id:-UID:$uid}"
        else
            app_id="GLOBAL"
        fi

        printf "  ${YELLOW}%-20s${ENDC} %-8s ${RED}%-20s %-10s${ENDC}\n" "$app_id" "${dport:-*}" "${proxy_ip:-*}" "${proxy_port:-*}"
    done

    echo ""
    read -p "Press Enter..."
}

# ============================================================
#  9. EMULATOR MANAGEMENT (from emulator.py)
# ============================================================

db_emulator_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ“± EMULATOR MANAGEMENT${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        echo "  1. List existing AVDs"
        echo "  2. Create new AVD"
        echo "  3. Launch AVD"
        echo "  4. Delete AVD"
        echo "  b. Back"
        echo ""
        read -p "Select: " opt
        case $opt in
            1) _db_avd_list ;;
            2) _db_avd_create ;;
            3) _db_avd_launch ;;
            4) _db_avd_delete ;;
            b|B) return ;;
            *) echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

_db_avd_list() {
    if command -v avdmanager &>/dev/null; then
        echo -e "${CYAN}Existing AVDs:${ENDC}"
        avdmanager list avd 2>/dev/null
    elif command -v emulator &>/dev/null; then
        echo -e "${CYAN}AVDs from emulator:${ENDC}"
        emulator -list-avds 2>/dev/null
    else
        echo -e "${RED}avdmanager/emulator not found${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_avd_create() {
    if ! command -v avdmanager &>/dev/null; then
        echo -e "${RED}avdmanager not found. Install Android SDK cmdline-tools.${ENDC}"; read -p "Press Enter..."; return
    fi

    echo -e "${CYAN}Available system images:${ENDC}"
    sdkmanager --list 2>/dev/null | grep "system-images" | head -20
    echo ""

    read -p "System image package (e.g. system-images;android-34;google_apis;x86_64): " pkg
    read -p "Device type (e.g. pixel_6): " device
    read -p "AVD name: " name

    if [[ -z "$pkg" ]] || [[ -z "$name" ]]; then
        echo -e "${RED}Missing required fields${ENDC}"; read -p "Press Enter..."; return
    fi

    # Install package if needed
    echo -e "${BLUE}Ensuring package is installed...${ENDC}"
    echo "y" | sdkmanager "$pkg" 2>&1

    echo -e "${BLUE}Creating AVD: $name${ENDC}"
    echo "no" | avdmanager create avd --name "$name" --package "$pkg" ${device:+--device "$device"} --force 2>&1
    echo -e "${GREEN}âœ“ AVD created${ENDC}"
    read -p "Press Enter..."
}

_db_avd_launch() {
    if ! command -v emulator &>/dev/null; then
        echo -e "${RED}emulator not found${ENDC}"; read -p "Press Enter..."; return
    fi

    local avds=$(emulator -list-avds 2>/dev/null)
    if [[ -z "$avds" ]]; then
        echo -e "${RED}No AVDs found${ENDC}"; read -p "Press Enter..."; return
    fi

    echo -e "${CYAN}Available AVDs:${ENDC}"
    local i=0; local arr=()
    while IFS= read -r line; do
        echo "  $i) $line"
        arr+=("$line"); ((i++))
    done <<< "$avds"

    read -p "Select: " sel
    if [[ "$sel" =~ ^[0-9]+$ ]] && [[ "$sel" -lt "${#arr[@]}" ]]; then
        local avd_name="${arr[$sel]}"
        echo -e "${BLUE}Launching $avd_name...${ENDC}"
        emulator -avd "$avd_name" -no-boot-anim -gpu host -writable-system &>/dev/null &
        echo -e "${GREEN}âœ“ Emulator launched in background${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_avd_delete() {
    if ! command -v avdmanager &>/dev/null; then
        echo -e "${RED}avdmanager not found${ENDC}"; read -p "Press Enter..."; return
    fi

    local avds=$(emulator -list-avds 2>/dev/null)
    if [[ -z "$avds" ]]; then
        echo -e "${RED}No AVDs found${ENDC}"; read -p "Press Enter..."; return
    fi

    echo -e "${CYAN}Available AVDs:${ENDC}"
    local i=0; local arr=()
    while IFS= read -r line; do
        echo "  $i) $line"
        arr+=("$line"); ((i++))
    done <<< "$avds"

    read -p "Select AVD to delete: " sel
    if [[ "$sel" =~ ^[0-9]+$ ]] && [[ "$sel" -lt "${#arr[@]}" ]]; then
        local avd_name="${arr[$sel]}"
        read -p "Delete $avd_name? (y/n): " yn
        if [[ "$yn" == "y" ]]; then
            avdmanager delete avd --name "$avd_name" 2>&1
            echo -e "${GREEN}âœ“ Deleted${ENDC}"
        fi
    fi
    read -p "Press Enter..."
}

# ============================================================
#  10. APK MERGE (from merge_apks.py)
# ============================================================

db_merge_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ”€ APK MERGE${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        echo "  1. Merge APKs from directory"
        echo "  2. Merge specific APK files"
        echo "  b. Back"
        echo ""
        read -p "Select: " opt
        case $opt in
            1) _db_merge_from_dir ;;
            2) _db_merge_from_list ;;
            b|B) return ;;
            *) echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

_db_merge_from_dir() {
    if ! command -v apkeditor &>/dev/null; then
        echo -e "${RED}apkeditor not found. Install APKEditor first.${ENDC}"; read -p "Press Enter..."; return
    fi

    read -ep "Directory containing APK files: " dir_path
    dir_path=$(eval echo "$dir_path")
    if [[ ! -d "$dir_path" ]]; then
        echo -e "${RED}Directory not found${ENDC}"; read -p "Press Enter..."; return
    fi

    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local out_dir="$DB_RESULTS_DIR/merged_apk"
    mkdir -p "$out_dir"
    local out_apk="$out_dir/${ts}_merged.apk"

    echo -e "${BLUE}Merging APKs from $dir_path...${ENDC}"
    apkeditor m -f -i "$dir_path" -o "$out_apk" 2>&1

    if [[ -f "$out_apk" ]]; then
        echo -e "${GREEN}âœ“ Merged APK: $out_apk${ENDC}"
        read -p "Sign it? (y/n): " yn
        [[ "$yn" == "y" ]] && _db_do_sign "$out_apk"
    else
        echo -e "${RED}Merge failed${ENDC}"
    fi
    read -p "Press Enter..."
}

_db_merge_from_list() {
    if ! command -v apkeditor &>/dev/null; then
        echo -e "${RED}apkeditor not found${ENDC}"; read -p "Press Enter..."; return
    fi

    echo -e "${CYAN}Enter APK file paths (one per line, blank line to finish):${ENDC}"
    local tmp_dir=$(mktemp -d)
    while true; do
        read -ep "> " apk_file
        [[ -z "$apk_file" ]] && break
        apk_file=$(eval echo "$apk_file")
        if [[ -f "$apk_file" ]] && [[ "$apk_file" == *.apk ]]; then
            cp "$apk_file" "$tmp_dir/"
            echo -e "  ${GREEN}Added: $(basename "$apk_file")${ENDC}"
        else
            echo -e "  ${RED}Skipped: $apk_file${ENDC}"
        fi
    done

    local count=$(ls "$tmp_dir"/*.apk 2>/dev/null | wc -l)
    if [[ "$count" -lt 1 ]]; then
        echo -e "${RED}No valid APKs provided${ENDC}"; rm -rf "$tmp_dir"; read -p "Press Enter..."; return
    fi

    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local out_dir="$DB_RESULTS_DIR/merged_apk"
    mkdir -p "$out_dir"
    local out_apk="$out_dir/${ts}_merged.apk"

    apkeditor m -f -i "$tmp_dir" -o "$out_apk" 2>&1
    rm -rf "$tmp_dir"

    if [[ -f "$out_apk" ]]; then
        echo -e "${GREEN}âœ“ Merged APK: $out_apk${ENDC}"
    else
        echo -e "${RED}Merge failed${ENDC}"
    fi
    read -p "Press Enter..."
}

# ============================================================
#  11. INTERACTIVE SHELL (from shell.py)
# ============================================================

db_interactive_shell() {
    _db_ensure_device || return

    echo -e "${BOLD}${CYAN}ğŸ–¥ï¸  ENHANCED ADB SHELL${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    echo -e "Commands: ${GREEN}exit${ENDC} | ${GREEN}download <mobile_path> [local_path]${ENDC} | ${GREEN}upload <local_path> [mobile_path]${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"

    local user=$($ADB -s "$SERIAL" shell whoami 2>/dev/null | tr -d '\r')
    local cwd=$($ADB -s "$SERIAL" shell pwd 2>/dev/null | tr -d '\r')

    while true; do
        read -ep "[$user:$cwd]\$ " cmd
        [[ -z "$cmd" ]] && continue

        case "$cmd" in
            exit|quit)
                break ;;
            clear)
                clear ;;
            download\ *)
                local args=($cmd)
                local mobile_path="${args[1]}"
                local local_path="${args[2]:-.}"
                [[ ! "$mobile_path" == /* ]] && mobile_path="$cwd/$mobile_path"
                _db_su_pull "$mobile_path" "$local_path"
                ;;
            upload\ *)
                local args=($cmd)
                local local_path="${args[1]}"
                local mobile_dest="${args[2]:-$cwd}"
                [[ ! "$mobile_dest" == /* ]] && mobile_dest="$cwd/$mobile_dest"
                _db_su_push "$local_path" "$mobile_dest"
                ;;
            su|su\ *)
                user="root"
                echo -e "${GREEN}Switched to root context${ENDC}"
                ;;
            cd\ *)
                local new_dir="${cmd#cd }"
                local result=$($ADB -s "$SERIAL" shell "su -c 'cd $cwd && cd $new_dir 2>/dev/null && pwd'" 2>/dev/null | tr -d '\r')
                if [[ -n "$result" ]] && [[ "$result" == /* ]]; then
                    cwd="$result"
                else
                    echo "cd: $new_dir: No such directory"
                fi
                ;;
            *)
                local prefix=""
                [[ "$user" == "root" ]] && prefix="su -c "
                $ADB -s "$SERIAL" shell "${prefix}'cd $cwd && $cmd'" 2>&1
                ;;
        esac
    done
    read -p "Press Enter to return to menu..."
}

# ============================================================
#  12. APP BACKUP (Android Backup format â€” from backup.py)
# ============================================================

db_app_backup_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ’¾ APP BACKUP (.ab format)${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        _db_ensure_device || return
        echo "  1. Backup single app (.ab)"
        echo "  2. Full device backup (.ab)"
        echo "  3. Restore .ab backup"
        echo "  4. Extract .ab to TAR"
        echo "  5. Collect app data storage (/data/data/)"
        echo "  6. Reset app data"
        echo "  b. Back"
        echo ""
        read -p "Select: " opt
        case $opt in
            1) _db_backup_app ;;
            2) _db_backup_device ;;
            3) _db_restore_backup ;;
            4) _db_extract_ab ;;
            5) _db_collect_data ;;
            6) _db_reset_data ;;
            b|B) return ;;
            *) echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

_db_backup_app() {
    _db_pick_app_id "Select app to backup" || { read -p "Press Enter..."; return; }
    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local out_dir="$DB_RESULTS_DIR/$PICKED_APP/backup"
    mkdir -p "$out_dir"
    local ab_file="$out_dir/${ts}_backup.ab"

    echo -e "${BLUE}Backup $PICKED_APP â†’ $ab_file${ENDC}"
    echo -e "${YELLOW}Confirm backup on the device screen...${ENDC}"
    $ADB -s "$SERIAL" backup -apk -f "$ab_file" "$PICKED_APP" 2>&1
    echo -e "${GREEN}âœ“ Backup saved: $ab_file${ENDC}"
    read -p "Press Enter..."
}

_db_backup_device() {
    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local out_dir="$DB_RESULTS_DIR/device/backup"
    mkdir -p "$out_dir"
    local ab_file="$out_dir/${ts}_device_backup.ab"

    echo -e "${BLUE}Full device backup â†’ $ab_file${ENDC}"
    echo -e "${YELLOW}Confirm backup on the device screen...${ENDC}"
    $ADB -s "$SERIAL" backup -apk -shared -all -f "$ab_file" 2>&1
    echo -e "${GREEN}âœ“ Backup saved: $ab_file${ENDC}"
    read -p "Press Enter..."
}

_db_restore_backup() {
    read -ep "Path to .ab file: " ab_path
    ab_path=$(eval echo "$ab_path")
    if [[ ! -f "$ab_path" ]] || [[ ! "$ab_path" == *.ab ]]; then
        echo -e "${RED}Invalid .ab file${ENDC}"; read -p "Press Enter..."; return
    fi
    echo -e "${BLUE}Restoring backup...${ENDC}"
    echo -e "${YELLOW}Confirm restore on the device screen...${ENDC}"
    $ADB -s "$SERIAL" restore "$ab_path" 2>&1
    echo -e "${GREEN}âœ“ Restore command sent${ENDC}"
    read -p "Press Enter..."
}

_db_extract_ab() {
    read -ep "Path to .ab file: " ab_path
    ab_path=$(eval echo "$ab_path")
    if [[ ! -f "$ab_path" ]]; then
        echo -e "${RED}File not found${ENDC}"; read -p "Press Enter..."; return
    fi

    if command -v abe &>/dev/null; then
        local tar_path="${ab_path%.ab}.tar"
        read -sp "Backup password (Enter if none): " pwd; echo ""
        abe unpack "$ab_path" "$tar_path" "$pwd" 2>&1
        if [[ -f "$tar_path" ]]; then
            local extract_dir="${ab_path%.ab}_extracted"
            mkdir -p "$extract_dir"
            tar xf "$tar_path" -C "$extract_dir" 2>&1
            echo -e "${GREEN}âœ“ Extracted to: $extract_dir${ENDC}"
        fi
    else
        echo -e "${YELLOW}ABE not found. Trying dd + openssl + tar...${ENDC}"
        local tar_path="${ab_path%.ab}.tar"
        dd if="$ab_path" bs=1 skip=24 2>/dev/null | python3 -c "import zlib,sys; sys.stdout.buffer.write(zlib.decompress(sys.stdin.buffer.read()))" > "$tar_path" 2>/dev/null
        if [[ -s "$tar_path" ]]; then
            local extract_dir="${ab_path%.ab}_extracted"
            mkdir -p "$extract_dir"
            tar xf "$tar_path" -C "$extract_dir" 2>&1
            echo -e "${GREEN}âœ“ Extracted to: $extract_dir${ENDC}"
        else
            echo -e "${RED}Extraction failed (backup may be encrypted)${ENDC}"
        fi
    fi
    read -p "Press Enter..."
}

_db_collect_data() {
    _db_ensure_root || return
    _db_pick_app_id "Select app to collect data from" || { read -p "Press Enter..."; return; }
    local ts=$(date +%Y-%m-%d_%H-%M-%S)
    local out_dir="$DB_RESULTS_DIR/$PICKED_APP/data_storage/$ts"
    mkdir -p "$out_dir"

    echo -e "${BLUE}Collecting /data/data/$PICKED_APP/...${ENDC}"
    _db_su_pull "/data/data/$PICKED_APP/" "$out_dir"
    echo -e "${GREEN}âœ“ Data collected: $out_dir${ENDC}"
    read -p "Press Enter..."
}

_db_reset_data() {
    _db_pick_app_id "Select app to reset data" || { read -p "Press Enter..."; return; }
    read -p "This will CLEAR ALL DATA for $PICKED_APP. Continue? (y/n): " yn
    if [[ "$yn" == "y" ]]; then
        $ADB -s "$SERIAL" shell pm clear "$PICKED_APP" 2>/dev/null
        echo -e "${GREEN}âœ“ Data cleared for $PICKED_APP${ENDC}"
    fi
    read -p "Press Enter..."
}

# ============================================================
#  MAIN SECURITY TESTING MENU
# ============================================================

security_testing_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${RED}ğŸ” droidB SECURITY TOOLKIT${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"

        if [[ -n "$SERIAL" ]]; then
            local MODEL=$($ADB -s "$SERIAL" shell getprop ro.product.model 2>/dev/null | tr -d '\r')
            echo -e "${GREEN}Device: $MODEL ($SERIAL)${ENDC}"
        else
            echo -e "${YELLOW}No device connected (some features still work)${ENDC}"
        fi
        echo ""

        echo "  1.  ğŸ”¬ APK Analysis (decompile/recompile/analyze)"
        echo "  2.  ğŸ” Secrets Scanner (regex patterns)"
        echo "  3.  ğŸª Frida Integration"
        echo "  4.  ğŸŒ Proxy & Traffic Interception"
        echo "  5.  ğŸ”’ TLS Certificate Management"
        echo "  6.  ğŸ“‹ App Logging (filtered logcat)"
        echo "  7.  ğŸ”— Deep Link Analysis"
        echo "  8.  ğŸ“¡ Connectivity & Device Controls"
        echo "  9.  ğŸ“± Emulator Management"
        echo " 10.  ğŸ”€ APK Merge"
        echo " 11.  ğŸ–¥ï¸  Interactive Shell (enhanced)"
        echo " 12.  ğŸ’¾ App Backup & Data (.ab format)"
        echo " 13.  ğŸ›‘ Force Stop Running App"
        echo " 14.  ğŸª Open Play Store"
        echo " 15.  ğŸ”§ Check Security Tools"
        echo "  b.  Back to Main Menu"
        echo ""
        read -p "Select: " opt
        case $opt in
            1) db_apk_analysis_menu ;;
            2) db_secrets_scanner_menu ;;
            3) db_frida_menu ;;
            4) db_proxy_menu ;;
            5) db_tls_menu ;;
            6) db_logging_menu ;;
            7) db_deeplink_menu ;;
            8) db_connectivity_menu ;;
            9) db_emulator_menu ;;
            10) db_merge_menu ;;
            11) db_interactive_shell ;;
            12) db_app_backup_menu ;;
            13) _db_force_stop_active ;;
            14) _db_playstore_open ;;
            15) _db_check_security_tools ;;
            b|B) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

main_menu() {
    while true; do
        clear_screen
        display_banner
        
        get_device_info 2>/dev/null
        
        if [[ -n "$DEVICE_INFO" ]]; then
            STATE=$(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+' || echo 'Unknown')
            MODEL=$(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+' || echo 'Unknown')
            echo -e "${GREEN}Device: $MODEL ($STATE)${ENDC}"
        else
            echo -e "${YELLOW}No device connected${ENDC}"
        fi
        
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        echo -e "${BOLD}Main Menu:${ENDC}"
        echo "  1. Device Information"
        echo "  2. Universal Debloater ğŸ—‘ï¸"
        echo "  3. App Management"
        echo "  4. File Operations"
        echo "  5. System Operations"
        echo "  6. Fastboot Operations"
        echo "  7. Samsung Operations ğŸ“±"
        echo "  8. ğŸ’¾ Full Device Backup (SMS, Contacts, Media, APKs)"
        echo "  9. Install System-Wide"
        echo " 10. ğŸ”¬ Security Toolkit"
        echo "  q. Exit"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        read -p "Select option: " choice
        
        case $choice in
            1) display_device_info ;;
            2) [[ -n "$SERIAL" ]] && universal_debloater_menu || { echo -e "${RED}No device${ENDC}"; sleep 2; } ;;
            3) app_management_menu ;;
            4) file_operations_menu ;;
            5) system_operations_menu ;;
            6) fastboot_operations_menu ;;
            7) samsung_operations_menu ;;
            8) [[ -n "$SERIAL" ]] && full_backup_menu || { echo -e "${RED}No device connected${ENDC}"; sleep 2; } ;;
            9) install_systemwide ;;
            10) security_testing_menu ;;
            q|Q) exit 0 ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

cleanup() {
    rm -f "$DEBLOAT_LIST_FILE" 2>/dev/null
}

trap cleanup EXIT

main() {
    parse_arguments "$@"
    check_requirements
    main_menu
}

main "$@"
