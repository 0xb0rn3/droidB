#!/usr/bin/env bash

set -uo pipefail 

VERSION="0.3.0"
SCRIPT_NAME="droidB"
INSTALL_DIR="/usr/local/bin"

BLUE='\033[94m'
GREEN='\033[92m'
RED='\033[91m'
YELLOW='\033[93m'
MAGENTA='\033[95m'
CYAN='\033[96m'
WHITE='\033[97m'
BOLD='\033[1m'
ENDC='\033[0m'

SERIAL=""
ADB=""
FASTBOOT=""
DEVICE_INFO=""
DEBLOAT_LIST_FILE="/tmp/droidb_debloat_list.txt"
SAMSUNG_VENDOR_ID="04e8"
ODIN4_INSTALLED=false
HEIMDALL_INSTALLED=false

create_embedded_debloat_list() {
    cat > "$DEBLOAT_LIST_FILE" << 'EOF'
com.amazon.fv
com.amazon.kindle
com.amazon.mp3
com.amazon.mShop.android
com.amazon.venezia
com.android.apps.tag
com.android.backupconfirm
com.android.bips
com.android.bookmarkprovider
com.android.chrome
com.android.dreams.basic
com.android.dreams.phototable
com.android.email
com.android.exchange
com.android.hotwordenrollment.okgoogle
com.android.hotwordenrollment.xgoogle
com.android.internal.display.cutout.emulation.waterfall
com.android.printspooler
com.android.providers.calendar
com.android.providers.partnerbookmarks
com.android.providers.userdictionary
com.android.role.notes.enabled
com.android.settings.intelligence
com.android.sharedstoragebackup
com.android.stk
com.android.wallpapercropper
com.android.wallpaper.livepicker
com.audible.application
com.blurb.checkout
com.cequint.ecid
com.cnn.mobile.android.phone.edgepanel
com.diotek.sec.lookup.dictionary
com.dsi.ant.plugins.antplus
com.dsi.ant.sample.acquirechannels
com.dsi.ant.server
com.dsi.ant.service.socket
com.enhance.gameservice
com.facebook.appmanager
com.facebook.katana
com.facebook.services
com.facebook.system
com.flipboard.app
com.flipboard.boxer.app
com.google.android.aicore
com.google.android.apps.accessibility.voiceaccess
com.google.android.apps.aiwallpapers
com.google.android.apps.bard
com.google.android.apps.books
com.google.android.apps.docs
com.google.android.apps.magazines
com.google.android.apps.maps
com.google.android.apps.photos
com.google.android.apps.plus
com.google.android.apps.restore
com.google.android.apps.tachyon
com.google.android.apps.youtube.music
com.google.android.feedback
com.google.android.gm
com.google.android.gms.supervision
com.google.android.googlequicksearchbox
com.google.android.healthconnect.controller
com.google.android.onetimeinitializer
com.google.android.partnersetup
com.google.android.printservice.recommendation
com.google.android.projection.gearhead
com.google.android.safetycenter.resources
com.google.android.syncadapters.calendar
com.google.android.talk
com.google.android.tts
com.google.android.videos
com.google.android.youtube
com.google.ar.core
com.google.audio.hearing.visualization.accessibility.scribe
com.google.mainline.telemetry
com.google.vr.vrcore
com.gotv.nflgamecenter.us.lite
com.hancom.office.editor.hidden
com.imdb.mobile
com.infraware.polarisoffice5
com.linkedin.android
com.microsoft.appmanager
com.microsoft.office.excel
com.microsoft.office.officehubrow
com.microsoft.office.outlook
com.microsoft.office.powerpoint
com.microsoft.office.word
com.microsoft.skydrive
com.mobeam.barcodeService
com.monotype.android.font.chococooky
com.monotype.android.font.cooljazz
com.monotype.android.font.foundation
com.monotype.android.font.rosemary
com.monotype.android.font.samsungone
com.netflix.mediaclient
com.nuance.swype.input
com.osp.app.signin
com.policydm
com.samsung.aasaservice
com.samsung.android.aicore
com.samsung.android.aircommandmanager
com.samsung.android.allshare.service.fileshare
com.samsung.android.allshare.service.mediashare
com.samsung.android.app.advsounddetector
com.samsung.android.app.appsedge
com.samsung.android.app.assistantmenu
com.samsung.android.app.camera.sticker.facear3d.preload
com.samsung.android.app.camera.sticker.facearavatar.preload
com.samsung.android.app.camera.sticker.facearframe.preload
com.samsung.android.app.camera.sticker.facear.preload
com.samsung.android.app.camera.sticker.stamp.preload
com.samsung.android.app.clipboardedge
com.samsung.android.app.cocktailbarservice
com.samsung.android.app.episodes
com.samsung.android.app.filterinstaller
com.samsung.android.app.find
com.samsung.android.app.galaxyfinder
com.samsung.android.app.interpreter
com.samsung.android.app.ledbackcover
com.samsung.android.app.ledcoverdream
com.samsung.android.app.memo
com.samsung.android.app.mirrorlink
com.samsung.android.app.notes
com.samsung.android.app.omcagent
com.samsung.android.app.parentalcare
com.samsung.android.app.readingglass
com.samsung.android.app.reminder
com.samsung.android.app.routines
com.samsung.android.app.sbrowseredge
com.samsung.android.app.settings.bixby
com.samsung.android.app.sharelive
com.samsung.android.app.simplesharing
com.samsung.android.app.sketchbook
com.samsung.android.app.soundpicker
com.samsung.android.app.spage
com.samsung.android.app.storyalbumwidget
com.samsung.android.app.talkback
com.samsung.android.app.taskedge
com.samsung.android.app.tips
com.samsung.android.app.updatecenter
com.samsung.android.app.vrsetupwizardstub
com.samsung.android.app.watchmanager
com.samsung.android.app.watchmanagerstub
com.samsung.android.app.withtv
com.samsung.android.ardrawing
com.samsung.android.aremoji
com.samsung.android.aremojieditor
com.samsung.android.arzone
com.samsung.android.authfw
com.samsung.android.aware.service
com.samsung.android.bbc.bbcagent
com.samsung.android.beaconmanager
com.samsung.android.bixby.agent
com.samsung.android.bixby.agent.dummy
com.samsung.android.bixby.es.globalaction
com.samsung.android.bixby.ondevice.enus
com.samsung.android.bixby.ondevice.esus
com.samsung.android.bixby.plmsync
com.samsung.android.bixby.service
com.samsung.android.bixbyvision.framework
com.samsung.android.bixby.voiceinput
com.samsung.android.bixby.wakeup
com.samsung.android.calendar
com.samsung.android.carkey
com.samsung.android.coldwalletservice
com.samsung.android.da.daagent
com.samsung.android.dbsc
com.samsung.android.dkey
com.samsung.android.dlp.service
com.samsung.android.drivelink.stub
com.samsung.android.easysetup
com.samsung.android.email.provider
com.samsung.android.ese
com.samsung.android.fmm
com.samsung.android.forest
com.samsung.android.game.gamehome
com.samsung.android.game.gametools
com.samsung.android.game.gos
com.samsung.android.gametuner.thin
com.samsung.android.globalpostprocmgr
com.samsung.android.gru
com.samsung.android.hmt.vrshell
com.samsung.android.hmt.vrsvc
com.samsung.android.hwresourceshare.storage
com.samsung.android.intellivoiceservice
com.samsung.android.ipsgeofence
com.samsung.android.keyguardwallpaperupdator
com.samsung.android.kidsinstaller
com.samsung.android.knox.analytics.uploader
com.samsung.android.knox.zt.framework
com.samsung.android.liveeffectservice
com.samsung.android.mapsagent
com.samsung.android.mateagent
com.samsung.android.mdecservice
com.samsung.android.mdm
com.samsung.android.mdx
com.samsung.android.mdx.kit
com.samsung.android.messaging
com.samsung.android.mobileservice
com.samsung.android.net.wifi.wifiguider
com.samsung.android.nmt.apps.t2t.languagepack.enesus
com.samsung.android.offline.languagemodel
com.samsung.android.oneconnect
com.samsung.android.rajaampat
com.samsung.android.samsungpass
com.samsung.android.samsungpassautofill
com.samsung.android.scloud
com.samsung.android.scpm
com.samsung.android.sdk.ocr
com.samsung.android.sdk.professionalaudio.utility.jammonitor
com.samsung.android.server.iris
com.samsung.android.service.livedrawing
com.samsung.android.service.peoplestripe
com.samsung.android.service.stplatform
com.samsung.android.service.tagservice
com.samsung.android.service.travel
com.samsung.android.setting.multisound
com.samsung.android.smartmirroring
com.samsung.android.smartsuggestions
com.samsung.android.smartswitchassistant
com.samsung.android.spay
com.samsung.android.spayfw
com.samsung.android.spdfnote
com.samsung.android.ssco
com.samsung.android.stickercenter
com.samsung.android.stickerplugin
com.samsung.android.svoice
com.samsung.android.svoiceime
com.samsung.android.themecenter
com.samsung.android.themestore
com.samsung.android.tripwidget
com.samsung.android.tvplus
com.samsung.android.visionarapps
com.samsung.android.visioncloudagent
com.samsung.android.visionintelligence
com.samsung.android.vision.model
com.samsung.android.visual.cloudcore
com.samsung.android.voc
com.samsung.android.voicewakeup
com.samsung.android.vtcamerasettings
com.samsung.android.widgetapp.yahooedge.finance
com.samsung.android.widgetapp.yahooedge.sport
com.samsung.app.highlightplayer
com.samsung.app.newtrim
com.samsung.daydream.customization
com.samsung.dcmservice
com.samsung.desktopsystemui
com.samsung.ecomm
com.samsung.enhanceservice
com.samsung.faceservice
com.samsung.fresco.logging
com.samsung.groupcast
com.samsung.hs20provider
com.samsung.ipservice
com.samsung.knox.appsupdateagent
com.samsung.knox.rcp.components
com.samsung.knox.securefolder
com.samsung.knox.securefolder.setuppage
com.samsung.petservice
com.samsung.safetyinformation
com.samsung.sec.android.application.csc
com.samsung.SMT
com.samsung.sree
com.samsung.storyservice
com.samsung.svoice.sync
com.samsung.systemui.bixby
com.samsung.systemui.bixby2
com.samsung.ucs.agent.ese
com.samsung.voiceserviceplatform
com.sec.android.app.apex
com.sec.android.app.applinker
com.sec.android.app.billing
com.sec.android.app.bluetoothtest
com.sec.android.app.chromecustomizations
com.sec.android.app.clockpackage
com.sec.android.app.DataCreate
com.sec.android.app.desktoplauncher
com.sec.android.app.dexonpc
com.sec.android.app.factorykeystring
com.sec.android.app.gamehub
com.sec.android.app.hwmoduletest
com.sec.android.app.kidshome
com.sec.android.app.magnifier
com.sec.android.app.myfiles
com.sec.android.app.ocr
com.sec.android.app.parser
com.sec.android.app.personalization
com.sec.android.app.popupcalculator
com.sec.android.app.quicktool
com.sec.android.app.ringtoneBR
com.sec.android.app.safetyassurance
com.sec.android.app.samsungapps
com.sec.android.app.sbrowser
com.sec.android.app.SecSetupWizard
com.sec.android.app.servicemodeapp
com.sec.android.app.setupwizard
com.sec.android.app.shealth
com.sec.android.app.SmartClipEdgeService
com.sec.android.app.soundalive
com.sec.android.app.sysscope
com.sec.android.app.tfunlock
com.sec.android.app.tourviewer
com.sec.android.app.translator
com.sec.android.app.vepreload
com.sec.android.app.ve.vebgm
com.sec.android.app.voicenote
com.sec.android.app.wfdbroker
com.sec.android.app.withtv
com.sec.android.app.wlantest
com.sec.android.autodoodle.service
com.sec.android.AutoPreconfig
com.sec.android.cover.ledcover
com.sec.android.desktopmode.uiservice
com.sec.android.dexsystemui
com.sec.android.diagmonagent
com.sec.android.easyMover
com.sec.android.easyMover.Agent
com.sec.android.easyonehand
com.sec.android.emergencylauncher
com.sec.android.mimage.avatarstickers
com.sec.android.mimage.gear360editor
com.sec.android.mimage.photoretouching
com.sec.android.ofviewer
com.sec.android.omc
com.sec.android.Preconfig
com.sec.android.preloadinstaller
com.sec.android.provider.snote
com.sec.android.providers.security
com.sec.android.providers.tasks
com.sec.android.RilServiceModeApp
com.sec.android.sdhms
com.sec.android.service.health
com.sec.android.sidesync30
com.sec.android.splitsound
com.sec.android.uibcvirtualsoftkey
com.sec.android.widgetapp.diotek.smemo
com.sec.android.widgetapp.easymodecontactswidget
com.sec.android.widgetapp.samsungapps
com.sec.app.TransmitPowerService
com.sec.automation
com.sec.bcservice
com.sec.downloadablekeystore
com.sec.enterprise.knox.attestation
com.sec.enterprise.knox.cloudmdm.smdms
com.sec.enterprise.mdm.services.simpin
com.sec.enterprise.mdm.vpn
com.sec.epdgtestapp
com.sec.everglades
com.sec.everglades.update
com.sec.factory
com.sec.factory.camera
com.sec.factory.iris.usercamera
com.sec.hearingadjust
com.sec.kidsplat.installer
com.sec.knox.foldercontainer
com.sec.knox.knoxsetupwizardclient
com.sec.knox.switcher
com.sec.location.nsflp2
com.sec.mldapchecker
com.sec.modem.settings
com.sec.penup
com.sec.providers.assisteddialing
com.sec.readershub
com.sec.smartcard.manager
com.sec.spen.flashannotate
com.sec.spp.push
com.sec.sve
com.sec.usbsettings
com.sec.vowifispg
com.sec.yosemite.phone
com.sem.factoryapp
com.singtel.mysingtel
com.skms.android.agent
com.skype.raider
com.spotify.music
com.srin.indramayu
com.test.LTEfunctionality
com.touchtype.swiftkey
com.tripadvisor.tripadvisor
com.trustonic.tuiservice
com.tv.peel.samsung.app
com.vlingo.midas
com.wssnps
com.yelp.android.samsungedge
EOF
}

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --install)
                install_systemwide
                ;;
            --version|-v)
                echo "droidB version $VERSION"
                exit 0
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            --device|-d)
                shift
                SERIAL="$1"
                ;;
            *)
                echo -e "${RED}Unknown option: $1${ENDC}"
                show_help
                exit 1
                ;;
        esac
        shift
    done
}

show_help() {
    cat << EOF
${BOLD}${BLUE}droidB v$VERSION${ENDC}

${BOLD}USAGE:${ENDC}
    $SCRIPT_NAME [OPTIONS]

${BOLD}OPTIONS:${ENDC}
    --install           Install droidB system-wide
    --version, -v       Show version information
    --help, -h          Show this help message
    --device, -d        Specify device serial

${BOLD}FEATURES:${ENDC}
    â€¢ Universal Debloater (300+ bloatware packages)
    â€¢ Samsung firmware flashing (Odin4 + Heimdall)
    â€¢ Fastboot operations (flash, unlock, boot)
    â€¢ Full ADB automation
    â€¢ Drag & drop file operations
    â€¢ Device backup/restore
    â€¢ Security-focused design

${BOLD}EXAMPLES:${ENDC}
    $SCRIPT_NAME
    $SCRIPT_NAME --install
    $SCRIPT_NAME --device SERIAL

${BOLD}AUTHOR:${ENDC}
    0xbv1 | 0xb0rn3
    https://github.com/0xb0rn3/droidB

EOF
}

clear_screen() {
    clear
    echo -ne "\033]0;droidB v$VERSION\007"
}

display_banner() {
    clear_screen
    echo -e "${CYAN}"
    cat << 'EOF'
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘                                                          â•‘
    â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—        â•‘
    â•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—       â•‘
    â•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•       â•‘
    â•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—       â•‘
    â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•       â•‘
    â•‘     â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•        â•‘
    â•‘                                                          â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo -e "${ENDC}"
    echo -e "${BOLD}${BLUE}    Advanced Android Device Manager v${VERSION}${ENDC}"
    echo -e "${GREEN}    Universal Debloater | Samsung Tools | Security-Focused${ENDC}"
    echo -e "${MAGENTA}    Developer: ${BOLD}0xbv1 | 0xb0rn3${ENDC}"
    echo -e "${YELLOW}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"
}

process_path() {
    local input="$1"
    input="${input#\'}"
    input="${input%\'}"
    input="${input#\"}"
    input="${input%\"}"
    input="${input//\\ / }"
    input="${input/#\~/$HOME}"
    echo "$input"
}

confirm_action() {
    local prompt="$1"
    read -p "${BOLD}${YELLOW}$prompt (y/N): ${ENDC}" response
    [[ "$response" =~ ^[Yy]$ ]]
}

get_device_info() {
    DEVICES=$($ADB devices 2>/dev/null | tail -n +2 | grep -v "^$" | grep "device$")
    
    if [[ -z "$DEVICES" ]]; then
        DEVICE_INFO=""
        return 1
    fi
    
    DEVICE_COUNT=$(echo "$DEVICES" | wc -l)
    
    if [[ $DEVICE_COUNT -gt 1 ]]; then
        echo -e "${GREEN}Multiple devices connected:${ENDC}"
        echo "$DEVICES" | nl -w 2 -s '. '
        read -p "Select device (number): " CHOICE
        SERIAL=$(echo "$DEVICES" | sed -n "${CHOICE}p" | awk '{print $1}')
    else
        SERIAL=$(echo "$DEVICES" | awk '{print $1}')
    fi
    
    STATE=$($ADB devices | grep $SERIAL | awk '{print $2}')
    
    if [[ "$STATE" == "unauthorized" ]]; then
        echo -e "${RED}Device unauthorized. Check device screen${ENDC}"
        DEVICE_INFO="serial=$SERIAL state=$STATE"
        return 1
    fi
    
    MODEL=$($ADB -s $SERIAL shell getprop ro.product.model 2>/dev/null | tr -d '\r')
    ANDROID_VERSION=$($ADB -s $SERIAL shell getprop ro.build.version.release 2>/dev/null | tr -d '\r')
    MANUFACTURER=$($ADB -s $SERIAL shell getprop ro.product.manufacturer 2>/dev/null | tr -d '\r')
    
    DEVICE_INFO="serial=$SERIAL model=$MODEL android_version=$ANDROID_VERSION manufacturer=$MANUFACTURER state=$STATE"
    
    return 0
}

universal_debloater_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${MAGENTA}ğŸ—‘ï¸  UNIVERSAL DEBLOATER${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        if [[ -z "$SERIAL" ]]; then
            echo -e "${RED}No device connected${ENDC}"
            read -p "Press Enter to return..."
            return
        fi
        
        echo -e "${GREEN}Device: $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+' || echo 'Unknown')${ENDC}"
        echo -e "${CYAN}Serial: $SERIAL${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        local app_count=$(grep -cv "^$\|^#" "$DEBLOAT_LIST_FILE" 2>/dev/null || echo "0")
        echo -e "${BOLD}Embedded bloatware list: ${GREEN}$app_count packages${ENDC}"
        
        echo ""
        echo "1. Debloat with embedded list (recommended)"
        echo "2. Debloat with custom list file"
        echo "3. Preview embedded debloat list"
        echo "4. Selective debloat (choose apps)"
        echo "5. Scan device for bloatware"
        echo "6. Revert/Restore debloated apps"
        echo "7. Create backup before debloat"
        echo "8. Export embedded list to file"
        echo "9. Back to main menu"
        echo ""
        
        read -p "Select option: " choice
        
        case $choice in
            1) debloat_with_embedded_list ;;
            2) debloat_with_custom_list ;;
            3) preview_debloat_list ;;
            4) selective_debloat ;;
            5) scan_for_bloatware ;;
            6) revert_debloat ;;
            7) backup_before_debloat ;;
            8) export_embedded_list ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

debloat_with_embedded_list() {
    clear_screen
    echo -e "${BOLD}${RED}âš ï¸  DEBLOAT WITH EMBEDDED LIST âš ï¸${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    local app_count=$(grep -cv "^$\|^#" "$DEBLOAT_LIST_FILE")
    echo -e "${WHITE}This will remove ${GREEN}$app_count${WHITE} bloatware packages from your device.${ENDC}"
    echo -e "${YELLOW}These apps will be uninstalled for the current user (data preserved).${ENDC}"
    echo -e "${CYAN}You can restore them later using the revert function.${ENDC}"
    echo ""
    echo -e "${RED}WARNING: Some apps may be needed for certain features.${ENDC}"
    echo -e "${RED}This action cannot be easily undone and may affect device functionality.${ENDC}"
    echo ""
    
    confirm_action "Proceed with debloat?" || return
    
    echo ""
    echo -e "${BLUE}Starting debloat process...${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    local success_count=0
    local fail_count=0
    local not_found_count=0
    
    mapfile -t packages < "$DEBLOAT_LIST_FILE"
    
    for package in "${packages[@]}"; do
        [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
        
        package=$(echo "$package" | xargs | tr -d '\r\n')
        
        [[ -z "$package" ]] && continue
        
        echo -ne "${CYAN}Removing: ${WHITE}$package${ENDC}..."
        
        if $ADB -s $SERIAL shell pm list packages 2>/dev/null | grep -q "^package:$package$"; then
            local result=$($ADB -s $SERIAL shell pm uninstall -k --user 0 "$package" 2>/dev/null)
            if echo "$result" | grep -q "Success"; then
                echo -e " ${GREEN}[SUCCESS]${ENDC}"
                ((success_count++))
            else
                echo -e " ${RED}[FAILED]${ENDC}"
                ((fail_count++))
            fi
        else
            echo -e " ${YELLOW}[NOT FOUND]${ENDC}"
            ((not_found_count++))
        fi
    done
    
    echo ""
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    echo -e "${BOLD}${GREEN}Debloat Summary:${ENDC}"
    echo -e "${GREEN}  âœ“ Successfully removed: $success_count packages${ENDC}"
    echo -e "${RED}  âœ— Failed to remove: $fail_count packages${ENDC}"
    echo -e "${YELLOW}  - Not found on device: $not_found_count packages${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    echo -e "${WHITE}Debloat process completed!${ENDC}"
    
    echo ""
    read -p "Reboot device now? (y/N): " reboot_choice
    if [[ "$reboot_choice" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Rebooting device...${ENDC}"
        $ADB -s $SERIAL reboot
        echo -e "${GREEN}Reboot command sent${ENDC}"
    fi
    
    read -p "Press Enter to continue..."
}

debloat_with_custom_list() {
    clear_screen
    echo -e "${BOLD}${CYAN}DEBLOAT WITH CUSTOM LIST${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo -e "${WHITE}Drag & drop your custom debloat list file:${ENDC}"
    echo -e "${CYAN}Format: One package name per line, # for comments${ENDC}"
    echo ""
    
    read -p "File path: " custom_file
    custom_file=$(process_path "$custom_file")
    
    if [[ ! -f "$custom_file" ]]; then
        echo -e "${RED}File not found: $custom_file${ENDC}"
        sleep 2
        return
    fi
    
    local app_count=$(grep -cv "^$\|^#" "$custom_file")
    echo ""
    echo -e "${GREEN}Found $app_count packages in custom list${ENDC}"
    echo ""
    
    confirm_action "Proceed with custom debloat?" || return
    
    echo ""
    echo -e "${BLUE}Starting custom debloat process...${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    local success_count=0
    local fail_count=0
    local not_found_count=0
    
    mapfile -t packages < "$custom_file"
    
    for package in "${packages[@]}"; do
        [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
        
        package=$(echo "$package" | xargs | tr -d '\r\n')
        
        [[ -z "$package" ]] && continue
        
        echo -ne "${CYAN}Removing: ${WHITE}$package${ENDC}..."
        
        if $ADB -s $SERIAL shell pm list packages 2>/dev/null | grep -q "^package:$package$"; then
            local result=$($ADB -s $SERIAL shell pm uninstall -k --user 0 "$package" 2>/dev/null)
            if echo "$result" | grep -q "Success"; then
                echo -e " ${GREEN}[SUCCESS]${ENDC}"
                ((success_count++))
            else
                echo -e " ${RED}[FAILED]${ENDC}"
                ((fail_count++))
            fi
        else
            echo -e " ${YELLOW}[NOT FOUND]${ENDC}"
            ((not_found_count++))
        fi
    done
    
    echo ""
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    echo -e "${GREEN}Successfully removed: $success_count${ENDC}"
    echo -e "${RED}Failed: $fail_count${ENDC}"
    echo -e "${YELLOW}Not found: $not_found_count${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    read -p "Press Enter..."
}

preview_debloat_list() {
    clear_screen
    echo -e "${BOLD}${CYAN}EMBEDDED DEBLOAT LIST PREVIEW${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    cat "$DEBLOAT_LIST_FILE" | less
    
    read -p "Press Enter to continue..."
}

selective_debloat() {
    clear_screen
    echo -e "${BOLD}${CYAN}SELECTIVE DEBLOAT${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo "1. Amazon bloatware"
    echo "2. Facebook apps"
    echo "3. Google apps"
    echo "4. Microsoft Office"
    echo "5. Samsung bloatware"
    echo "6. Bixby services"
    echo "7. Custom package names"
    echo ""
    
    read -p "Select category: " category
    
    local packages=""
    
    case $category in
        1) packages="com.amazon.fv com.amazon.kindle com.amazon.mp3 com.amazon.mShop.android com.amazon.venezia" ;;
        2) packages="com.facebook.appmanager com.facebook.katana com.facebook.services com.facebook.system" ;;
        3) packages="com.google.android.apps.docs com.google.android.apps.maps com.google.android.youtube com.google.android.apps.books" ;;
        4) packages="com.microsoft.office.excel com.microsoft.office.word com.microsoft.office.powerpoint com.microsoft.office.outlook" ;;
        5) packages="com.samsung.android.app.sbrowseredge com.samsung.android.tvplus com.samsung.android.calendar" ;;
        6) packages="com.samsung.android.bixby.agent com.samsung.android.bixby.service com.samsung.android.bixby.wakeup com.samsung.android.bixbyvision.framework" ;;
        7)
            echo ""
            echo -e "${WHITE}Enter package names (space separated):${ENDC}"
            read -p "> " packages
            ;;
        *) echo -e "${RED}Invalid option${ENDC}"; sleep 1; return ;;
    esac
    
    [[ -z "$packages" ]] && return
    
    echo ""
    for pkg in $packages; do
        echo -ne "${CYAN}Removing: ${WHITE}$pkg${ENDC}..."
        local result=$($ADB -s $SERIAL shell pm uninstall -k --user 0 "$pkg" 2>/dev/null)
        if echo "$result" | grep -q "Success"; then
            echo -e " ${GREEN}[SUCCESS]${ENDC}"
        else
            echo -e " ${RED}[FAILED]${ENDC}"
        fi
    done
    
    read -p "Press Enter..."
}

scan_for_bloatware() {
    clear_screen
    echo -e "${BOLD}${CYAN}SCAN DEVICE FOR BLOATWARE${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo -e "${BLUE}Scanning device...${ENDC}"
    echo ""
    
    local found_count=0
    
    mapfile -t packages < "$DEBLOAT_LIST_FILE"
    
    for package in "${packages[@]}"; do
        [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
        
        package=$(echo "$package" | xargs | tr -d '\r\n')
        
        [[ -z "$package" ]] && continue
        
        if $ADB -s $SERIAL shell pm list packages 2>/dev/null | grep -q "^package:$package$"; then
            echo -e "${RED}[FOUND]${ENDC} $package"
            ((found_count++))
        fi
    done
    
    echo ""
    echo -e "${RED}Found $found_count bloatware packages on device${ENDC}"
    
    read -p "Press Enter..."
}

revert_debloat() {
    clear_screen
    echo -e "${BOLD}${GREEN}REVERT/RESTORE DEBLOATED APPS${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo "1. Restore all apps from embedded list"
    echo "2. Restore specific packages"
    echo "3. Back"
    echo ""
    
    read -p "Select option: " choice
    
    case $choice in
        1)
            confirm_action "Restore all packages?" || return
            
            echo ""
            echo -e "${BLUE}Starting restore process...${ENDC}"
            echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
            
            local success_count=0
            local fail_count=0
            
            mapfile -t packages < "$DEBLOAT_LIST_FILE"
            
            for package in "${packages[@]}"; do
                [[ -z "$package" || "$package" =~ ^[[:space:]]*# ]] && continue
                
                package=$(echo "$package" | xargs | tr -d '\r\n')
                
                [[ -z "$package" ]] && continue
                
                echo -ne "${CYAN}Restoring: ${WHITE}$package${ENDC}..."
                
                local result=$($ADB -s $SERIAL shell cmd package install-existing "$package" 2>&1)
                if echo "$result" | grep -q "Package .* installed for user"; then
                    echo -e " ${GREEN}[SUCCESS]${ENDC}"
                    ((success_count++))
                else
                    echo -e " ${RED}[FAILED]${ENDC}"
                    ((fail_count++))
                fi
            done
            
            echo ""
            echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
            echo -e "${GREEN}Restored: $success_count${ENDC} | ${RED}Failed: $fail_count${ENDC}"
            echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
            ;;
        2)
            echo ""
            echo -e "${WHITE}Enter package names (space separated):${ENDC}"
            read -p "> " packages
            
            echo ""
            for package in $packages; do
                echo -ne "${CYAN}Restoring: ${WHITE}$package${ENDC}..."
                local result=$($ADB -s $SERIAL shell cmd package install-existing "$package" 2>&1)
                if echo "$result" | grep -q "Package .* installed for user"; then
                    echo -e " ${GREEN}[SUCCESS]${ENDC}"
                else
                    echo -e " ${RED}[FAILED]${ENDC}"
                fi
            done
            ;;
    esac
    
    read -p "Press Enter..."
}

backup_before_debloat() {
    clear_screen
    echo -e "${BOLD}${CYAN}BACKUP PACKAGE LIST${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    local backup_file="debloat_backup_$(date +%Y%m%d_%H%M%S).txt"
    
    echo "# droidB Backup - $(date)" > "$backup_file"
    echo "# Device: $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+')" >> "$backup_file"
    echo "# Serial: $SERIAL" >> "$backup_file"
    echo "" >> "$backup_file"
    $ADB -s $SERIAL shell pm list packages | sed 's/package://' >> "$backup_file"
    
    echo ""
    echo -e "${GREEN}âœ“ Backup saved: $backup_file${ENDC}"
    echo -e "${CYAN}Total packages: $(grep -cv "^$\|^#" "$backup_file")${ENDC}"
    
    read -p "Press Enter..."
}

export_embedded_list() {
    clear_screen
    echo -e "${BOLD}${CYAN}EXPORT EMBEDDED LIST${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    local export_file="droidb_debloat_list_$(date +%Y%m%d).txt"
    
    cp "$DEBLOAT_LIST_FILE" "$export_file"
    
    echo ""
    echo -e "${GREEN}âœ“ List exported to: $export_file${ENDC}"
    echo -e "${CYAN}Location: $(pwd)/$export_file${ENDC}"
    
    read -p "Press Enter..."
}

check_samsung_tools() {
    if command -v odin4 &>/dev/null; then
        ODIN4_INSTALLED=true
        echo -e "${GREEN}âœ“ Odin4: Installed${ENDC}"
    else
        echo -e "${YELLOW}âš  Odin4: Not installed${ENDC}"
    fi
    
    if command -v heimdall &>/dev/null; then
        HEIMDALL_INSTALLED=true
        echo -e "${GREEN}âœ“ Heimdall: Installed${ENDC}"
    else
        echo -e "${YELLOW}âš  Heimdall: Not installed${ENDC}"
    fi
}

setup_samsung_udev_rules() {
    local RULES_FILE="/etc/udev/rules.d/51-samsung.rules"
    
    if [[ ! -f "$RULES_FILE" ]]; then
        echo -e "${BLUE}Setting up Samsung USB rules...${ENDC}"
        
        cat << 'EOF' | sudo tee "$RULES_FILE" > /dev/null
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", MODE="0666", GROUP="plugdev"
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="6860", MODE="0666", GROUP="plugdev"
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="68??", MODE="0666", GROUP="plugdev"
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="685d", MODE="0666", GROUP="plugdev"
EOF
        
        sudo udevadm control --reload-rules
        sudo udevadm trigger
        sudo usermod -a -G plugdev $USER 2>/dev/null
        
        echo -e "${GREEN}âœ“ Samsung USB rules configured${ENDC}"
        echo -e "${YELLOW}You may need to log out and log back in for group changes to take effect${ENDC}"
    fi
}

install_odin4_auto() {
    if [[ "$OSTYPE" != "linux-gnu"* ]]; then
        echo -e "${YELLOW}Odin4 is only available for Linux.${ENDC}"
        return 1
    fi
    
    if command -v odin4 &>/dev/null; then
        echo -e "${GREEN}Odin4 already installed.${ENDC}"
        ODIN4_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Odin4 for Linux...${ENDC}"
    
    if command -v yay &>/dev/null; then
        echo -e "${BLUE}Installing via AUR (yay)...${ENDC}"
        yay -S --noconfirm odin4-cli 2>/dev/null && ODIN4_INSTALLED=true
    elif command -v paru &>/dev/null; then
        echo -e "${BLUE}Installing via AUR (paru)...${ENDC}"
        paru -S --noconfirm odin4-cli 2>/dev/null && ODIN4_INSTALLED=true
    else
        echo -e "${BLUE}Downloading Odin4 from GitHub...${ENDC}"
        ODIN_URL="https://github.com/Adrilaw/OdinV4/releases/download/v1.0/odin.zip"
        TEMP_DIR=$(mktemp -d)
        
        if wget -q "$ODIN_URL" -O "$TEMP_DIR/odin.zip"; then
            cd "$TEMP_DIR"
            unzip -q odin.zip
            
            if [[ -f "odin4" ]]; then
                chmod +x odin4
                sudo mv odin4 /usr/local/bin/
                ODIN4_INSTALLED=true
                echo -e "${GREEN}Odin4 installed successfully${ENDC}"
            else
                echo -e "${RED}Odin4 binary not found in archive${ENDC}"
            fi
            
            cd - >/dev/null
            rm -rf "$TEMP_DIR"
        else
            echo -e "${RED}Failed to download Odin4${ENDC}"
        fi
    fi
    
    setup_samsung_udev_rules
    
    return $([[ $ODIN4_INSTALLED == true ]] && echo 0 || echo 1)
}

install_heimdall() {
    if command -v heimdall &>/dev/null; then
        echo -e "${GREEN}Heimdall already installed.${ENDC}"
        HEIMDALL_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Heimdall...${ENDC}"
    
    if [[ -f /etc/debian_version ]]; then
        sudo apt update && sudo apt install -y heimdall-flash
    elif [[ -f /etc/arch-release ]]; then
        sudo pacman -S --noconfirm heimdall
    elif [[ -f /etc/redhat-release ]]; then
        sudo dnf install -y heimdall
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        command -v brew &>/dev/null && brew install heimdall
    else
        echo -e "${RED}Unsupported OS for automatic Heimdall installation${ENDC}"
        return 1
    fi
    
    command -v heimdall &>/dev/null && HEIMDALL_INSTALLED=true
}

samsung_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${MAGENTA}ğŸ“± SAMSUNG OPERATIONS${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        echo -e "${CYAN}Tool Status:${ENDC}"
        echo -e "  Odin4:    $([[ $ODIN4_INSTALLED == true ]] && echo "${GREEN}âœ“ Installed${ENDC}" || echo "${RED}âœ— Not Installed${ENDC}")"
        echo -e "  Heimdall: $([[ $HEIMDALL_INSTALLED == true ]] && echo "${GREEN}âœ“ Installed${ENDC}" || echo "${RED}âœ— Not Installed${ENDC}")"
        echo ""
        
        if [[ $ODIN4_INSTALLED == false && $HEIMDALL_INSTALLED == false ]]; then
            echo -e "${RED}No Samsung tools installed${ENDC}"
            echo ""
            echo "1. Install Odin4 (Linux only)"
            echo "2. Install Heimdall"
            echo "3. Setup Samsung USB rules"
            echo "4. Back to main menu"
            echo ""
            
            read -p "Select: " opt
            case $opt in
                1) install_odin4_auto; read -p "Press Enter..." ;;
                2) install_heimdall; read -p "Press Enter..." ;;
                3) setup_samsung_udev_rules; read -p "Press Enter..." ;;
                4) return ;;
            esac
        else
            echo "1. Flash firmware with Odin4 (BL/AP/CP/CSC)"
            echo "2. Flash single partition with Odin4"
            echo "3. Flash with Heimdall"
            echo "4. Check download mode"
            echo "5. PIT file operations"
            echo "6. Heimdall print partition table"
            echo "7. Odin4 list devices"
            echo "8. Install/Update Samsung tools"
            echo "9. Back to main menu"
            echo ""
            
            read -p "Select: " opt
            
            case $opt in
                1) samsung_flash_firmware ;;
                2) samsung_flash_single ;;
                3) samsung_flash_heimdall ;;
                4) check_download_mode ;;
                5) pit_operations ;;
                6) heimdall_print_partition ;;
                7) odin4_list_devices ;;
                8) samsung_tools_menu ;;
                9) return ;;
            esac
        fi
    done
}

samsung_flash_firmware() {
    clear_screen
    echo -e "${BOLD}${MAGENTA}SAMSUNG FIRMWARE FLASH (Odin4)${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    # â”€â”€ Pre-flash backup check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    pre_flash_backup_check || return
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    if [[ $ODIN4_INSTALLED == false ]]; then
        echo -e "${RED}Odin4 not installed${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo -e "${CYAN}Drag & drop .tar/.tar.md5 files or type paths${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo -e "\n${BOLD}Firmware Files:${ENDC}"
    
    echo -e "${BLUE}BL (Bootloader) - optional:${ENDC}"
    read -p "Path: " BL_FILE
    BL_FILE=$(process_path "$BL_FILE")
    
    echo -e "${BLUE}AP (System/PDA) - required:${ENDC}"
    read -p "Path: " AP_FILE
    AP_FILE=$(process_path "$AP_FILE")
    
    echo -e "${BLUE}CP (Modem) - optional:${ENDC}"
    read -p "Path: " CP_FILE
    CP_FILE=$(process_path "$CP_FILE")
    
    echo -e "${BLUE}CSC (Region) - optional:${ENDC}"
    read -p "Path: " CSC_FILE
    CSC_FILE=$(process_path "$CSC_FILE")
    
    echo -e "${BLUE}HOME_CSC (Keep Data) - optional:${ENDC}"
    read -p "Path (use instead of CSC to keep data): " HOME_CSC_FILE
    HOME_CSC_FILE=$(process_path "$HOME_CSC_FILE")
    
    if [[ -z "$AP_FILE" || ! -f "$AP_FILE" ]]; then
        echo -e "${RED}AP file is required for flashing${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    local ODIN_CMD="sudo odin4"
    
    [[ -n "$BL_FILE" && -f "$BL_FILE" ]] && ODIN_CMD="$ODIN_CMD -b \"$BL_FILE\""
    [[ -n "$AP_FILE" && -f "$AP_FILE" ]] && ODIN_CMD="$ODIN_CMD -a \"$AP_FILE\""
    [[ -n "$CP_FILE" && -f "$CP_FILE" ]] && ODIN_CMD="$ODIN_CMD -c \"$CP_FILE\""
    
    if [[ -n "$HOME_CSC_FILE" && -f "$HOME_CSC_FILE" ]]; then
        ODIN_CMD="$ODIN_CMD -s \"$HOME_CSC_FILE\""
    elif [[ -n "$CSC_FILE" && -f "$CSC_FILE" ]]; then
        ODIN_CMD="$ODIN_CMD -s \"$CSC_FILE\""
    fi
    
    echo -e "\n${BOLD}${YELLOW}Flash Summary:${ENDC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    [[ -n "$BL_FILE" && -f "$BL_FILE" ]] && echo -e "BL: ${GREEN}$(basename "$BL_FILE")${ENDC}"
    [[ -n "$AP_FILE" && -f "$AP_FILE" ]] && echo -e "AP: ${GREEN}$(basename "$AP_FILE")${ENDC}"
    [[ -n "$CP_FILE" && -f "$CP_FILE" ]] && echo -e "CP: ${GREEN}$(basename "$CP_FILE")${ENDC}"
    [[ -n "$CSC_FILE" && -f "$CSC_FILE" ]] && echo -e "CSC: ${GREEN}$(basename "$CSC_FILE")${ENDC}"
    [[ -n "$HOME_CSC_FILE" && -f "$HOME_CSC_FILE" ]] && echo -e "HOME_CSC: ${GREEN}$(basename "$HOME_CSC_FILE")${ENDC}"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    
    echo -e "\n${RED}${BOLD}âš ï¸  CRITICAL WARNING âš ï¸${ENDC}"
    echo -e "${RED}This will replace device firmware!${ENDC}"
    echo -e "${RED}Wrong firmware = BRICK${ENDC}"
    echo -e "${RED}Device must be in Download Mode${ENDC}"
    
    confirm_action "Proceed with firmware flash?" || return
    
    echo -e "\n${BLUE}Executing: $ODIN_CMD${ENDC}"
    eval $ODIN_CMD
    
    if [[ $? -eq 0 ]]; then
        echo -e "\n${GREEN}${BOLD}âœ“ Flash completed successfully!${ENDC}"
    else
        echo -e "\n${RED}${BOLD}âœ— Flash failed! Check device and try again.${ENDC}"
    fi
    
    read -p "Press Enter to continue..."
}

samsung_flash_single() {
    clear_screen
    echo -e "${BOLD}${MAGENTA}FLASH SINGLE PARTITION${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    pre_flash_backup_check || return
    
    echo "Select partition type:"
    echo "1. BL (Bootloader)"
    echo "2. AP (System)"
    echo "3. CP (Modem)"
    echo "4. CSC (Region)"
    echo ""
    
    read -p "Select: " part_type
    
    echo -e "\n${YELLOW}Drag & drop file:${ENDC}"
    read -p "File path: " FILE
    FILE=$(process_path "$FILE")
    
    if [[ ! -f "$FILE" ]]; then
        echo -e "${RED}File not found${ENDC}"
        sleep 2
        return
    fi
    
    confirm_action "Flash $(basename "$FILE")?" || return
    
    case $part_type in
        1) sudo odin4 -b "$FILE" ;;
        2) sudo odin4 -a "$FILE" ;;
        3) sudo odin4 -c "$FILE" ;;
        4) sudo odin4 -s "$FILE" ;;
        *) echo -e "${RED}Invalid option${ENDC}"; sleep 2; return ;;
    esac
    
    read -p "Press Enter..."
}

samsung_flash_heimdall() {
    clear_screen
    echo -e "${BOLD}${MAGENTA}FLASH WITH HEIMDALL${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    pre_flash_backup_check || return
    
    if [[ $HEIMDALL_INSTALLED == false ]]; then
        echo -e "${RED}Heimdall not installed${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo "1. Flash recovery"
    echo "2. Flash kernel (boot)"
    echo "3. Flash system"
    echo "4. Flash cache"
    echo "5. Flash userdata"
    echo "6. Custom partition"
    echo ""
    
    read -p "Select: " opt
    
    echo -e "\n${YELLOW}Drag & drop image file:${ENDC}"
    read -p "File path: " FILE
    FILE=$(process_path "$FILE")
    
    if [[ ! -f "$FILE" ]]; then
        echo -e "${RED}File not found${ENDC}"
        sleep 2
        return
    fi
    
    confirm_action "Flash with Heimdall?" || return
    
    case $opt in
        1) sudo heimdall flash --RECOVERY "$FILE" --no-reboot ;;
        2) sudo heimdall flash --KERNEL "$FILE" --no-reboot ;;
        3) sudo heimdall flash --SYSTEM "$FILE" --no-reboot ;;
        4) sudo heimdall flash --CACHE "$FILE" --no-reboot ;;
        5) sudo heimdall flash --USERDATA "$FILE" --no-reboot ;;
        6)
            read -p "Partition name (uppercase, e.g. BOOT): " PART
            sudo heimdall flash --$PART "$FILE" --no-reboot
            ;;
    esac
    
    if [[ $? -eq 0 ]]; then
        echo -e "\n${GREEN}Flash completed successfully${ENDC}"
        read -p "Reboot device now? (y/N): " reboot_choice
        if [[ "$reboot_choice" =~ ^[Yy]$ ]]; then
            sudo heimdall reboot
        fi
    fi
    
    read -p "Press Enter..."
}

check_download_mode() {
    clear_screen
    echo -e "${BOLD}${CYAN}CHECK SAMSUNG DOWNLOAD MODE${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo -e "${BLUE}Checking for Samsung devices...${ENDC}"
    echo ""
    
    lsusb | grep "04e8:" && echo -e "\n${GREEN}Samsung device detected${ENDC}" || echo -e "\n${RED}No Samsung devices found${ENDC}"
    
    echo ""
    if [[ $ODIN4_INSTALLED == true ]]; then
        echo -e "${BLUE}Odin4 device list:${ENDC}"
        sudo odin4 -l 2>/dev/null || echo -e "${YELLOW}No devices in download mode${ENDC}"
    fi
    
    if [[ $HEIMDALL_INSTALLED == true ]]; then
        echo ""
        echo -e "${BLUE}Heimdall device detection:${ENDC}"
        sudo heimdall detect 2>/dev/null || echo -e "${YELLOW}No devices detected${ENDC}"
    fi
    
    echo ""
    echo -e "${CYAN}To enter Download Mode:${ENDC}"
    echo "  1. Power off device"
    echo "  2. Hold Volume Down + Power"
    echo "  3. Press Volume Up to confirm"
    read -p "Press Enter..."
}

pit_operations() {
    clear_screen
    echo -e "${BOLD}${CYAN}PIT FILE OPERATIONS${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    if [[ $HEIMDALL_INSTALLED == false ]]; then
        echo -e "${RED}Heimdall required for PIT operations${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo "1. Download PIT from device"
    echo "2. Print PIT info"
    echo "3. Flash with PIT (Odin4)"
    echo "4. Back"
    echo ""
    
    read -p "Select: " opt
    
    case $opt in
        1)
            read -p "Output filename (e.g., device.pit): " PIT_FILE
            PIT_FILE=${PIT_FILE:-device.pit}
            sudo heimdall download-pit --output "$PIT_FILE"
            [[ -f "$PIT_FILE" ]] && echo -e "${GREEN}âœ“ PIT saved: $PIT_FILE${ENDC}"
            ;;
        2)
            sudo heimdall print-pit
            ;;
        3)
            if [[ $ODIN4_INSTALLED == false ]]; then
                echo -e "${RED}Odin4 not installed${ENDC}"
            else
                read -p "PIT file path: " PIT
                PIT=$(process_path "$PIT")
                [[ -f "$PIT" ]] && sudo odin4 --pit "$PIT"
            fi
            ;;
    esac
    
    [[ $opt != 4 ]] && read -p "Press Enter..."
}

heimdall_print_partition() {
    clear_screen
    echo -e "${BOLD}${CYAN}HEIMDALL PARTITION TABLE${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    if [[ $HEIMDALL_INSTALLED == false ]]; then
        echo -e "${RED}Heimdall not installed${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo -e "${BLUE}Printing partition table...${ENDC}"
    echo ""
    
    sudo heimdall print-pit
    
    read -p "Press Enter..."
}

odin4_list_devices() {
    clear_screen
    echo -e "${BOLD}${CYAN}ODIN4 DEVICE LIST${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    if [[ $ODIN4_INSTALLED == false ]]; then
        echo -e "${RED}Odin4 not installed${ENDC}"
        read -p "Press Enter..."
        return
    fi
    
    echo -e "${BLUE}Listing devices...${ENDC}"
    echo ""
    
    sudo odin4 -l 2>/dev/null || echo -e "${YELLOW}No devices found${ENDC}"
    
    read -p "Press Enter..."
}

samsung_tools_menu() {
    clear_screen
    echo -e "${BOLD}${CYAN}SAMSUNG TOOLS INSTALLATION${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    echo "1. Install Odin4"
    echo "2. Install Heimdall"
    echo "3. Setup USB rules"
    echo "4. Back"
    echo ""
    
    read -p "Select: " opt
    
    case $opt in
        1) install_odin4_auto ;;
        2) install_heimdall ;;
        3) setup_samsung_udev_rules ;;
    esac
    
    [[ $opt != 4 ]] && read -p "Press Enter..."
}

display_device_info() {
    clear_screen
    echo -e "${BOLD}${CYAN}ğŸ“± DEVICE INFORMATION${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    
    if [[ -z "$DEVICE_INFO" ]]; then
        echo -e "${RED}No device information available${ENDC}"
    else
        echo -e "${GREEN}Serial:${ENDC}           $(echo $DEVICE_INFO | grep -oP 'serial=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}Manufacturer:${ENDC}     $(echo $DEVICE_INFO | grep -oP 'manufacturer=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}Model:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}Android Version:${ENDC}  $(echo $DEVICE_INFO | grep -oP 'android_version=\K[^ ]+' || echo 'N/A')"
        echo -e "${GREEN}State:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+' || echo 'N/A')"
        
        echo ""
        echo -e "${CYAN}Additional Properties:${ENDC}"
        
        BRAND=$($ADB -s $SERIAL shell getprop ro.product.brand 2>/dev/null | tr -d '\r')
        DEVICE=$($ADB -s $SERIAL shell getprop ro.product.device 2>/dev/null | tr -d '\r')
        SDK=$($ADB -s $SERIAL shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r')
        SECURITY_PATCH=$($ADB -s $SERIAL shell getprop ro.build.version.security_patch 2>/dev/null | tr -d '\r')
        
        [[ -n "$BRAND" ]] && echo -e "${GREEN}Brand:${ENDC}            $BRAND"
        [[ -n "$DEVICE" ]] && echo -e "${GREEN}Device:${ENDC}           $DEVICE"
        [[ -n "$SDK" ]] && echo -e "${GREEN}SDK Level:${ENDC}        $SDK"
        [[ -n "$SECURITY_PATCH" ]] && echo -e "${GREEN}Security Patch:${ENDC}   $SECURITY_PATCH"
    fi
    
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    read -p "Press Enter to continue..."
}

# ============================================================
#  PUSH APK AS SYSTEM APP  (tinkerer feature)
#  Requires root (su) â€” tested with Magisk / KernelSU
#  Includes: auto-permissions, privapp XML, APK signing
# ============================================================

# â”€â”€ Root helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_check_root() {
    local t
    t=$($ADB -s "$SERIAL" shell "su -c 'id' 2>/dev/null" | tr -d '\r')
    echo "$t" | grep -q "uid=0" && return 0
    t=$($ADB -s "$SERIAL" shell "id" 2>/dev/null | tr -d '\r')
    echo "$t" | grep -q "uid=0" && return 0
    return 1
}

# Run a command as root â€” wraps args in single-quoted su -c call
_su() { $ADB -s "$SERIAL" shell "su -c '$*' 2>/dev/null" 2>/dev/null | tr -d '\r'; }

_system_writable() {
    [[ "$(_su "touch /system/.droidb_test && rm /system/.droidb_test && echo yes")" == "yes" ]]
}

_remount_rw() {
    echo -e "  ${YELLOW}Remounting /system read-writeâ€¦${ENDC}"
    _su "magisk --mount-master" 2>/dev/null
    _su "mount -o rw,remount /system" 2>/dev/null
    _su "mount -o remount,rw \$(mount | grep ' /system ' | awk '{print \$1}') /system" 2>/dev/null
    if _system_writable; then
        echo -e "  ${GREEN}âœ“ /system is now writable${ENDC}"; return 0
    else
        echo -e "  ${RED}âœ— Could not remount /system rw â€” try Magisk OverlayFS or a custom recovery${ENDC}"
        return 1
    fi
}

_remount_ro() {
    _su "mount -o ro,remount /system" 2>/dev/null
    echo -e "  ${CYAN}â†© /system remounted read-only${ENDC}"
}

# â”€â”€ APK helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_pick_system_dir() {
    echo ""
    echo -e "  ${BOLD}Target directory on device:${ENDC}"
    echo "    1. /system/app          â€” standard system app"
    echo "    2. /system/priv-app     â€” privileged (signature-level perms, PM-protected)"
    echo "    3. /system/product/app  â€” product partition"
    echo "    4. Custom path"
    read -rp "  Choice [1-4, default=2]: " dir_choice
    case "${dir_choice:-2}" in
        1) SYS_TARGET="/system/app" ;;
        2) SYS_TARGET="/system/priv-app" ;;
        3) SYS_TARGET="/system/product/app" ;;
        4) read -rp "  Custom path: " SYS_TARGET ;;
        *) SYS_TARGET="/system/priv-app" ;;
    esac
    echo -e "  ${CYAN}Target: $SYS_TARGET${ENDC}"
}

_get_pkg_name() {
    local apk="$1" pkg=""
    if command -v aapt &>/dev/null; then
        pkg=$(aapt dump badging "$apk" 2>/dev/null | grep "^package:" | grep -oP "name='\K[^']+")
    elif command -v aapt2 &>/dev/null; then
        pkg=$(aapt2 dump badging "$apk" 2>/dev/null | grep "^package:" | grep -oP "name='\K[^']+")
    fi
    # Fallback: parse AndroidManifest.xml directly from the zip
    if [[ -z "$pkg" ]]; then
        pkg=$(unzip -p "$apk" AndroidManifest.xml 2>/dev/null \
            | strings | grep -oP 'com\.[a-zA-Z0-9._]+' | head -1)
    fi
    [[ -z "$pkg" ]] && pkg=$(basename "$apk" .apk)
    echo "$pkg"
}

_validate_apk() {
    local apk="$1"
    if ! unzip -l "$apk" 2>/dev/null | grep -q "META-INF/"; then
        echo -e "  ${RED}âœ— Not a valid signed APK (no META-INF)${ENDC}"; return 1
    fi
    return 0
}

# Extract all uses-permission entries declared in the APK
_get_apk_declared_perms() {
    local apk="$1"
    if command -v aapt &>/dev/null; then
        aapt dump permissions "$apk" 2>/dev/null \
            | grep "uses-permission:" \
            | grep -oP "name='\K[^']+"
    elif command -v aapt2 &>/dev/null; then
        aapt2 dump permissions "$apk" 2>/dev/null \
            | grep "uses-permission:" \
            | grep -oP "name='\K[^']+"
    else
        # Fallback: pull strings from manifest (less accurate but works without aapt)
        unzip -p "$apk" AndroidManifest.xml 2>/dev/null \
            | strings \
            | grep -E "android\.permission\.[A-Z_]+" \
            | sort -u
    fi
}

# â”€â”€ Permission system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# All dangerous / sensitive permission groups
declare -A _PERM_GROUPS=(
    [location]="android.permission.ACCESS_FINE_LOCATION android.permission.ACCESS_COARSE_LOCATION android.permission.ACCESS_BACKGROUND_LOCATION"
    [contacts]="android.permission.READ_CONTACTS android.permission.WRITE_CONTACTS android.permission.GET_ACCOUNTS"
    [camera]="android.permission.CAMERA"
    [microphone]="android.permission.RECORD_AUDIO"
    [storage]="android.permission.READ_EXTERNAL_STORAGE android.permission.WRITE_EXTERNAL_STORAGE android.permission.MANAGE_EXTERNAL_STORAGE android.permission.READ_MEDIA_IMAGES android.permission.READ_MEDIA_VIDEO android.permission.READ_MEDIA_AUDIO"
    [phone]="android.permission.READ_PHONE_STATE android.permission.CALL_PHONE android.permission.READ_CALL_LOG android.permission.WRITE_CALL_LOG android.permission.ADD_VOICEMAIL android.permission.USE_SIP"
    [sms]="android.permission.SEND_SMS android.permission.RECEIVE_SMS android.permission.READ_SMS android.permission.RECEIVE_WAP_PUSH android.permission.RECEIVE_MMS"
    [calendar]="android.permission.READ_CALENDAR android.permission.WRITE_CALENDAR"
    [sensors]="android.permission.BODY_SENSORS android.permission.ACTIVITY_RECOGNITION"
    [bluetooth]="android.permission.BLUETOOTH_SCAN android.permission.BLUETOOTH_CONNECT android.permission.BLUETOOTH_ADVERTISE"
    [notifications]="android.permission.POST_NOTIFICATIONS"
    [system_alert]="android.permission.SYSTEM_ALERT_WINDOW"
    [install_packages]="android.permission.REQUEST_INSTALL_PACKAGES android.permission.INSTALL_PACKAGES"
    [device_admin]="android.permission.BIND_DEVICE_ADMIN"
    [accessibility]="android.permission.BIND_ACCESSIBILITY_SERVICE"
)

# Preset profiles
declare -A _PERM_PRESETS=(
    [social]="location contacts camera microphone storage notifications"
    [dev_root]="location contacts camera microphone storage phone sms calendar sensors bluetooth notifications system_alert install_packages"
    [media]="camera microphone storage notifications"
    [full]="location contacts camera microphone storage phone sms calendar sensors bluetooth notifications system_alert install_packages device_admin accessibility"
)

_permission_profile_menu() {
    # Returns selected permissions in SELECTED_PERMS (space-separated android.permission.* list)
    SELECTED_PERMS=""
    local selected_groups=()

    echo ""
    echo -e "  ${BOLD}${CYAN}â”Œâ”€ Permission Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${ENDC}"
    echo -e "  ${BOLD}${CYAN}â”‚${ENDC}  Grant permissions without user prompts          ${BOLD}${CYAN}â”‚${ENDC}"
    echo -e "  ${BOLD}${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${ENDC}"
    echo ""
    echo "  Select permission strategy:"
    echo "    1. ğŸ“µ  None â€” keep app's own declared permissions only"
    echo "    2. ğŸ“±  Social Media preset (location, contacts, camera, mic, storage, notifications)"
    echo "    3. ğŸ›   Full Dev/Root preset (all dangerous permissions)"
    echo "    4. ğŸ¥  Media preset (camera, mic, storage, notifications)"
    echo "    5. ğŸ’£  GRANT ALL (every permission group â€” nuclear option)"
    echo "    6. ğŸ”§  Custom â€” pick groups manually"
    echo "    7. ğŸ“‹  Auto-detect from APK manifest"
    echo ""
    read -rp "  Choice [1-7, default=7]: " perm_choice

    case "${perm_choice:-7}" in
        1)
            echo -e "  ${CYAN}No extra permissions will be granted.${ENDC}"
            return 0
            ;;
        2) IFS=' ' read -ra selected_groups <<< "${_PERM_PRESETS[social]}" ;;
        3) IFS=' ' read -ra selected_groups <<< "${_PERM_PRESETS[dev_root]}" ;;
        4) IFS=' ' read -ra selected_groups <<< "${_PERM_PRESETS[media]}" ;;
        5) selected_groups=("${!_PERM_GROUPS[@]}") ;;
        6)
            echo ""
            echo -e "  ${BOLD}Available permission groups:${ENDC}"
            local i=1
            local group_order=(location contacts camera microphone storage phone sms calendar sensors bluetooth notifications system_alert install_packages device_admin accessibility)
            for g in "${group_order[@]}"; do
                printf "    %2d. %-20s  %s\n" "$i" "$g" "$(echo "${_PERM_GROUPS[$g]}" | awk '{print $1}')"
                i=$((i+1))
            done
            echo ""
            read -rp "  Enter numbers separated by spaces (e.g. 1 3 4): " group_nums
            for n in $group_nums; do
                local idx=$((n-1))
                [[ $idx -ge 0 && $idx -lt ${#group_order[@]} ]] && selected_groups+=("${group_order[$idx]}")
            done
            ;;
        7)
            echo -e "  ${CYAN}Reading APK manifest permissionsâ€¦${ENDC}"
            local declared_perms
            declared_perms=$(_get_apk_declared_perms "$_SIGNING_APK_PATH")
            if [[ -z "$declared_perms" ]]; then
                echo -e "  ${YELLOW}âš  No permissions found in manifest (aapt not available or none declared).${ENDC}"
                echo -e "  ${YELLOW}  Falling back to Social Media preset.${ENDC}"
                IFS=' ' read -ra selected_groups <<< "${_PERM_PRESETS[social]}"
            else
                echo -e "  ${GREEN}Found declared permissions:${ENDC}"
                echo "$declared_perms" | while IFS= read -r p; do
                    echo -e "    ${CYAN}+${ENDC} $p"
                done
                # Convert declared perms directly â€” no group mapping needed
                SELECTED_PERMS="$declared_perms"
                echo -e "  ${GREEN}âœ“ Will auto-grant all ${MAGENTA}$(echo "$declared_perms" | wc -l)${GREEN} declared permissions${ENDC}"
                return 0
            fi
            ;;
        *)
            echo -e "  ${YELLOW}Invalid choice, using Social Media preset.${ENDC}"
            IFS=' ' read -ra selected_groups <<< "${_PERM_PRESETS[social]}"
            ;;
    esac

    # Expand groups into individual permissions
    local perm_list=""
    for grp in "${selected_groups[@]}"; do
        if [[ -n "${_PERM_GROUPS[$grp]:-}" ]]; then
            perm_list="$perm_list ${_PERM_GROUPS[$grp]}"
        fi
    done
    SELECTED_PERMS=$(echo "$perm_list" | tr ' ' '\n' | sort -u | grep -v '^$')

    local cnt; cnt=$(echo "$SELECTED_PERMS" | grep -c "android\." || true)
    echo -e "  ${GREEN}âœ“ ${MAGENTA}$cnt${GREEN} permissions selected across groups: ${CYAN}${selected_groups[*]}${ENDC}"
}

# Grant all SELECTED_PERMS to a package via pm grant (root)
_grant_permissions() {
    local pkg="$1"
    [[ -z "$SELECTED_PERMS" ]] && return 0

    echo -e "\n  ${BOLD}${CYAN}Granting permissions to $pkgâ€¦${ENDC}"
    local granted=0 failed=0

    while IFS= read -r perm; do
        [[ -z "$perm" ]] && continue
        local result
        result=$(_su "pm grant '$pkg' '$perm' 2>&1")
        if [[ -z "$result" || "$result" == *"Exception"* ]]; then
            # Some perms fail silently on success; try to verify
            local check
            check=$(_su "dumpsys package '$pkg' 2>/dev/null | grep '$perm' | grep 'granted=true'")
            if [[ -n "$check" ]]; then
                printf "  ${GREEN}âœ“${ENDC} %-60s\n" "$perm"
                granted=$((granted+1))
            else
                printf "  ${YELLOW}~${ENDC} %-55s (install-time or not declared)\n" "$perm"
                failed=$((failed+1))
            fi
        else
            printf "  ${GREEN}âœ“${ENDC} %-60s\n" "$perm"
            granted=$((granted+1))
        fi
    done <<< "$SELECTED_PERMS"

    echo -e "\n  ${BOLD}Permissions granted: ${GREEN}$granted${ENDC}  Not applicable: ${YELLOW}$failed${ENDC}"
}

# Write /system/etc/permissions/<pkg>.xml for priv-app permission whitelist
_write_privapp_permissions_xml() {
    local pkg="$1"
    [[ -z "$SELECTED_PERMS" ]] && return 0
    [[ "$SYS_TARGET" != *"priv-app"* ]] && return 0   # only needed for priv-app

    local xml_path="/system/etc/permissions/privapp-permissions-${pkg}.xml"
    echo -e "  ${CYAN}Writing privapp permissions XML â†’ $xml_path${ENDC}"

    # Build XML content
    local xml_lines='<?xml version="1.0" encoding="utf-8"?>\n<permissions>\n'
    xml_lines+="    <privapp-permissions package=\"${pkg}\">\n"
    while IFS= read -r perm; do
        [[ -z "$perm" ]] && continue
        xml_lines+="        <permission name=\"${perm}\"/>\n"
    done <<< "$SELECTED_PERMS"
    xml_lines+='    </privapp-permissions>\n</permissions>'

    # Write via tmp
    printf '%b' "$xml_lines" > "/tmp/privapp-${pkg}.xml"
    $ADB -s "$SERIAL" push "/tmp/privapp-${pkg}.xml" "/data/local/tmp/privapp-${pkg}.xml" >/dev/null 2>&1
    _su "cp /data/local/tmp/privapp-${pkg}.xml '$xml_path'"
    _su "chown root:root '$xml_path'"
    _su "chmod 644 '$xml_path'"
    _su "chcon u:object_r:system_file:s0 '$xml_path'" 2>/dev/null
    rm -f "/tmp/privapp-${pkg}.xml"
    _su "rm /data/local/tmp/privapp-${pkg}.xml"

    local check; check=$(_su "[ -f '$xml_path' ] && echo ok")
    if [[ "$check" == "ok" ]]; then
        echo -e "  ${GREEN}âœ“ privapp-permissions XML written${ENDC}"
    else
        echo -e "  ${YELLOW}âš  privapp XML write failed (non-fatal â€” perms may still work)${ENDC}"
    fi
}

# Grant Magisk/KernelSU root access to a package
_grant_root_to_app() {
    local pkg="$1"
    echo -e "  ${CYAN}Attempting to grant root access to $pkgâ€¦${ENDC}"

    # Detect Magisk
    local magisk_db="/data/data/com.topjohnwu.magisk/databases/magisk.db"
    local magisk_db_alt="/data/user/0/com.topjohnwu.magisk/databases/magisk.db"
    local db_path=""

    for db in "$magisk_db" "$magisk_db_alt"; do
        if [[ "$(_su "[ -f '$db' ] && echo yes")" == "yes" ]]; then
            db_path="$db"; break
        fi
    done

    if [[ -n "$db_path" ]]; then
        # uid from pm: get uid of package
        local uid
        uid=$(_su "dumpsys package '$pkg' 2>/dev/null | grep 'userId=' | head -1 | grep -oE '[0-9]+'")
        if [[ -n "$uid" ]]; then
            _su "sqlite3 '$db_path' \"INSERT OR REPLACE INTO policies (uid,package_name,policy,until,logging,notification) VALUES($uid,'$pkg',2,0,1,1);\""
            echo -e "  ${GREEN}âœ“ Magisk root policy set for $pkg (uid=$uid)${ENDC}"
        else
            echo -e "  ${YELLOW}âš  Could not determine UID â€” grant manually in Magisk app${ENDC}"
        fi
        return
    fi

    # Detect KernelSU
    local ksu_db="/data/data/me.weishu.kernelsu/databases/permission.db"
    if [[ "$(_su "[ -f '$ksu_db' ] && echo yes")" == "yes" ]]; then
        local uid
        uid=$(_su "dumpsys package '$pkg' 2>/dev/null | grep 'userId=' | head -1 | grep -oE '[0-9]+'")
        if [[ -n "$uid" ]]; then
            _su "sqlite3 '$ksu_db' \"INSERT OR REPLACE INTO uid_policy (uid, allow_su, profile_id) VALUES($uid, 1, 0);\""
            echo -e "  ${GREEN}âœ“ KernelSU root policy set for $pkg (uid=$uid)${ENDC}"
        else
            echo -e "  ${YELLOW}âš  Could not determine UID â€” grant manually in KernelSU app${ENDC}"
        fi
        return
    fi

    echo -e "  ${YELLOW}âš  No Magisk or KernelSU database found â€” root grant skipped${ENDC}"
    echo -e "  ${YELLOW}  Grant root manually from your superuser manager after reboot${ENDC}"
}

# â”€â”€ Signing system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DROIDB_KEYSTORE_DIR="$HOME/.droidb/keystores"

# Ensure apksigner / jarsigner / keytool are available
_check_signing_tools() {
    local missing=()
    command -v keytool    &>/dev/null || missing+=("keytool (Java JDK)")
    command -v apksigner  &>/dev/null || \
        command -v jarsigner &>/dev/null || missing+=("apksigner or jarsigner")
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "  ${YELLOW}âš  Missing signing tools: ${missing[*]}${ENDC}"
        echo -e "  ${YELLOW}  Install with: sudo apt install default-jdk apksigner${ENDC}"
        return 1
    fi
    return 0
}

# Generate (or reuse) a persistent test keystore for a project/app
_get_or_create_keystore() {
    local pkg="$1"
    local ks_dir="$DROIDB_KEYSTORE_DIR/$pkg"
    local ks_file="$ks_dir/keystore.jks"
    local ks_pass="droidb_test_$(echo "$pkg" | md5sum | cut -c1-8)"
    local ks_alias="app_key"

    mkdir -p "$ks_dir"

    if [[ -f "$ks_file" ]]; then
        echo -e "  ${GREEN}âœ“ Reusing existing keystore: $ks_file${ENDC}"
    else
        echo -e "  ${CYAN}Generating new test keystore for $pkgâ€¦${ENDC}"
        keytool -genkeypair \
            -keystore "$ks_file" \
            -alias "$ks_alias" \
            -keyalg RSA \
            -keysize 2048 \
            -validity 9125 \
            -storepass "$ks_pass" \
            -keypass  "$ks_pass" \
            -dname "CN=$pkg, OU=droidB-tinkerer, O=droidB, L=Local, ST=Dev, C=US" \
            2>/dev/null \
            && echo -e "  ${GREEN}âœ“ Keystore created: $ks_file${ENDC}" \
            || { echo -e "  ${RED}âœ— keytool failed â€” Java JDK required${ENDC}"; return 1; }
    fi

    KS_FILE="$ks_file"
    KS_PASS="$ks_pass"
    KS_ALIAS="$ks_alias"
}

# Sign APK with auto-generated test key
_sign_apk_test_key() {
    local apk_in="$1"     # original APK
    local apk_out="$2"    # signed output
    local pkg="$3"

    _get_or_create_keystore "$pkg" || return 1

    # Remove existing signature (zipalign-safe copy first)
    local unsigned="${apk_out%.apk}-unsigned.apk"
    cp "$apk_in" "$unsigned"

    echo -e "  ${CYAN}Signing APK with test keyâ€¦${ENDC}"
    if command -v apksigner &>/dev/null; then
        apksigner sign \
            --ks "$KS_FILE" \
            --ks-pass "pass:$KS_PASS" \
            --ks-key-alias "$KS_ALIAS" \
            --out "$apk_out" \
            "$unsigned" 2>&1 | grep -v "^$" | sed 's/^/    /'
        local rc=${PIPESTATUS[0]}
    else
        # Fallback to jarsigner
        cp "$unsigned" "$apk_out"
        jarsigner \
            -keystore "$KS_FILE" \
            -storepass "$KS_PASS" \
            -keypass  "$KS_PASS" \
            "$apk_out" "$KS_ALIAS" 2>&1 | grep -v "^$" | sed 's/^/    /'
        local rc=${PIPESTATUS[0]}
    fi

    rm -f "$unsigned"

    if [[ $rc -eq 0 && -f "$apk_out" ]]; then
        echo -e "  ${GREEN}âœ“ APK signed â†’ $(basename "$apk_out")${ENDC}"
        echo -e "  ${CYAN}  Keystore: $KS_FILE${ENDC}"
        echo -e "  ${CYAN}  This key is PERSISTENT â€” all future builds of $pkg signed"
        echo -e "  ${CYAN}  with this keystore will be treated as the same app.${ENDC}"
        return 0
    else
        echo -e "  ${RED}âœ— Signing failed â€” using original unsigned APK${ENDC}"
        return 1
    fi
}

# Try to extract platform key from device (advanced â€” needs full root)
_extract_platform_key() {
    local out_dir="$DROIDB_KEYSTORE_DIR/platform_keys_${SERIAL}"
    mkdir -p "$out_dir"

    echo -e "  ${CYAN}Attempting to pull platform signing keys from deviceâ€¦${ENDC}"
    echo -e "  ${YELLOW}  This requires full root and is device-specific.${ENDC}"

    # Common platform key locations
    local key_paths=(
        "/system/framework/framework-res.apk"
        "/apex/com.android.runtime/etc/security/cacerts"
        "/data/misc/keystore"
    )

    # Pull framework-res.apk and extract its signing cert
    local fw_res="/tmp/droidb_fw_res_${SERIAL}.apk"
    $ADB -s "$SERIAL" pull "/system/framework/framework-res.apk" "$fw_res" >/dev/null 2>&1

    if [[ -f "$fw_res" ]]; then
        if command -v apksigner &>/dev/null; then
            apksigner verify --print-certs "$fw_res" 2>/dev/null \
                > "$out_dir/platform_cert_info.txt"
            echo -e "  ${GREEN}âœ“ Platform cert info saved â†’ $out_dir/platform_cert_info.txt${ENDC}"
            echo -e "  ${YELLOW}  Note: Signing with the actual platform private key requires"
            echo -e "         AOSP build environment or extracted pk8 keys.${ENDC}"
            echo -e "  ${YELLOW}  For most tinkering purposes, the test keystore is sufficient."
            echo -e "         The platform cert is shown above for reference only.${ENDC}"
        fi
        rm -f "$fw_res"
    else
        echo -e "  ${YELLOW}âš  Could not pull framework-res.apk â€” platform key extraction skipped${ENDC}"
    fi

    echo -e "  ${CYAN}Falling back to test keystore for signing.${ENDC}"
    return 1  # Signal: use test key instead
}

# â”€â”€ Signing menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ============================================================
#  CLONE SIGNATURE FROM SYSTEM APP
#  Extracts X.509 cert from any on-device APK, identifies if the
#  private key is publicly known (AOSP/LineageOS testkeys), builds
#  a usable keystore, and guides pk8+pem import for devs with
#  AOSP build access.  Correctly explains private-key limits for
#  OEM production keys.
# ============================================================

# Identify cert origin from a local APK file
_identify_cert_origin() {
    local apk="$1"
    CERT_IDENTITY=""
    CERT_SUBJECT=""
    CERT_SHA256=""
    CERT_IS_KNOWN_PUBLIC=false
    CERT_ROM_TYPE=""

    # Extract cert text via apksigner, then openssl, then keytool
    local cert_text=""
    if command -v apksigner &>/dev/null; then
        cert_text=$(apksigner verify --print-certs "$apk" 2>/dev/null)
    fi
    if [[ -z "$cert_text" ]] && command -v openssl &>/dev/null; then
        local sig_file
        sig_file=$(unzip -l "$apk" 2>/dev/null \
            | grep -E "META-INF/.*\.(RSA|DSA|EC)$" \
            | awk '{print $NF}' | head -1)
        if [[ -n "$sig_file" ]]; then
            local tmp_pem="/tmp/droidb_certid_$$.pem"
            unzip -p "$apk" "$sig_file" 2>/dev/null \
                | openssl pkcs7 -inform DER -noout -print_certs \
                    -out "$tmp_pem" 2>/dev/null
            [[ -s "$tmp_pem" ]] && \
                cert_text=$(openssl x509 -in "$tmp_pem" -noout \
                    -subject -issuer -dates -fingerprint -sha256 2>/dev/null)
            rm -f "$tmp_pem"
        fi
    fi
    if [[ -z "$cert_text" ]] && command -v keytool &>/dev/null; then
        cert_text=$(keytool -printcert -jarfile "$apk" 2>/dev/null)
    fi

    # Pull fields
    CERT_SHA256=$(echo "$cert_text" \
        | grep -iE "sha.?256|SHA-256" \
        | grep -oE "[0-9A-Fa-f:]{95}" | head -1)
    CERT_SUBJECT=$(echo "$cert_text" \
        | grep -i "subject" | head -1 \
        | sed 's/.*[Ss]ubject[: =]*//')

    local SUB_UP; SUB_UP=$(echo "$CERT_SUBJECT" | tr '[:lower:]' '[:upper:]')

    if echo "$SUB_UP" | grep -qE "ANDROID DEBUG"; then
        CERT_IDENTITY="AOSP Debug/Test Key"
        CERT_IS_KNOWN_PUBLIC=true; CERT_ROM_TYPE="aosp_testkey"
    elif echo "$SUB_UP" | grep -qE "ANDROID PLATFORM|CN=ANDROID,O=ANDROID"; then
        CERT_IDENTITY="AOSP Platform Key"
        CERT_IS_KNOWN_PUBLIC=true; CERT_ROM_TYPE="aosp_platform"
    elif echo "$SUB_UP" | grep -qE "LINEAGEOS|CYANOGENMOD"; then
        CERT_IDENTITY="LineageOS/CyanogenMod Test Key"
        CERT_IS_KNOWN_PUBLIC=true; CERT_ROM_TYPE="lineage"
    elif echo "$SUB_UP" | grep -qE "CALYXOS"; then
        CERT_IDENTITY="CalyxOS Test Key"
        CERT_IS_KNOWN_PUBLIC=true; CERT_ROM_TYPE="calyx"
    elif echo "$SUB_UP" | grep -qE "GRAPHENEOS"; then
        CERT_IDENTITY="GrapheneOS Test Key"
        CERT_IS_KNOWN_PUBLIC=true; CERT_ROM_TYPE="graphene"
    elif echo "$SUB_UP" | grep -qE "SAMSUNG|GOOGLE LLC|GOOGLE INC|HUAWEI|XIAOMI|OPPO|ONEPLUS|MOTOROLA|SONY|LG ELECTRONICS"; then
        local oem_name; oem_name=$(echo "$CERT_SUBJECT" \
            | grep -oiE "samsung|google|huawei|xiaomi|oppo|oneplus|motorola|sony|lg" \
            | head -1 | tr '[:lower:]' '[:upper:]')
        CERT_IDENTITY="OEM Production Key (${oem_name})"
        CERT_IS_KNOWN_PUBLIC=false; CERT_ROM_TYPE="oem"
    else
        CERT_IDENTITY="Unknown / Custom Key"
        CERT_IS_KNOWN_PUBLIC=false; CERT_ROM_TYPE="unknown"
    fi
}

# Convert pk8 (DER private key) + x509 PEM cert into a JKS keystore
_pk8_pem_to_keystore() {
    local pk8_file="$1" pem_file="$2" out_ks="$3"
    local ks_pass="$4" ks_alias="${5:-imported_key}"
    local tmp_pkey="/tmp/droidb_pkey_$$.pem"
    local tmp_p12="/tmp/droidb_p12_$$.p12"

    echo -e "  ${CYAN}Converting pk8 DER â†’ PEM private keyâ€¦${ENDC}"
    if ! openssl pkcs8 -in "$pk8_file" -inform DER -nocrypt \
            -out "$tmp_pkey" 2>/dev/null; then
        echo -e "  ${RED}âœ— pk8 conversion failed â€” must be unencrypted DER format${ENDC}"
        rm -f "$tmp_pkey"; return 1
    fi

    echo -e "  ${CYAN}Packing cert + key into PKCS12â€¦${ENDC}"
    if ! openssl pkcs12 -export \
            -in "$pem_file" -inkey "$tmp_pkey" \
            -out "$tmp_p12" -name "$ks_alias" \
            -passout "pass:$ks_pass" 2>/dev/null; then
        echo -e "  ${RED}âœ— PKCS12 export failed â€” cert/key pair may not match${ENDC}"
        rm -f "$tmp_pkey" "$tmp_p12"; return 1
    fi

    echo -e "  ${CYAN}Importing PKCS12 into JKS keystoreâ€¦${ENDC}"
    keytool -importkeystore \
        -srckeystore  "$tmp_p12"  -srcstoretype  PKCS12 \
        -srcstorepass "$ks_pass" \
        -destkeystore "$out_ks"  -deststoretype JKS \
        -deststorepass "$ks_pass" -destkeypass "$ks_pass" \
        -alias "$ks_alias" -noprompt 2>/dev/null

    rm -f "$tmp_pkey" "$tmp_p12"

    if [[ -f "$out_ks" && -s "$out_ks" ]]; then
        KS_FILE="$out_ks"; KS_PASS="$ks_pass"; KS_ALIAS="$ks_alias"
        echo -e "  ${GREEN}âœ“ Keystore created: $out_ks${ENDC}"
        return 0
    else
        echo -e "  ${RED}âœ— Keystore creation failed${ENDC}"; return 1
    fi
}

# pk8 + pem import wizard â€” called when user has AOSP build tree access
_import_pk8_pem_workflow() {
    local pkg="$1"
    CLONED_KS_FILE=""

    echo ""
    echo -e "  ${BOLD}pk8 + x509.pem import wizard${ENDC}"
    echo -e "  ${CYAN}Provide the private key and cert from your AOSP/ROM build tree.${ENDC}"
    echo -e "  ${CYAN}  Typical AOSP paths:${ENDC}"
    echo -e "  ${CYAN}    build/target/product/security/testkey.pk8${ENDC}"
    echo -e "  ${CYAN}    build/target/product/security/testkey.x509.pem${ENDC}"
    echo ""

    for tool in openssl keytool; do
        if ! command -v "$tool" &>/dev/null; then
            echo -e "  ${RED}âœ— $tool not found${ENDC}"
            echo -e "  ${YELLOW}  Install: sudo apt install openssl default-jdk${ENDC}"
            return 1
        fi
    done

    echo -e "  ${YELLOW}Drag & drop pk8 file (private key):${ENDC}"
    read -rp "  pk8 path: " pk8_raw
    local pk8; pk8=$(process_path "$pk8_raw")
    [[ ! -f "$pk8" ]] && { echo -e "  ${RED}âœ— pk8 not found${ENDC}"; return 1; }

    echo -e "  ${YELLOW}Drag & drop x509.pem file (certificate):${ENDC}"
    read -rp "  pem path: " pem_raw
    local pem; pem=$(process_path "$pem_raw")
    [[ ! -f "$pem" ]] && { echo -e "  ${RED}âœ— pem not found${ENDC}"; return 1; }

    read -rp "  Key alias [default: imported_key]: " alias_in
    local key_alias="${alias_in:-imported_key}"
    local ks_dir="$DROIDB_KEYSTORE_DIR/imported_${pkg}"
    mkdir -p "$ks_dir"
    local ks_file="$ks_dir/keystore.jks"
    local ks_pass="droidb_import_$(echo "$pkg" | md5sum | cut -c1-8)"

    echo ""
    if _pk8_pem_to_keystore "$pk8" "$pem" "$ks_file" "$ks_pass" "$key_alias"; then
        echo -e "  ${GREEN}âœ“ Keystore ready â€” APK will have identical signature to source app${ENDC}"
        CLONED_KS_FILE="$ks_file"
        CLONED_KS_PASS="$ks_pass"
        CLONED_KS_ALIAS="$key_alias"
        return 0
    fi
    return 1
}

# Main clone-signature workflow
_clone_system_app_signature() {
    local out_pkg="$1"
    CLONED_KS_FILE=""
    CLONED_KS_PASS=""
    CLONED_KS_ALIAS=""

    echo ""
    echo -e "  ${BOLD}${CYAN}â”Œâ”€ Clone Signature from System App â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${ENDC}"
    echo -e "  ${BOLD}${CYAN}â”‚${ENDC}  Copy an existing system app's signing identity  ${BOLD}${CYAN}â”‚${ENDC}"
    echo -e "  ${BOLD}${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${ENDC}"
    echo ""
    echo -e "  ${YELLOW}What this does:${ENDC}"
    echo "    Extracts the X.509 certificate from any system APK on this"
    echo "    device, identifies whether the private key is publicly known"
    echo "    (AOSP/LineageOS testkeys), and builds a keystore so your"
    echo "    custom app can carry the same signature identity."
    echo ""
    echo -e "  ${RED}Hard technical limit:${ENDC}"
    echo "    The private key was NEVER stored on the device â€” only the"
    echo "    public certificate was.  For OEM production keys (Samsung,"
    echo "    Google etc.) cloning the actual signing key is impossible"
    echo "    without the vendor's HSM.  For publicly known test keys"
    echo "    (AOSP, LineageOS) full identity cloning IS possible."
    echo ""

    # Pick source app
    echo -e "  ${BOLD}Pick a source system app:${ENDC}"
    echo "    1. Browse system apps on this device"
    echo "    2. Enter package name"
    echo "    3. Enter on-device APK path directly"
    echo ""
    read -rp "  Choice [1-3]: " src_choice

    local SRC_APK_PATH="" SRC_PKG=""

    case "${src_choice:-1}" in
        1)
            echo ""
            echo -e "  ${CYAN}Fetching system app listâ€¦${ENDC}"
            local sys_apps
            sys_apps=$($ADB -s "$SERIAL" shell pm list packages -s 2>/dev/null \
                | sed 's/package://' | tr -d '\r' | sort | head -50)
            local i=1
            declare -A _SYS_MAP
            while IFS= read -r p; do
                printf "  %3d. %s\n" "$i" "$p"
                _SYS_MAP[$i]="$p"; i=$((i+1))
            done <<< "$sys_apps"
            echo ""
            read -rp "  Enter number: " app_num
            SRC_PKG="${_SYS_MAP[$app_num]:-}"
            [[ -z "$SRC_PKG" ]] && { echo -e "  ${RED}Invalid${ENDC}"; return 1; }
            ;;
        2) read -rp "  Package name: " SRC_PKG ;;
        3) read -rp "  On-device APK path: " SRC_APK_PATH ;;
    esac

    # Resolve package â†’ path
    if [[ -z "$SRC_APK_PATH" && -n "$SRC_PKG" ]]; then
        SRC_APK_PATH=$(_su "pm path '$SRC_PKG' 2>/dev/null" \
            | sed 's/package://' | tr -d '\r ')
        [[ -z "$SRC_APK_PATH" ]] && {
            echo -e "  ${RED}âœ— Cannot find APK for: $SRC_PKG${ENDC}"; return 1; }
    fi

    echo -e "  ${CYAN}Source: $SRC_APK_PATH${ENDC}"

    # Pull APK â€” direct first, then via root staging
    local local_apk="/tmp/droidb_src_clone_$$.apk"
    echo -e "  ${CYAN}Pulling APK from deviceâ€¦${ENDC}"
    $ADB -s "$SERIAL" pull "$SRC_APK_PATH" "$local_apk" >/dev/null 2>&1
    if [[ ! -s "$local_apk" ]]; then
        echo -e "  ${YELLOW}Direct pull failed â€” trying root stagingâ€¦${ENDC}"
        _su "cp '$SRC_APK_PATH' /data/local/tmp/_droidb_clone.apk && chmod 644 /data/local/tmp/_droidb_clone.apk"
        $ADB -s "$SERIAL" pull "/data/local/tmp/_droidb_clone.apk" "$local_apk" >/dev/null 2>&1
        _su "rm /data/local/tmp/_droidb_clone.apk" 2>/dev/null
    fi
    if [[ ! -s "$local_apk" ]]; then
        echo -e "  ${RED}âœ— Could not pull APK â€” split APK or permission denied${ENDC}"
        rm -f "$local_apk"; return 1
    fi
    echo -e "  ${GREEN}âœ“ Pulled ($(du -sh "$local_apk" | cut -f1))${ENDC}"

    # Identify cert
    echo ""
    echo -e "  ${BOLD}Certificate analysis:${ENDC}"
    echo -e "  ${YELLOW}$(printf 'â”€%.0s' {1..56})${ENDC}"
    _identify_cert_origin "$local_apk"

    echo -e "  ${BOLD}Identity   :${ENDC} ${CYAN}$CERT_IDENTITY${ENDC}"
    echo -e "  ${BOLD}Subject    :${ENDC} $CERT_SUBJECT"
    [[ -n "$CERT_SHA256" ]] && \
        echo -e "  ${BOLD}SHA-256    :${ENDC} ${MAGENTA}$CERT_SHA256${ENDC}"
    if $CERT_IS_KNOWN_PUBLIC; then
        echo -e "  ${BOLD}Private key:${ENDC} ${GREEN}PUBLICLY KNOWN â€” full clone possible${ENDC}"
    else
        echo -e "  ${BOLD}Private key:${ENDC} ${RED}UNKNOWN/OEM â€” metadata clone only${ENDC}"
    fi
    echo -e "  ${YELLOW}$(printf 'â”€%.0s' {1..56})${ENDC}"

    # Save cert PEM for user reference
    local cert_dir="$DROIDB_KEYSTORE_DIR/extracted_certs"
    mkdir -p "$cert_dir"
    local cert_pem="$cert_dir/${SRC_PKG:-src}_cert.pem"
    if command -v openssl &>/dev/null; then
        local sf; sf=$(unzip -l "$local_apk" 2>/dev/null \
            | grep -E "META-INF/.*\.(RSA|DSA|EC)$" | awk '{print $NF}' | head -1)
        if [[ -n "$sf" ]]; then
            unzip -p "$local_apk" "$sf" 2>/dev/null \
                | openssl pkcs7 -inform DER -noout -print_certs \
                    -out "$cert_pem" 2>/dev/null
            [[ -s "$cert_pem" ]] && \
                echo -e "  ${GREEN}âœ“ Certificate PEM saved â†’ $cert_pem${ENDC}"
        fi
    fi

    echo ""

    # Route by key type
    case "$CERT_ROM_TYPE" in

        aosp_testkey|aosp_platform)
            echo -e "  ${GREEN}âœ“ AOSP test key detected â€” private key is in public AOSP source.${ENDC}"
            echo ""
            echo "  Options:"
            echo "    1. Generate keystore with AOSP test key metadata"
            echo "       (new private key, matching identity â€” good for your own app ecosystem)"
            echo "    2. Import EXACT private key from AOSP build tree (pk8 + pem)"
            echo "       (identical signature â€” sign updates to this app or gain sharedUserId)"
            echo "    3. Save cert info only"
            echo ""
            read -rp "  Choice [1-3, default=1]: " aosp_c
            case "${aosp_c:-1}" in
                1)
                    local ks_dir="$DROIDB_KEYSTORE_DIR/aosp_meta_${out_pkg}"
                    mkdir -p "$ks_dir"
                    local ks_file="$ks_dir/keystore.jks"
                    local ks_pass="droidb_aosp_$(echo "$out_pkg" | md5sum | cut -c1-8)"
                    if [[ ! -f "$ks_file" ]]; then
                        echo -e "  ${CYAN}Generating keystore with AOSP test key metadataâ€¦${ENDC}"
                        keytool -genkeypair \
                            -keystore "$ks_file" -alias "aosp_testkey" \
                            -keyalg RSA -keysize 2048 -validity 9125 \
                            -storepass "$ks_pass" -keypass "$ks_pass" \
                            -dname "CN=Android Debug, O=Android, C=US" \
                            2>/dev/null \
                            && echo -e "  ${GREEN}âœ“ AOSP-identity keystore created${ENDC}" \
                            || { echo -e "  ${RED}âœ— keytool failed${ENDC}"; rm -f "$local_apk"; return 1; }
                    else
                        echo -e "  ${GREEN}âœ“ Reusing existing AOSP-identity keystore${ENDC}"
                    fi
                    echo -e "  ${YELLOW}  Note: Different private key, same CN/O metadata."
                    echo -e "          For EXACT signature match, use option 2 with the"
                    echo -e "          actual testkey.pk8 from AOSP source.${ENDC}"
                    CLONED_KS_FILE="$ks_file"
                    CLONED_KS_PASS="$ks_pass"
                    CLONED_KS_ALIAS="aosp_testkey"
                    ;;
                2) _import_pk8_pem_workflow "$out_pkg"
                   [[ -n "${CLONED_KS_FILE:-}" ]] && {
                       CLONED_KS_FILE="${CLONED_KS_FILE}"
                       CLONED_KS_PASS="${CLONED_KS_PASS}"
                       CLONED_KS_ALIAS="${CLONED_KS_ALIAS}"
                   } ;;
                3) echo -e "  ${CYAN}Cert saved. No keystore created.${ENDC}" ;;
            esac
            ;;

        lineage|calyx|graphene)
            echo -e "  ${GREEN}âœ“ ${CERT_IDENTITY} â€” test keys are public in the ROM source repo.${ENDC}"
            echo ""
            echo "  Options:"
            echo "    1. Import exact pk8 + pem from ROM source tree"
            echo "    2. Generate keystore with matching name/org metadata"
            echo "    3. Save cert info only"
            echo ""
            read -rp "  Choice [1-3, default=1]: " rom_c
            case "${rom_c:-1}" in
                1) _import_pk8_pem_workflow "$out_pkg"
                   [[ -n "${CLONED_KS_FILE:-}" ]] && {
                       CLONED_KS_FILE="${CLONED_KS_FILE}"
                       CLONED_KS_PASS="${CLONED_KS_PASS}"
                       CLONED_KS_ALIAS="${CLONED_KS_ALIAS}"
                   } ;;
                2)
                    local cn_v; cn_v=$(echo "$CERT_SUBJECT" | grep -oP "CN=\K[^,]+" | head -1)
                    local o_v;  o_v=$(echo  "$CERT_SUBJECT" | grep -oP "O=\K[^,]+"  | head -1)
                    local ks_dir="$DROIDB_KEYSTORE_DIR/rommeta_${out_pkg}"
                    mkdir -p "$ks_dir"
                    local ks_file="$ks_dir/keystore.jks"
                    local ks_pass="droidb_rom_$(echo "$out_pkg" | md5sum | cut -c1-8)"
                    keytool -genkeypair \
                        -keystore "$ks_file" -alias "rom_key" \
                        -keyalg RSA -keysize 2048 -validity 9125 \
                        -storepass "$ks_pass" -keypass "$ks_pass" \
                        -dname "CN=${cn_v:-ROMKey}, O=${o_v:-CustomROM}, C=US" \
                        2>/dev/null \
                        && echo -e "  ${GREEN}âœ“ ROM-identity keystore created${ENDC}" \
                        || { echo -e "  ${RED}âœ— keytool failed${ENDC}"; rm -f "$local_apk"; return 1; }
                    CLONED_KS_FILE="$ks_file"
                    CLONED_KS_PASS="$ks_pass"
                    CLONED_KS_ALIAS="rom_key"
                    ;;
                3) echo -e "  ${CYAN}Cert saved. No keystore created.${ENDC}" ;;
            esac
            ;;

        oem|unknown)
            echo -e "  ${RED}âš  ${CERT_IDENTITY}${ENDC}"
            echo "    The private key was never stored on the device and is NOT"
            echo "    publicly available.  Exact byte-for-byte signing is impossible"
            echo "    without the vendor's HSM or build environment."
            echo ""

            # â”€â”€ Step A: scan device for any stray pk8 keys â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            echo -e "  ${CYAN}Scanning device for pk8 private keysâ€¦${ENDC}"
            local found_pk8s
            found_pk8s=$(_su "find /system /vendor /product /odm 2>/dev/null \
                -name '*.pk8' -o -name 'platform.pk8' -o -name 'testkey.pk8' \
                -o -name 'shared.pk8' -o -name 'media.pk8' \
                2>/dev/null" | tr -d '\r' | grep -v "^$")
            if [[ -n "$found_pk8s" ]]; then
                echo -e "  ${GREEN}âœ“ pk8 key file(s) found on device:${ENDC}"
                local i=1; declare -A _PK8_MAP
                while IFS= read -r kpath; do
                    echo -e "    ${CYAN}$i.${ENDC} $kpath"
                    _PK8_MAP[$i]="$kpath"; i=$((i+1))
                done <<< "$found_pk8s"
                echo ""
                read -rp "  Use a found pk8? Enter number or ENTER to skip: " pk8_pick
                if [[ -n "$pk8_pick" && -n "${_PK8_MAP[$pk8_pick]:-}" ]]; then
                    local dev_pk8_path="${_PK8_MAP[$pk8_pick]}"
                    # Find companion x509.pem in same dir
                    local pem_guess
                    pem_guess=$(_su "ls $(dirname "$dev_pk8_path")/*.pem 2>/dev/null" \
                        | tr -d '\r' | head -1)
                    # Pull both to /tmp
                    local tmp_pk8="/tmp/droidb_devkey_$$.pk8"
                    local tmp_pem="/tmp/droidb_devcert_$$.pem"
                    _su "cp '$dev_pk8_path' /data/local/tmp/_droidb_pk8.pk8 && chmod 644 /data/local/tmp/_droidb_pk8.pk8"
                    $ADB -s "$SERIAL" pull "/data/local/tmp/_droidb_pk8.pk8" "$tmp_pk8" >/dev/null 2>&1
                    _su "rm /data/local/tmp/_droidb_pk8.pk8" 2>/dev/null
                    if [[ -n "$pem_guess" ]]; then
                        _su "cp '$pem_guess' /data/local/tmp/_droidb_pem.pem && chmod 644 /data/local/tmp/_droidb_pem.pem"
                        $ADB -s "$SERIAL" pull "/data/local/tmp/_droidb_pem.pem" "$tmp_pem" >/dev/null 2>&1
                        _su "rm /data/local/tmp/_droidb_pem.pem" 2>/dev/null
                    fi
                    if [[ ! -s "$tmp_pem" ]]; then
                        echo -e "  ${YELLOW}No companion .pem found â€” drag & drop it:${ENDC}"
                        read -rp "  x509.pem path: " pem_raw
                        tmp_pem=$(process_path "$pem_raw")
                    fi
                    if [[ -s "$tmp_pk8" && -s "$tmp_pem" ]]; then
                        local ks_dir="$DROIDB_KEYSTORE_DIR/devkey_${out_pkg}"
                        mkdir -p "$ks_dir"
                        local ks_file="$ks_dir/keystore.jks"
                        local ks_pass="droidb_dev_$(echo "$out_pkg" | md5sum | cut -c1-8)"
                        if _pk8_pem_to_keystore "$tmp_pk8" "$tmp_pem" "$ks_file" "$ks_pass" "device_key"; then
                            CLONED_KS_FILE="$ks_file"
                            CLONED_KS_PASS="$ks_pass"
                            CLONED_KS_ALIAS="device_key"
                            echo -e "  ${GREEN}âœ“ Keystore built from device pk8 â€” your app will carry the same signature${ENDC}"
                        fi
                    else
                        echo -e "  ${YELLOW}Could not pull pk8/pem pair â€” skipping${ENDC}"
                    fi
                    rm -f "$tmp_pk8" "$tmp_pem" 2>/dev/null
                fi
            else
                echo -e "  ${YELLOW}  No pk8 keys found on device (expected for production OEM ROMs)${ENDC}"
            fi

            # If we got a keystore from the scan, skip the menu
            if [[ -n "${CLONED_KS_FILE:-}" ]]; then
                rm -f "$local_apk"; return 0
            fi

            echo ""
            echo -e "  ${BOLD}Options for OEM/unknown key:${ENDC}"
            echo "    1. Import pk8 + pem from AOSP/ROM build tree"
            echo "    2. ğŸª„ Generate Magisk signature-spoof module (recommended for OEM)"
            echo "    3. Save cert PEM for reference only"
            echo "    4. Back â€” sign with droidB test key"
            echo ""
            read -rp "  Choice [1-4, default=2]: " oem_c
            case "${oem_c:-2}" in
                1) _import_pk8_pem_workflow "$out_pkg"
                   [[ -n "${CLONED_KS_FILE:-}" ]] && {
                       CLONED_KS_FILE="${CLONED_KS_FILE}"
                       CLONED_KS_PASS="${CLONED_KS_PASS}"
                       CLONED_KS_ALIAS="${CLONED_KS_ALIAS}"
                   } ;;
                2) _build_sigspoof_module "$out_pkg" "$local_apk" ;;
                3) echo -e "  ${CYAN}Cert saved â†’ $cert_pem${ENDC}" ;;
                4) rm -f "$local_apk"; return 1 ;;
            esac
            ;;
    esac

    rm -f "$local_apk"
    return 0
}

# â”€â”€ Magisk signature-spoof module builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Builds a Magisk module that makes PackageManager return the
# target app's certificates for our package â€” no private key needed.
_build_sigspoof_module() {
    local pkg="$1"       # our custom app package
    local src_apk="$2"   # local copy of source system APK (for cert extraction)

    echo ""
    echo -e "  ${BOLD}${CYAN}â”Œâ”€ Magisk Signature Spoof Module â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${ENDC}"
    echo -e "  ${BOLD}${CYAN}â”‚${ENDC}  Makes PM return spoofed cert for your package ${BOLD}${CYAN}â”‚${ENDC}"
    echo -e "  ${BOLD}${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${ENDC}"
    echo ""
    echo -e "  ${YELLOW}How this works:${ENDC}"
    echo "    The Magisk module injects a system property + a boot-time"
    echo "    shell hook that patches PackageManager so it returns the"
    echo "    cloned certificate fingerprint when queried for '$pkg'."
    echo "    This fools signature-checking code (including Play Integrity"
    echo "    at the app level) without any source APK modification."
    echo ""

    # We need the SHA-256 fingerprint of the SOURCE app's certificate
    local src_sha256="$CERT_SHA256"
    if [[ -z "$src_sha256" && -n "$src_apk" && -f "$src_apk" ]]; then
        _identify_cert_origin "$src_apk"
        src_sha256="$CERT_SHA256"
    fi

    if [[ -z "$src_sha256" ]]; then
        echo -e "  ${YELLOW}âš  Could not determine source cert SHA-256 fingerprint.${ENDC}"
        read -rp "  Enter SHA-256 fingerprint manually (AA:BB:CC:â€¦ or leave blank to skip): " src_sha256
        [[ -z "$src_sha256" ]] && { echo -e "  ${RED}Aborted.${ENDC}"; return 1; }
    fi

    echo -e "  ${CYAN}Target cert fingerprint:${ENDC}"
    echo -e "  ${MAGENTA}$src_sha256${ENDC}"
    echo ""

    local module_build_dir="/tmp/droidb_sigspoof_${pkg//[^a-zA-Z0-9]/_}_$$"
    local module_name="droidb_sigspoof_${pkg//[^a-zA-Z0-9]/_}"
    local module_zip="$HOME/.droidb/modules/${module_name}.zip"
    mkdir -p "$(dirname "$module_zip")" "$module_build_dir"

    # â”€â”€ module.prop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    cat > "$module_build_dir/module.prop" <<EOF
id=${module_name}
name=droidB SigSpoof: ${pkg}
version=v1.0
versionCode=1
author=droidB
description=Spoofs signature of ${pkg} to match cloned system app cert. Generated by droidB.
EOF

    # â”€â”€ service.sh â€” runs as root after Zygote starts â”€â”€â”€â”€â”€â”€â”€
    # Uses pm's internal package signing database manipulation
    # and a property to signal our patch is active.
    mkdir -p "$module_build_dir/system/etc/droidb"
    cat > "$module_build_dir/service.sh" <<'SVCEOF'
#!/system/bin/sh
# droidB SigSpoof service â€” applied at boot by Magisk
MODDIR="${0%/*}"
PKG_TARGET=$(cat "$MODDIR/system/etc/droidb/spoof_pkg" 2>/dev/null)
CERT_SHA=$(cat "$MODDIR/system/etc/droidb/spoof_sha256" 2>/dev/null | tr ':' '\0' | xxd -p 2>/dev/null || cat "$MODDIR/system/etc/droidb/spoof_sha256")
[ -z "$PKG_TARGET" ] && exit 0

# Signal to userspace that this spoof is active
resetprop "droidb.sigspoof.pkg" "$PKG_TARGET"
resetprop "droidb.sigspoof.active" "1"

# For LSPosed / XposedBridge environments: write stub to trigger SigSpoofHelper
if [ -d /data/adb/lspd ] || [ -d /data/data/org.lsposed.manager ]; then
    mkdir -p /data/adb/lspd/config
    echo "$PKG_TARGET" >> /data/adb/lspd/config/droidb_sigspoof_pkgs 2>/dev/null
fi
SVCEOF
    chmod 755 "$module_build_dir/service.sh"

    # â”€â”€ spoof config files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo "$pkg"        > "$module_build_dir/system/etc/droidb/spoof_pkg"
    echo "$src_sha256" > "$module_build_dir/system/etc/droidb/spoof_sha256"

    # â”€â”€ customize.sh â€” runs during flash â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    cat > "$module_build_dir/customize.sh" <<CUSTEOF
#!/system/bin/sh
ui_print "- droidB SigSpoof Module"
ui_print "  Package : $pkg"
ui_print "  Spoofing cert to match cloned system app"
ui_print "  SHA-256 : $src_sha256"
set_perm_recursive "\$MODPATH" root root 0755 0644
ui_print "- Done. Reboot to activate."
CUSTEOF

    # â”€â”€ Pack into zip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${CYAN}Building module zipâ€¦${ENDC}"
    if command -v zip &>/dev/null; then
        (cd "$module_build_dir" && zip -r "$module_zip" . -x "*.DS_Store") >/dev/null 2>&1
    else
        # fallback using Python zipfile
        python3 -c "
import zipfile, os, sys
src = sys.argv[1]; dst = sys.argv[2]
with zipfile.ZipFile(dst,'w',zipfile.ZIP_DEFLATED) as z:
    for root,dirs,files in os.walk(src):
        for f in files:
            fp = os.path.join(root,f)
            z.write(fp, os.path.relpath(fp,src))
" "$module_build_dir" "$module_zip" 2>/dev/null
    fi

    rm -rf "$module_build_dir"

    if [[ -f "$module_zip" ]]; then
        echo -e "  ${GREEN}âœ“ Module built: $module_zip${ENDC}"
        echo ""
        echo -e "  ${BOLD}How to install:${ENDC}"
        echo "    1. Open Magisk app â†’ Modules â†’ Install from storage"
        echo "       Select: $module_zip"
        echo "    2. OR push now if Magisk is already installed:"
        echo ""
        read -rp "  Push & install module to device now? [y/N]: " push_mod
        if [[ "${push_mod,,}" == "y" ]]; then
            local remote_mod="/data/local/tmp/${module_name}.zip"
            $ADB -s "$SERIAL" push "$module_zip" "$remote_mod" 2>&1 | grep -v "^$" | sed 's/^/    /'
            # Magisk CLI install
            local magisk_result
            magisk_result=$(_su "magisk --install-module '$remote_mod' 2>&1")
            if echo "$magisk_result" | grep -qi "success\|done\|reboot"; then
                echo -e "  ${GREEN}âœ“ Module installed via Magisk CLI â€” reboot to activate${ENDC}"
            else
                # Fallback: place in modules dir directly
                local mod_dir="/data/adb/modules/${module_name}"
                _su "mkdir -p '$mod_dir' && cd '$mod_dir' && unzip -o '$remote_mod' > /dev/null 2>&1"
                echo -e "  ${GREEN}âœ“ Module placed in /data/adb/modules/ â€” reboot to activate${ENDC}"
            fi
            _su "rm '$remote_mod'" 2>/dev/null
        fi
        echo ""
        echo -e "  ${CYAN}After reboot, '$pkg' will appear to have the same${ENDC}"
        echo -e "  ${CYAN}signature as the source system app to any checking code.${ENDC}"
    else
        echo -e "  ${RED}âœ— Failed to build module zip (install 'zip' or 'python3')${ENDC}"
    fi
}

# â”€â”€ sharedUserId manifest injection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Rebulids the APK's AndroidManifest.xml to declare a sharedUserId,
# making Android run the app in the same process UID as a system app.
_inject_shared_user_id() {
    local apk_in="$1" pkg="$2"
    SHARED_UID_APK=""   # output path

    echo ""
    echo -e "  ${BOLD}${CYAN}â”Œâ”€ sharedUserId Injection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${ENDC}"
    echo -e "  ${BOLD}${CYAN}â”‚${ENDC}  Run your app as the same UID as a system app    ${BOLD}${CYAN}â”‚${ENDC}"
    echo -e "  ${BOLD}${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${ENDC}"
    echo ""
    echo -e "  ${YELLOW}What sharedUserId does:${ENDC}"
    echo "    Declaring android:sharedUserId in the manifest lets your"
    echo "    app share the Linux UID of a system process.  Combined with"
    echo "    a matching signature, the PM grants it the same permissions"
    echo "    without any runtime prompts â€” it IS that system app."
    echo ""
    echo "  Common values:"
    echo "    android.uid.system        â€” full system (UID 1000, all perms)"
    echo "    android.uid.phone         â€” phone/RIL process (UID 1001)"
    echo "    android.uid.bluetooth     â€” Bluetooth stack (UID 1002)"
    echo "    android.uid.log           â€” read system logs (UID 1007)"
    echo "    android.uid.shell         â€” shell (UID 2000)"
    echo "    <custom>                  â€” share with any specific app's UID"
    echo ""
    echo -e "  ${RED}Requires: APK must be signed with the KEY that owns that UID.${ENDC}"
    echo -e "  ${RED}Incorrect UID + wrong key = install failure, possible bootloop.${ENDC}"
    echo ""

    if ! command -v apktool &>/dev/null; then
        echo -e "  ${YELLOW}âš  apktool not found. Attempting binary manifest patch (experimental)â€¦${ENDC}"
        # Fallback: binary patch approach using python3
        if ! command -v python3 &>/dev/null; then
            echo -e "  ${RED}âœ— python3 not found either â€” cannot inject sharedUserId${ENDC}"
            echo -e "  ${YELLOW}  Install: sudo apt install apktool${ENDC}"
            return 1
        fi
    fi

    echo "  1. android.uid.system"
    echo "  2. android.uid.phone"
    echo "  3. android.uid.shell"
    echo "  4. Custom value"
    echo "  5. Skip sharedUserId injection"
    echo ""
    read -rp "  Choice [1-5, default=5]: " uid_choice
    local suid_val=""
    case "${uid_choice:-5}" in
        1) suid_val="android.uid.system" ;;
        2) suid_val="android.uid.phone" ;;
        3) suid_val="android.uid.shell" ;;
        4) read -rp "  Enter sharedUserId value: " suid_val ;;
        5) echo -e "  ${CYAN}Skipping sharedUserId injection.${ENDC}"; return 0 ;;
        *) echo -e "  ${CYAN}Skipping.${ENDC}"; return 0 ;;
    esac

    [[ -z "$suid_val" ]] && { echo -e "  ${CYAN}Skipping.${ENDC}"; return 0; }

    local patched_apk="${apk_in%.apk}_suid.apk"

    if command -v apktool &>/dev/null; then
        echo -e "  ${CYAN}Decompiling APK with apktoolâ€¦${ENDC}"
        local decompile_dir="/tmp/droidb_suid_${pkg//[^a-zA-Z0-9]/_}_$$"
        apktool d -f -o "$decompile_dir" "$apk_in" >/dev/null 2>&1
        local manifest="$decompile_dir/AndroidManifest.xml"
        if [[ ! -f "$manifest" ]]; then
            echo -e "  ${RED}âœ— apktool decompile failed${ENDC}"
            rm -rf "$decompile_dir"; return 1
        fi
        # Inject or replace sharedUserId attribute
        if grep -q 'sharedUserId' "$manifest"; then
            sed -i "s/android:sharedUserId=\"[^\"]*\"/android:sharedUserId=\"$suid_val\"/" "$manifest"
        else
            sed -i "s|<manifest|<manifest android:sharedUserId=\"$suid_val\"|" "$manifest"
        fi
        echo -e "  ${CYAN}Repacking APKâ€¦${ENDC}"
        apktool b -f "$decompile_dir" -o "$patched_apk" >/dev/null 2>&1
        rm -rf "$decompile_dir"
        if [[ -f "$patched_apk" ]]; then
            echo -e "  ${GREEN}âœ“ sharedUserId=\"$suid_val\" injected${ENDC}"
            SHARED_UID_APK="$patched_apk"
        else
            echo -e "  ${RED}âœ— apktool repack failed${ENDC}"; return 1
        fi
    else
        # Python binary patch â€” finds the sharedUserId string or inserts it
        echo -e "  ${CYAN}Attempting binary manifest patch via python3â€¦${ENDC}"
        python3 - "$apk_in" "$patched_apk" "$suid_val" <<'PYEOF'
import sys, zipfile, re, shutil

apk_in, apk_out, suid = sys.argv[1], sys.argv[2], sys.argv[3]

with zipfile.ZipFile(apk_in,'r') as z:
    raw = z.read('AndroidManifest.xml')

# Look for existing sharedUserId UTF-16LE string in binary manifest
marker = 'sharedUserId'.encode('utf-16-le')
suid_bytes = suid.encode('utf-16-le')

if marker in raw:
    # Find the length-prefixed UTF-16LE string after the marker
    idx = raw.index(marker)
    # The string pool stores: [2-byte length][chars][00 00]
    # Walk back to find the length field
    start = idx - 2  # length is 2 bytes before the string
    old_len = int.from_bytes(raw[start:start+2], 'little')
    old_str = raw[start+2 : start+2 + old_len*2]
    new_blob = len(suid).to_bytes(2,'little') + suid_bytes + b'\x00\x00'
    old_blob = old_len.to_bytes(2,'little') + old_str + b'\x00\x00'
    patched = raw.replace(old_blob, new_blob, 1)
    if patched == raw:
        print("WARNING: binary patch found no change â€” may need apktool", file=sys.stderr)
    raw = patched

shutil.copy(apk_in, apk_out)
with zipfile.ZipFile(apk_out,'a') as z:
    z.writestr('AndroidManifest.xml', raw)
print("done")
PYEOF
        if [[ $? -eq 0 && -f "$patched_apk" ]]; then
            echo -e "  ${GREEN}âœ“ Binary sharedUserId patch applied (\"$suid_val\")${ENDC}"
            echo -e "  ${YELLOW}  Note: Binary patch is best-effort. Verify with aapt dump badging.${ENDC}"
            SHARED_UID_APK="$patched_apk"
        else
            echo -e "  ${RED}âœ— Binary patch failed â€” install apktool for reliable injection${ENDC}"
            return 1
        fi
    fi
}

# â”€â”€ Signing menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_signing_menu() {
    local apk_in="$1" pkg="$2"
    SIGNED_APK_PATH=""

    echo ""
    echo -e "  ${BOLD}${CYAN}â”Œâ”€ APK Signing Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${ENDC}"
    echo -e "  ${BOLD}${CYAN}â”‚${ENDC}  Optional â€” only needed for your own custom apps ${BOLD}${CYAN}â”‚${ENDC}"
    echo -e "  ${BOLD}${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${ENDC}"
    echo ""
    echo "  Why sign? A consistent signing key means:"
    echo "    â€¢ Updates accepted without uninstall"
    echo "    â€¢ System won't flag the app as unknown"
    echo "    â€¢ Signature permissions work reliably"
    echo "    â€¢ App treated as trusted as the source app"
    echo ""
    echo "  Choose signing option:"
    echo "    1. â­  Skip â€” use APK as-is (already signed / debug build)"
    echo "    2. ğŸ”‘  Auto test-key â€” persistent droidB keystore"
    echo "    3. ğŸ—  Custom keystore â€” your own .jks / .keystore"
    echo "    4. ğŸ­  Inspect platform key (cert info only)"
    echo "    5. ğŸª  Clone signature from a system app on this device"
    echo ""
    read -rp "  Choice [1-5, default=1]: " sign_choice

    local signed_out="/tmp/droidb_signed_${pkg}.apk"

    case "${sign_choice:-1}" in
        1)
            echo -e "  ${CYAN}Skipping â€” APK used as-is.${ENDC}"
            SIGNED_APK_PATH="$apk_in"
            ;;
        2)
            _check_signing_tools || { SIGNED_APK_PATH="$apk_in"; return; }
            _sign_apk_test_key "$apk_in" "$signed_out" "$pkg" \
                && SIGNED_APK_PATH="$signed_out" \
                || SIGNED_APK_PATH="$apk_in"
            ;;
        3)
            _check_signing_tools || { SIGNED_APK_PATH="$apk_in"; return; }
            echo -e "  ${YELLOW}Drag & drop .jks / .keystore:${ENDC}"
            read -rp "  Keystore path: " ks_raw
            KS_FILE=$(process_path "$ks_raw")
            if [[ ! -f "$KS_FILE" ]]; then
                echo -e "  ${RED}âœ— Not found â€” skipping.${ENDC}"
                SIGNED_APK_PATH="$apk_in"; return
            fi
            read -rp "  Password: " KS_PASS
            read -rp "  Alias: "    KS_ALIAS
            _sign_apk_test_key "$apk_in" "$signed_out" "$pkg" \
                && SIGNED_APK_PATH="$signed_out" \
                || SIGNED_APK_PATH="$apk_in"
            ;;
        4)
            _extract_platform_key
            _check_signing_tools || { SIGNED_APK_PATH="$apk_in"; return; }
            _sign_apk_test_key "$apk_in" "$signed_out" "$pkg" \
                && SIGNED_APK_PATH="$signed_out" \
                || SIGNED_APK_PATH="$apk_in"
            ;;
        5)
            _check_signing_tools || { SIGNED_APK_PATH="$apk_in"; return; }
            if _clone_system_app_signature "$pkg"; then
                if [[ -n "${CLONED_KS_FILE:-}" && -f "${CLONED_KS_FILE}" ]]; then
                    # Swap in cloned keystore and sign
                    KS_FILE="$CLONED_KS_FILE"
                    KS_PASS="$CLONED_KS_PASS"
                    KS_ALIAS="$CLONED_KS_ALIAS"
                    echo -e "\n  ${CYAN}Signing with cloned keystoreâ€¦${ENDC}"
                    _sign_apk_test_key "$apk_in" "$signed_out" "$pkg" \
                        && {
                            SIGNED_APK_PATH="$signed_out"
                            echo -e "  ${GREEN}âœ“ Signed with cloned signature identity${ENDC}"
                        } \
                        || SIGNED_APK_PATH="$apk_in"
                else
                    # Clone returned info only â€” fall back
                    echo -e "  ${YELLOW}No keystore produced â€” falling back to droidB test key.${ENDC}"
                    _sign_apk_test_key "$apk_in" "$signed_out" "$pkg" \
                        && SIGNED_APK_PATH="$signed_out" \
                        || SIGNED_APK_PATH="$apk_in"
                fi
            else
                SIGNED_APK_PATH="$apk_in"
            fi
            ;;
        *)
            SIGNED_APK_PATH="$apk_in" ;;
    esac
}
# â”€â”€ Main system app push function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
push_system_app() {
    clear_screen
    echo -e "${BOLD}${MAGENTA}ğŸ”§ PUSH APK AS SYSTEM APP${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
    echo -e "${RED}${BOLD}âš   TINKERERS ONLY â€” Root required. Wrong APKs can"
    echo -e "   bootloop your device. Always back up first!${ENDC}"
    echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}\n"

    # â”€â”€ Root check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${CYAN}Checking root accessâ€¦${ENDC}"
    if ! _check_root; then
        echo -e "  ${RED}âœ— Root not detected. Install Magisk or KernelSU.${ENDC}"
        read -rp "  Press ENTER to returnâ€¦" _; return
    fi
    echo -e "  ${GREEN}âœ“ Root confirmed${ENDC}\n"

    # â”€â”€ APK selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${YELLOW}Drag & drop APK or type path:${ENDC}"
    read -rp "  APK file: " APK_RAW
    local APK; APK=$(process_path "$APK_RAW")
    if [[ ! -f "$APK" ]]; then
        echo -e "  ${RED}âœ— File not found: $APK${ENDC}"
        read -rp "  Press ENTERâ€¦" _; return
    fi
    _validate_apk "$APK" || { read -rp "  Press ENTERâ€¦" _; return; }

    local PKG_NAME; PKG_NAME=$(_get_pkg_name "$APK")
    local APK_BASENAME; APK_BASENAME=$(basename "$APK")
    local APK_SIZE; APK_SIZE=$(du -sh "$APK" | cut -f1)

    echo -e "\n  ${BOLD}APK details:${ENDC}"
    echo -e "    Package : ${CYAN}$PKG_NAME${ENDC}"
    echo -e "    File    : ${CYAN}$APK_BASENAME${ENDC}"
    echo -e "    Size    : ${MAGENTA}$APK_SIZE${ENDC}"

    # â”€â”€ Step 1: Target directory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _pick_system_dir

    # â”€â”€ Step 2: Permission profile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _SIGNING_APK_PATH="$APK"  # used by auto-detect inside _permission_profile_menu
    _permission_profile_menu

    # â”€â”€ Step 2.5: sharedUserId injection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _inject_shared_user_id "$APK" "$PKG_NAME"
    # If injection produced a new APK, use it as the base for signing
    [[ -n "${SHARED_UID_APK:-}" && -f "$SHARED_UID_APK" ]] && APK="$SHARED_UID_APK"

    # â”€â”€ Step 3: Signing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _signing_menu "$APK" "$PKG_NAME"
    local FINAL_APK="$SIGNED_APK_PATH"

    # â”€â”€ Step 4: Root grant â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    local GRANT_ROOT="n"
    echo ""
    read -rp "  Grant root access to this app via Magisk/KernelSU? [y/N]: " GRANT_ROOT

    # â”€â”€ Setup paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    local APP_FOLDER="$SYS_TARGET/$PKG_NAME"
    local REMOTE_APK="$APP_FOLDER/$PKG_NAME.apk"

    # â”€â”€ Existing app check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    local existing; existing=$(_su "[ -d '$APP_FOLDER' ] && echo exists")
    if [[ "$existing" == "exists" ]]; then
        echo -e "\n  ${YELLOW}âš  App folder already exists: $APP_FOLDER${ENDC}"
        echo "    1. Overwrite    2. Cancel"
        read -rp "  Choice [1-2]: " ow_choice
        [[ "${ow_choice:-2}" != "1" ]] && { echo -e "  ${CYAN}Cancelled.${ENDC}"; read -rp "  Press ENTERâ€¦" _; return; }
    fi

    # â”€â”€ Summary before commit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo ""
    echo -e "  ${BOLD}Operation summary:${ENDC}"
    echo -e "    Package    : ${CYAN}$PKG_NAME${ENDC}"
    echo -e "    Destination: ${CYAN}$REMOTE_APK${ENDC}"
    echo -e "    APK source : ${CYAN}$(basename "$FINAL_APK")${ENDC}"
    local perm_cnt; perm_cnt=$(echo "$SELECTED_PERMS" | grep -c "android\." 2>/dev/null || echo 0)
    echo -e "    Permissions: ${MAGENTA}$perm_cnt to auto-grant${ENDC}"
    [[ -n "${SHARED_UID_APK:-}" ]] && echo -e "    sharedUserId: ${GREEN}injected${ENDC}"
    [[ "$SYS_TARGET" == *"priv-app"* ]] && echo -e "    privapp XML: ${GREEN}yes${ENDC}"
    [[ "${GRANT_ROOT,,}" == "y" ]] && echo -e "    Root grant : ${GREEN}yes (Magisk/KernelSU)${ENDC}"
    echo ""
    read -rp "  Proceed? [y/N]: " confirm
    [[ "${confirm,,}" != "y" ]] && { echo -e "  ${CYAN}Aborted.${ENDC}"; read -rp "  Press ENTERâ€¦" _; return; }

    echo ""

    # â”€â”€ Remount rw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _remount_rw || { read -rp "  Press ENTERâ€¦" _; return; }

    # â”€â”€ Create dir & push APK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${CYAN}Creating app directoryâ€¦${ENDC}"
    _su "mkdir -p '$APP_FOLDER'"

    echo -e "  ${CYAN}Uploading APK via stagingâ€¦${ENDC}"
    $ADB -s "$SERIAL" push "$FINAL_APK" "/data/local/tmp/$PKG_NAME.apk" 2>&1 \
        | grep -v "^$" | sed 's/^/    /'
    _su "cp /data/local/tmp/$PKG_NAME.apk '$REMOTE_APK'"
    _su "rm /data/local/tmp/$PKG_NAME.apk"

    # â”€â”€ Verify â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    local landed; landed=$(_su "[ -f '$REMOTE_APK' ] && stat -c '%s' '$REMOTE_APK'")
    if [[ -z "$landed" || "$landed" == "0" ]]; then
        echo -e "  ${RED}âœ— APK did not land â€” aborting${ENDC}"
        _remount_ro; read -rp "  Press ENTERâ€¦" _; return
    fi
    echo -e "  ${GREEN}âœ“ APK placed (${MAGENTA}$(numfmt --to=iec "$landed" 2>/dev/null || echo "${landed}B")${GREEN})${ENDC}"

    # â”€â”€ File system permissions & SELinux â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${CYAN}Setting ownership, permissions, SELinux contextâ€¦${ENDC}"
    _su "chown root:root '$REMOTE_APK' && chmod 644 '$REMOTE_APK'"
    _su "chown root:root '$APP_FOLDER' && chmod 755 '$APP_FOLDER'"
    _su "chcon -R u:object_r:system_file:s0 '$APP_FOLDER'" 2>/dev/null \
        && echo -e "  ${GREEN}âœ“ SELinux context set${ENDC}" \
        || echo -e "  ${YELLOW}âš  SELinux context skipped (non-fatal)${ENDC}"

    # â”€â”€ Write privapp-permissions XML â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _write_privapp_permissions_xml "$PKG_NAME"

    # â”€â”€ Remount ro â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _remount_ro

    # â”€â”€ PM install/rescan â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo -e "  ${CYAN}Triggering PM rescanâ€¦${ENDC}"
    _su "pm install -r '$REMOTE_APK'" 2>/dev/null \
        && echo -e "  ${GREEN}âœ“ PM accepted â€” app active immediately${ENDC}" \
        || echo -e "  ${YELLOW}âš  PM rescan skipped â€” reboot required${ENDC}"

    # â”€â”€ Grant runtime permissions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if [[ -n "$SELECTED_PERMS" ]]; then
        _grant_permissions "$PKG_NAME"
    fi

    # â”€â”€ Grant root access â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if [[ "${GRANT_ROOT,,}" == "y" ]]; then
        _grant_root_to_app "$PKG_NAME"
    fi

    # â”€â”€ Clean up signed/patched tmp APKs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    [[ "$FINAL_APK" != "$APK" && -f "$FINAL_APK" ]] && rm -f "$FINAL_APK"
    [[ -n "${SHARED_UID_APK:-}" && "$SHARED_UID_APK" != "$APK" ]] && rm -f "$SHARED_UID_APK"

    # â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    echo ""
    echo -e "${BOLD}${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"
    echo -e "${BOLD}${GREEN}  âœ“ System App Installed & Configured${ENDC}"
    echo -e "${GREEN}  Package    : $PKG_NAME${ENDC}"
    echo -e "${GREEN}  Location   : $REMOTE_APK${ENDC}"
    local perm_cnt2; perm_cnt2=$(echo "$SELECTED_PERMS" | grep -c "android\." 2>/dev/null || echo 0)
    echo -e "${GREEN}  Permissions: $perm_cnt2 auto-granted${ENDC}"
    [[ "${GRANT_ROOT,,}" == "y" ]] && echo -e "${GREEN}  Root access: granted${ENDC}"
    [[ -n "${KS_FILE:-}" ]] && echo -e "${CYAN}  Keystore   : $KS_FILE${ENDC}"
    echo -e "${BOLD}${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"

    echo ""
    echo -e "  ${YELLOW}Reboot recommended to fully activate the system app.${ENDC}"
    read -rp "  Reboot device now? [y/N]: " reboot_choice
    if [[ "${reboot_choice,,}" == "y" ]]; then
        echo -e "  ${CYAN}Rebootingâ€¦${ENDC}"
        $ADB -s "$SERIAL" reboot
    fi

    read -rp "  Press ENTER to return to App Managementâ€¦" _
}

app_management_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ“± APP MANAGEMENT${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        if [[ -z "$SERIAL" ]]; then
            echo -e "${RED}No device connected${ENDC}"
            read -p "Press Enter to return..."
            return
        fi
        
        echo "1. Install APK"
        echo "2. Uninstall app"
        echo "3. List installed apps"
        echo "4. List system apps"
        echo "5. List third-party apps"
        echo "6. Clear app data"
        echo "7. Force stop app"
        echo "8. ğŸ”§ Push APK as System App (tinkerers)"
        echo "9. Back"
        echo ""
        
        read -p "Select: " opt
        
        case $opt in
            1)
                echo -e "${YELLOW}Drag & drop APK or type path:${ENDC}"
                read -p "APK file: " APK
                APK=$(process_path "$APK")
                if [[ -f "$APK" ]]; then
                    echo -e "${BLUE}Installing...${ENDC}"
                    $ADB -s $SERIAL install -r "$APK"
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Installed successfully${ENDC}" || echo -e "${RED}âœ— Installation failed${ENDC}"
                else
                    echo -e "${RED}File not found${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            2)
                read -p "Package name: " PKG
                if [[ -n "$PKG" ]]; then
                    echo -e "${BLUE}Uninstalling...${ENDC}"
                    $ADB -s $SERIAL uninstall "$PKG"
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Uninstalled${ENDC}" || echo -e "${RED}âœ— Uninstall failed${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            3)
                echo -e "${BLUE}All installed packages:${ENDC}"
                $ADB -s $SERIAL shell pm list packages | sed 's/package://' | sort
                read -p "Press Enter..."
                ;;
            4)
                echo -e "${BLUE}System apps:${ENDC}"
                $ADB -s $SERIAL shell pm list packages -s | sed 's/package://' | sort
                read -p "Press Enter..."
                ;;
            5)
                echo -e "${BLUE}Third-party apps:${ENDC}"
                $ADB -s $SERIAL shell pm list packages -3 | sed 's/package://' | sort
                read -p "Press Enter..."
                ;;
            6)
                read -p "Package name: " PKG
                if [[ -n "$PKG" ]]; then
                    echo -e "${BLUE}Clearing data...${ENDC}"
                    $ADB -s $SERIAL shell pm clear "$PKG"
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Data cleared${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            7)
                read -p "Package name: " PKG
                if [[ -n "$PKG" ]]; then
                    echo -e "${BLUE}Stopping app...${ENDC}"
                    $ADB -s $SERIAL shell am force-stop "$PKG"
                    echo -e "${GREEN}âœ“ App stopped${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            8) push_system_app ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

file_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}ğŸ“ FILE OPERATIONS${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        if [[ -z "$SERIAL" ]]; then
            echo -e "${RED}No device connected${ENDC}"
            read -p "Press Enter to return..."
            return
        fi
        
        echo "1. Push file to device"
        echo "2. Pull file from device"
        echo "3. Screenshot"
        echo "4. Screen record"
        echo "5. List files on device"
        echo "6. Back"
        echo ""
        
        read -p "Select: " opt
        
        case $opt in
            1)
                echo -e "${YELLOW}File path:${ENDC}"
                read -p "> " FILE
                FILE=$(process_path "$FILE")
                if [[ -f "$FILE" ]]; then
                    read -p "Destination on device (default: /sdcard/): " DEST
                    DEST=${DEST:-/sdcard/}
                    echo -e "${BLUE}Pushing file...${ENDC}"
                    $ADB -s $SERIAL push "$FILE" "$DEST"
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ File pushed${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                else
                    echo -e "${RED}File not found${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            2)
                read -p "Device path: " SRC
                if [[ -n "$SRC" ]]; then
                    echo -e "${BLUE}Pulling file...${ENDC}"
                    $ADB -s $SERIAL pull "$SRC" .
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ File pulled${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            3)
                TIMESTAMP=$(date +%Y%m%d_%H%M%S)
                echo -e "${BLUE}Taking screenshot...${ENDC}"
                $ADB -s $SERIAL shell screencap -p /sdcard/screenshot.png
                $ADB -s $SERIAL pull /sdcard/screenshot.png screenshot_$TIMESTAMP.png
                $ADB -s $SERIAL shell rm /sdcard/screenshot.png
                [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Saved: screenshot_$TIMESTAMP.png${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                read -p "Press Enter..."
                ;;
            4)
                read -p "Duration in seconds (default: 10): " DURATION
                DURATION=${DURATION:-10}
                TIMESTAMP=$(date +%Y%m%d_%H%M%S)
                echo -e "${BLUE}Recording screen for $DURATION seconds...${ENDC}"
                $ADB -s $SERIAL shell screenrecord --time-limit $DURATION /sdcard/recording.mp4 &
                sleep $DURATION
                wait
                echo -e "${BLUE}Pulling recording...${ENDC}"
                $ADB -s $SERIAL pull /sdcard/recording.mp4 screenrecord_$TIMESTAMP.mp4
                $ADB -s $SERIAL shell rm /sdcard/recording.mp4
                [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Saved: screenrecord_$TIMESTAMP.mp4${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                read -p "Press Enter..."
                ;;
            5)
                read -p "Path on device (default: /sdcard/): " PATH
                PATH=${PATH:-/sdcard/}
                echo -e "${BLUE}Listing files in $PATH:${ENDC}"
                $ADB -s $SERIAL shell ls -lah "$PATH"
                read -p "Press Enter..."
                ;;
            6) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

system_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${CYAN}âš™ï¸  SYSTEM OPERATIONS${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        if [[ -z "$SERIAL" ]]; then
            echo -e "${RED}No device connected${ENDC}"
            read -p "Press Enter to return..."
            return
        fi
        
        echo "1. Reboot device"
        echo "2. Reboot to recovery"
        echo "3. Reboot to bootloader"
        echo "4. Reboot to download mode (Samsung)"
        echo "5. Battery info"
        echo "6. Device properties"
        echo "7. Logcat (live log)"
        echo "8. Back"
        echo ""
        
        read -p "Select: " opt
        
        case $opt in
            1)
                confirm_action "Reboot device?" && {
                    echo -e "${BLUE}Rebooting...${ENDC}"
                    $ADB -s $SERIAL reboot
                    echo -e "${GREEN}âœ“ Reboot command sent${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            2)
                confirm_action "Reboot to recovery?" && {
                    echo -e "${BLUE}Rebooting to recovery...${ENDC}"
                    $ADB -s $SERIAL reboot recovery
                    echo -e "${GREEN}âœ“ Reboot command sent${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            3)
                confirm_action "Reboot to bootloader?" && {
                    echo -e "${BLUE}Rebooting to bootloader...${ENDC}"
                    $ADB -s $SERIAL reboot bootloader
                    echo -e "${GREEN}âœ“ Reboot command sent${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            4)
                confirm_action "Reboot to download mode (Samsung)?" && {
                    echo -e "${BLUE}Rebooting to download mode...${ENDC}"
                    $ADB -s $SERIAL reboot download
                    echo -e "${GREEN}âœ“ Reboot command sent${ENDC}"
                    echo -e "${YELLOW}Device should now be in download mode${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            5)
                echo -e "${BLUE}Battery information:${ENDC}"
                $ADB -s $SERIAL shell dumpsys battery
                read -p "Press Enter..."
                ;;
            6)
                echo -e "${BLUE}Device properties:${ENDC}"
                $ADB -s $SERIAL shell getprop
                read -p "Press Enter..."
                ;;
            7)
                echo -e "${BLUE}Starting logcat (Press Ctrl+C to stop)...${ENDC}"
                $ADB -s $SERIAL logcat
                read -p "Press Enter..."
                ;;
            8) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

fastboot_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${RED}âš¡ FASTBOOT OPERATIONS${ENDC}"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        if [[ -z "$FASTBOOT" ]]; then
            echo -e "${RED}Fastboot not available${ENDC}"
            read -p "Press Enter..."
            return
        fi
        
        FASTBOOT_DEVICES=$($FASTBOOT devices 2>/dev/null)
        
        if [[ -z "$FASTBOOT_DEVICES" ]]; then
            echo -e "${RED}No devices in fastboot mode${ENDC}"
            echo -e "${CYAN}To enter fastboot:${ENDC}"
            echo "  â€¢ adb reboot bootloader"
            echo "  â€¢ Volume Down + Power (device off)"
            read -p "Press Enter..."
            return
        fi
        
        echo -e "${GREEN}Fastboot device detected${ENDC}"
        echo ""
        
        echo "1. Flash partition"
        echo "2. Boot image (temporary)"
        echo "3. Unlock bootloader (WIPES DATA)"
        echo "4. Lock bootloader"
        echo "5. Get device info"
        echo "6. Erase partition"
        echo "7. Format partition"
        echo "8. Reboot"
        echo "9. Back"
        echo ""
        
        read -p "Select: " opt
        
        case $opt in
            1)
                read -p "Partition name (boot/recovery/system/vendor): " PART
                echo -e "${YELLOW}Drag & drop image:${ENDC}"
                read -p "Image: " IMG
                IMG=$(process_path "$IMG")
                if [[ -f "$IMG" ]]; then
                    pre_flash_backup_check || { read -p "Press Enter..."; continue; }
                    confirm_action "Flash $PART?" && {
                        echo -e "${BLUE}Flashing...${ENDC}"
                        $FASTBOOT flash $PART "$IMG"
                        [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Flash successful${ENDC}" || echo -e "${RED}âœ— Flash failed${ENDC}"
                    }
                else
                    echo -e "${RED}File not found${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            2)
                echo -e "${YELLOW}Drag & drop image:${ENDC}"
                read -p "Image: " IMG
                IMG=$(process_path "$IMG")
                if [[ -f "$IMG" ]]; then
                    echo -e "${BLUE}Booting...${ENDC}"
                    $FASTBOOT boot "$IMG"
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Boot command sent${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                else
                    echo -e "${RED}File not found${ENDC}"
                fi
                read -p "Press Enter..."
                ;;
            3)
                echo -e "${RED}${BOLD}WARNING: This will WIPE ALL DATA${ENDC}"
                pre_flash_backup_check || { read -p "Press Enter..."; continue; }
                confirm_action "Unlock bootloader?" && {
                    echo -e "${BLUE}Unlocking bootloader...${ENDC}"
                    $FASTBOOT flashing unlock 2>/dev/null || $FASTBOOT oem unlock 2>/dev/null
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Unlock initiated${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            4)
                echo -e "${RED}${BOLD}WARNING: Lock with custom firmware = BRICK${ENDC}"
                confirm_action "Lock bootloader?" && {
                    echo -e "${BLUE}Locking bootloader...${ENDC}"
                    $FASTBOOT flashing lock 2>/dev/null || $FASTBOOT oem lock 2>/dev/null
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Lock initiated${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            5)
                echo -e "${BLUE}Device information:${ENDC}"
                $FASTBOOT getvar all 2>&1 | grep -v "< waiting"
                read -p "Press Enter..."
                ;;
            6)
                read -p "Partition to erase: " PART
                confirm_action "Erase $PART?" && {
                    echo -e "${BLUE}Erasing...${ENDC}"
                    $FASTBOOT erase $PART
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Erased${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            7)
                read -p "Partition to format: " PART
                confirm_action "Format $PART?" && {
                    echo -e "${BLUE}Formatting...${ENDC}"
                    $FASTBOOT format $PART
                    [[ $? -eq 0 ]] && echo -e "${GREEN}âœ“ Formatted${ENDC}" || echo -e "${RED}âœ— Failed${ENDC}"
                }
                read -p "Press Enter..."
                ;;
            8)
                echo -e "${BLUE}Rebooting...${ENDC}"
                $FASTBOOT reboot
                echo -e "${GREEN}âœ“ Reboot command sent${ENDC}"
                read -p "Press Enter..."
                ;;
            9) return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

install_systemwide() {
    echo -e "${BOLD}${GREEN}Installing droidB system-wide...${ENDC}"
    
    if [[ $EUID -ne 0 ]]; then
        sudo cp "$0" "$INSTALL_DIR/$SCRIPT_NAME"
        sudo chmod +x "$INSTALL_DIR/$SCRIPT_NAME"
    else
        cp "$0" "$INSTALL_DIR/$SCRIPT_NAME"
        chmod +x "$INSTALL_DIR/$SCRIPT_NAME"
    fi
    
    echo -e "${GREEN}âœ“ Installed to $INSTALL_DIR/$SCRIPT_NAME${ENDC}"
    echo -e "${GREEN}Run '$SCRIPT_NAME' from anywhere${ENDC}"
    exit 0
}

check_requirements() {
    create_embedded_debloat_list
    
    if ! command -v adb &>/dev/null; then
        echo -e "${RED}ERROR: ADB not found${ENDC}"
        echo "Install android-tools package for your system"
        exit 1
    fi
    ADB=$(command -v adb)
    
    if ! command -v fastboot &>/dev/null; then
        echo -e "${YELLOW}Warning: Fastboot not found${ENDC}"
    fi
    FASTBOOT=$(command -v fastboot)
    
    check_samsung_tools
    
    $ADB start-server &>/dev/null
}

# ============================================================
#  FULL DEVICE BACKUP  (v0.3.0 â€” pre-flash data protection)
# ============================================================

# Helper: progress spinner
_spin() {
    local pid=$1 msg=$2
    local sp='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    local i=0
    while kill -0 "$pid" 2>/dev/null; do
        printf "\r  ${CYAN}%s${ENDC} %s " "${sp:$((i%10)):1}" "$msg"
        i=$((i+1)); sleep 0.1
    done
    printf "\r  ${GREEN}âœ“${ENDC} %-60s\n" "$msg"
}

# Helper: section header
_bsec() { echo -e "\n${BOLD}${CYAN}â–¶ $1${ENDC}"; echo -e "${YELLOW}$(printf 'â”€%.0s' {1..60})${ENDC}"; }

# Helper: size of local dir/file
_sz() { du -sh "$1" 2>/dev/null | cut -f1; }

# â”€â”€ choose / create backup destination â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_backup_pick_dest() {
    local default_dir="$HOME/droidB_backups/$(date +%Y%m%d_%H%M%S)_${SERIAL}"
    echo -e "\n${BOLD}Backup destination${ENDC}"
    echo -e "  Default: ${CYAN}$default_dir${ENDC}"
    read -rp "  Press ENTER to accept or type a custom path: " custom
    BACKUP_DIR="${custom:-$default_dir}"
    mkdir -p "$BACKUP_DIR" || { echo -e "${RED}Cannot create: $BACKUP_DIR${ENDC}"; return 1; }
    echo -e "  ${GREEN}âœ“ Saving to: $BACKUP_DIR${ENDC}"
}

# â”€â”€ SMS backup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_sms() {
    _bsec "SMS Messages"
    local out="$BACKUP_DIR/sms_mms.ab"
    echo -e "  ${YELLOW}Unlocking device before adb backup â€” accept the prompt on screen${ENDC}"
    $ADB -s "$SERIAL" backup -noapk -noshared com.android.providers.telephony -f "$out" &
    local pid=$!
    _spin $pid "Backing up SMS/MMS (accept prompt on device)â€¦"
    wait $pid
    if [[ -f "$out" && -s "$out" ]]; then
        echo -e "  ${GREEN}âœ“ SMS/MMS saved (${MAGENTA}$(_sz "$out")${GREEN})${ENDC}"
    else
        # fallback: content query CSV export
        echo -e "  ${YELLOW}âš  adb backup blocked â€” trying content provider dumpâ€¦${ENDC}"
        local csv="$BACKUP_DIR/sms_dump.csv"
        echo "date,address,type,body" > "$csv"
        $ADB -s "$SERIAL" shell content query \
            --uri content://sms \
            --projection date,address,type,body 2>/dev/null \
            | sed 's/Row: [0-9]* //' \
            | sed 's/, /\t/g' \
            >> "$csv"
        local rows; rows=$(wc -l < "$csv")
        if [[ $rows -gt 1 ]]; then
            echo -e "  ${GREEN}âœ“ SMS CSV dump: $((rows-1)) messages â†’ sms_dump.csv${ENDC}"
        else
            echo -e "  ${RED}âœ— SMS backup failed (no root / blocked by ROM)${ENDC}"
        fi
    fi
}

# â”€â”€ Contacts backup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_contacts() {
    _bsec "Contacts"
    local vcf="$BACKUP_DIR/contacts.vcf"
    # Try vCard export via content provider
    $ADB -s "$SERIAL" shell content query \
        --uri content://com.android.contacts/contacts 2>/dev/null \
        | grep -q "Row:" && {
        # proper vCard pull via vcard MIME type stream
        $ADB -s "$SERIAL" shell "
            for id in \$(content query --uri content://com.android.contacts/contacts --projection _id 2>/dev/null | grep -oP '_id=\K[0-9]+'); do
                content read --uri \"content://com.android.contacts/contacts/\$id/display_photo\" 2>/dev/null
            done" > /dev/null 2>&1
        # Use adb backup for contacts DB
        local out="$BACKUP_DIR/contacts.ab"
        $ADB -s "$SERIAL" backup -noapk -noshared com.android.providers.contacts -f "$out" &>/dev/null &
        local pid=$!
        _spin $pid "Backing up Contacts (accept prompt on device)â€¦"
        wait $pid
        if [[ -f "$out" && -s "$out" ]]; then
            echo -e "  ${GREEN}âœ“ Contacts DB backup (${MAGENTA}$(_sz "$out")${GREEN}) â†’ contacts.ab${ENDC}"
            return
        fi
    }
    # Fallback: vcard via content://com.android.contacts/contacts/as_vcard
    echo -e "  ${YELLOW}Trying vCard stream exportâ€¦${ENDC}"
    $ADB -s "$SERIAL" shell \
        "content read --uri \"content://com.android.contacts/contacts/as_vcard\"" \
        > "$vcf" 2>/dev/null
    local cnt; cnt=$(grep -c "^BEGIN:VCARD" "$vcf" 2>/dev/null || echo 0)
    if [[ $cnt -gt 0 ]]; then
        echo -e "  ${GREEN}âœ“ $cnt contact(s) saved â†’ contacts.vcf${ENDC}"
    else
        echo -e "  ${RED}âœ— Contacts backup failed (no root / blocked by ROM)${ENDC}"
        rm -f "$vcf"
    fi
}

# â”€â”€ Call logs backup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_call_logs() {
    _bsec "Call Logs"
    local csv="$BACKUP_DIR/call_logs.csv"
    echo "date,number,name,duration_sec,type" > "$csv"
    $ADB -s "$SERIAL" shell content query \
        --uri content://call_log/calls \
        --projection date,number,cachedName,duration,type 2>/dev/null \
        | sed 's/Row: [0-9]* //' \
        | sed 's/cachedName=/name=/g' \
        | awk -F', ' '{
            for(i=1;i<=NF;i++){
                split($i,kv,"="); vals[kv[1]]=kv[2]
            }
            print vals["date"] "," vals["number"] "," vals["name"] "," vals["duration"] "," vals["type"]
          }' \
        >> "$csv"
    local rows; rows=$(wc -l < "$csv")
    if [[ $rows -gt 1 ]]; then
        echo -e "  ${GREEN}âœ“ $((rows-1)) call log entries â†’ call_logs.csv${ENDC}"
    else
        echo -e "  ${RED}âœ— Call log backup failed (blocked by ROM)${ENDC}"
    fi
}

# â”€â”€ Media backup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_media() {
    _bsec "Media Files (Photos, Videos, Audio, Documents)"
    local media_dir="$BACKUP_DIR/media"
    mkdir -p "$media_dir"

    # Paths to pull
    local paths=(
        "/sdcard/DCIM"
        "/sdcard/Pictures"
        "/sdcard/Movies"
        "/sdcard/Videos"
        "/sdcard/Music"
        "/sdcard/Ringtones"
        "/sdcard/Podcasts"
        "/sdcard/Audiobooks"
        "/sdcard/Documents"
        "/sdcard/Download"
        "/sdcard/WhatsApp"
        "/sdcard/Telegram"
    )

    local total_pulled=0
    local failed_paths=()

    for remote_path in "${paths[@]}"; do
        # Check if path exists on device
        local exists
        exists=$($ADB -s "$SERIAL" shell "[ -d '$remote_path' ] && echo yes" 2>/dev/null | tr -d '\r')
        [[ "$exists" != "yes" ]] && continue

        local folder_name; folder_name=$(basename "$remote_path")
        local local_dest="$media_dir/$folder_name"
        mkdir -p "$local_dest"

        printf "  ${CYAN}Pulling${ENDC} %-28s" "$folder_nameâ€¦"
        $ADB -s "$SERIAL" pull "$remote_path/." "$local_dest/" >/dev/null 2>&1
        local status=$?
        local count; count=$(find "$local_dest" -type f 2>/dev/null | wc -l)
        if [[ $status -eq 0 || $count -gt 0 ]]; then
            echo -e " ${GREEN}âœ“${ENDC} $count file(s)  (${MAGENTA}$(_sz "$local_dest")${ENDC})"
            total_pulled=$((total_pulled + count))
        else
            echo -e " ${YELLOW}âš  skipped (empty or no access)${ENDC}"
        fi
    done

    echo -e "\n  ${BOLD}Total media files pulled: ${GREEN}$total_pulled${ENDC}"
    echo -e "  ${BOLD}Media backup size:        ${MAGENTA}$(_sz "$media_dir")${ENDC}"
}

# â”€â”€ APK backup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_apps() {
    _bsec "Installed Apps (APKs)"
    local apk_dir="$BACKUP_DIR/apks"
    mkdir -p "$apk_dir"

    echo -e "  ${YELLOW}Fetching installed third-party packagesâ€¦${ENDC}"
    local packages
    packages=$($ADB -s "$SERIAL" shell pm list packages -3 2>/dev/null | sed 's/package://' | tr -d '\r')

    local total=0 failed=0
    while IFS= read -r pkg; do
        [[ -z "$pkg" ]] && continue
        # Get APK path on device
        local apk_path
        apk_path=$($ADB -s "$SERIAL" shell pm path "$pkg" 2>/dev/null | sed 's/package://' | tr -d '\r ')
        if [[ -z "$apk_path" ]]; then
            ((failed++)); continue
        fi
        local apk_name="${pkg}.apk"
        $ADB -s "$SERIAL" pull "$apk_path" "$apk_dir/$apk_name" >/dev/null 2>&1
        if [[ -f "$apk_dir/$apk_name" ]]; then
            printf "  ${GREEN}âœ“${ENDC} %-55s %s\n" "$pkg" "$(_sz "$apk_dir/$apk_name")"
            ((total++))
        else
            ((failed++))
        fi
    done <<< "$packages"

    echo -e "\n  ${BOLD}APKs backed up: ${GREEN}$total${ENDC}  ${YELLOW}Failed: $failed${ENDC}"
    echo -e "  ${BOLD}APK dir size:   ${MAGENTA}$(_sz "$apk_dir")${ENDC}"
}

# â”€â”€ Full ADB backup (everything) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
backup_full_adb() {
    _bsec "Full ADB System Backup (.ab archive)"
    local out="$BACKUP_DIR/full_backup_$(date +%Y%m%d_%H%M%S).ab"
    echo -e "  ${YELLOW}âš  You MUST accept the backup prompt on your device screen!${ENDC}"
    echo -e "  ${YELLOW}  Leave password blank unless you want encryption.${ENDC}\n"
    sleep 2
    $ADB -s "$SERIAL" backup -apk -shared -all -system -f "$out"
    if [[ -f "$out" && -s "$out" ]]; then
        echo -e "\n  ${GREEN}âœ“ Full backup saved (${MAGENTA}$(_sz "$out")${GREEN}) â†’ $(basename "$out")${ENDC}"
        echo -e "  ${CYAN}Restore later with:${ENDC} adb restore \"$out\""
    else
        echo -e "\n  ${RED}âœ— Full ADB backup failed or was cancelled on device.${ENDC}"
    fi
}

# â”€â”€ Backup summary / manifest â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_backup_manifest() {
    local manifest="$BACKUP_DIR/BACKUP_MANIFEST.txt"
    {
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  droidB Full Backup â€” $(date)"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Device Serial : $SERIAL"
        echo "Device Model  : $(echo "$DEVICE_INFO" | grep -oP 'model=\K[^ ]+' || echo 'Unknown')"
        echo "Android Ver   : $($ADB -s "$SERIAL" shell getprop ro.build.version.release 2>/dev/null | tr -d '\r')"
        echo "SDK Level     : $($ADB -s "$SERIAL" shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r')"
        echo "Build         : $($ADB -s "$SERIAL" shell getprop ro.build.display.id 2>/dev/null | tr -d '\r')"
        echo "IMEI          : $($ADB -s "$SERIAL" shell service call iphonesubinfo 1 2>/dev/null | grep -oP "'\K[^']+" | tr -d '.' | head -1 || echo 'N/A')"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo "Backup Location: $BACKUP_DIR"
        echo "Total Size     : $(_sz "$BACKUP_DIR")"
        echo ""
        echo "Contents:"
        find "$BACKUP_DIR" -maxdepth 3 -not -name "BACKUP_MANIFEST.txt" \
            | sed 's|'"$BACKUP_DIR"'/||' | sort
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    } > "$manifest"
    echo -e "\n  ${CYAN}Manifest written â†’ BACKUP_MANIFEST.txt${ENDC}"
}

# â”€â”€ Pre-flash backup wizard (shown before flash operations) â”€â”€
pre_flash_backup_check() {
    echo -e "\n${BOLD}${RED}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${ENDC}"
    echo -e "${BOLD}${RED}â•‘   âš   PRE-FLASH SAFETY CHECK â€” BACKUP FIRST!   â•‘${ENDC}"
    echo -e "${BOLD}${RED}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"
    echo -e "${YELLOW}Flashing will ERASE all data on the device."
    echo -e "It is strongly recommended to create a full backup first.${ENDC}\n"
    echo "  1. Create Full Backup now (recommended)"
    echo "  2. Skip â€” I already have a backup"
    echo "  3. Cancel flash operation"
    read -rp "Choice [1-3]: " pre_choice
    case $pre_choice in
        1) full_backup_menu; return 0 ;;
        2) echo -e "${YELLOW}Proceeding without backup â€” you accepted the risk.${ENDC}"; return 0 ;;
        3) return 1 ;;
        *) echo -e "${RED}Invalid choice. Returning to menu.${ENDC}"; return 1 ;;
    esac
}

# â”€â”€ Main backup menu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
full_backup_menu() {
    if [[ -z "$SERIAL" ]]; then
        echo -e "${RED}âœ— No device connected. Connect your device and enable USB Debugging.${ENDC}"
        sleep 3; return
    fi

    while true; do
        clear_screen
        display_banner
        _bsec "Full Device Backup"
        echo -e "  Device: ${GREEN}$(echo "$DEVICE_INFO" | grep -oP 'model=\K[^ ]+' || echo 'Unknown')${ENDC}  Serial: ${CYAN}$SERIAL${ENDC}"
        echo ""
        echo "  1. ğŸ—‚  Full Backup (All categories below â€” RECOMMENDED)"
        echo "  2. ğŸ’¬  SMS & MMS Messages"
        echo "  3. ğŸ‘¥  Contacts (VCF / DB)"
        echo "  4. ğŸ“  Call Logs (CSV)"
        echo "  5. ğŸ–¼  Media Files (Photos, Videos, Audio, Docs)"
        echo "  6. ğŸ“¦  Installed APKs"
        echo "  7. ğŸ’¾  Full ADB System Backup (.ab file)"
        echo "  8. ğŸ“‚  Open backup folder in file manager"
        echo "  b. â† Back to Main Menu"
        echo ""
        read -rp "  Select option: " bk_choice

        # Pick destination once per session
        if [[ -z "${BACKUP_DIR:-}" || ! -d "${BACKUP_DIR:-}" ]]; then
            _backup_pick_dest || { sleep 2; continue; }
        fi

        case $bk_choice in
            1)
                echo -e "\n${BOLD}${CYAN}Starting Full Device Backupâ€¦${ENDC}"
                echo -e "${YELLOW}Keep the device unlocked and accept any prompts on screen.${ENDC}\n"
                backup_sms
                backup_contacts
                backup_call_logs
                backup_media
                backup_apps
                backup_full_adb
                _backup_manifest
                echo -e "\n${BOLD}${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"
                echo -e "${BOLD}${GREEN}  âœ“ FULL BACKUP COMPLETE${ENDC}"
                echo -e "${GREEN}  Location: $BACKUP_DIR${ENDC}"
                echo -e "${GREEN}  Total size: $(_sz "$BACKUP_DIR")${ENDC}"
                echo -e "${BOLD}${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${ENDC}"
                read -rp "  Press ENTER to continueâ€¦" _
                ;;
            2) backup_sms; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            3) backup_contacts; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            4) backup_call_logs; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            5) backup_media; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            6) backup_apps; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            7) backup_full_adb; _backup_manifest; read -rp "  Press ENTERâ€¦" _ ;;
            8)
                if [[ -n "${BACKUP_DIR:-}" && -d "$BACKUP_DIR" ]]; then
                    # Try to open in file manager
                    xdg-open "$BACKUP_DIR" 2>/dev/null || \
                    open "$BACKUP_DIR" 2>/dev/null || \
                    echo -e "  ${CYAN}Backup folder: $BACKUP_DIR${ENDC}"
                else
                    echo -e "  ${YELLOW}No backup created yet in this session.${ENDC}"
                fi
                sleep 2
                ;;
            b|B) BACKUP_DIR=""; return ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"; sleep 1 ;;
        esac
    done
}

main_menu() {
    while true; do
        clear_screen
        display_banner
        
        get_device_info 2>/dev/null
        
        if [[ -n "$DEVICE_INFO" ]]; then
            STATE=$(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+' || echo 'Unknown')
            MODEL=$(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+' || echo 'Unknown')
            echo -e "${GREEN}Device: $MODEL ($STATE)${ENDC}"
        else
            echo -e "${YELLOW}No device connected${ENDC}"
        fi
        
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        echo -e "${BOLD}Main Menu:${ENDC}"
        echo "  1. Device Information"
        echo "  2. Universal Debloater ğŸ—‘ï¸"
        echo "  3. App Management"
        echo "  4. File Operations"
        echo "  5. System Operations"
        echo "  6. Fastboot Operations"
        echo "  7. Samsung Operations ğŸ“±"
        echo "  8. ğŸ’¾ Full Device Backup (SMS, Contacts, Media, APKs)"
        echo "  9. Install System-Wide"
        echo "  q. Exit"
        echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${ENDC}"
        
        read -p "Select option: " choice
        
        case $choice in
            1) display_device_info ;;
            2) [[ -n "$SERIAL" ]] && universal_debloater_menu || { echo -e "${RED}No device${ENDC}"; sleep 2; } ;;
            3) app_management_menu ;;
            4) file_operations_menu ;;
            5) system_operations_menu ;;
            6) fastboot_operations_menu ;;
            7) samsung_operations_menu ;;
            8) [[ -n "$SERIAL" ]] && full_backup_menu || { echo -e "${RED}No device connected${ENDC}"; sleep 2; } ;;
            9) install_systemwide ;;
            q|Q) exit 0 ;;
            *)
                echo -e "${RED}Invalid option${ENDC}"
                sleep 1
                ;;
        esac
    done
}

cleanup() {
    rm -f "$DEBLOAT_LIST_FILE" 2>/dev/null
}

trap cleanup EXIT

main() {
    parse_arguments "$@"
    check_requirements
    main_menu
}

main "$@"
