#!/usr/bin/env python3
"""
Pydroidb: A comprehensive ADB and Fastboot automation tool.

This script provides a safe and user-friendly command-line interface
for a wide range of Android device management tasks.

Author: 0xbv1 | 0xb0rn3
GitHub: https://github.com/0xb0rn3/pydroidb
"""

import subprocess
import os
import sys
import time
import platform
from pathlib import Path
from typing import List, Optional, Tuple
from dataclasses import dataclass

# --- UI and Color Definitions ---

def clear_screen():
    """Clears the console screen."""
    os.system('cls' if os.name == 'nt' else 'clear')

class Colors:
    """ANSI color codes for console output."""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def display_banner():
    """Displays the tool's startup banner and information."""
    banner = f"""
{Colors.BOLD}{Colors.BLUE}
██████╗ ██╗   ██╗██████╗  ██████╗ ██╗ ██████╗ ██████╗
██╔══██╗╚██╗ ██╔╝██╔══██╗██╔═══██╗██║██╔═══██╗██╔══██╗
██████╔╝ ╚████╔╝ ██████╔╝██║   ██║██║██║   ██║██████╔╝
██╔═══╝   ╚██╔╝  ██╔══██╗██║   ██║██║██║   ██║██╔══██╗
██║        ██║   ██████╔╝╚██████╔╝██║╚██████╔╝██████╔╝
╚═╝        ╚═╝   ╚═════╝  ╚═════╝ ╚═╝ ╚═════╝ ╚═════╝
{Colors.ENDC}
{Colors.BOLD}A comprehensive ADB automation tool for Android device management{Colors.ENDC}
            {Colors.YELLOW}Made with ❤️ by 0xbv1 | 0xb0rn3{Colors.ENDC}
    """
    warning = f"""
{Colors.BOLD}{Colors.RED}============================[ IMPORTANT SAFETY WARNING ]============================{Colors.ENDC}
{Colors.YELLOW}
- This tool deals with device firmware and can cause permanent damage if used incorrectly.
- Always back up your data and have official recovery images for your device model.
- The author is not responsible for any damage to your device. {Colors.BOLD}USE AT YOUR OWN RISK.{Colors.ENDC}
{Colors.BOLD}{Colors.RED}=================================================================================={Colors.ENDC}
    """
    print(banner)
    print(warning)
    input(f"{Colors.YELLOW}Press Enter to continue...{Colors.ENDC}")


@dataclass
class DeviceInfo:
    """Stores comprehensive device information for safety checks."""
    serial: str
    model: str
    android_version: str
    sdk_version: str
    bootloader_version: str
    state: str  # device, recovery, fastboot, unauthorized, etc.

class ADBAutomationTool:
    """
    Comprehensive ADB automation tool with enhanced safety features.
    
    This class provides a safe, user-friendly interface to ADB and Fastboot
    commands with built-in safety checks and error handling.
    """
    
    def __init__(self):
        self.device_info: Optional[DeviceInfo] = None
        self.adb_path = self._find_executable('adb')
        self.fastboot_path = self._find_executable('fastboot')
        
        self.critical_partitions = {
            'boot', 'system', 'recovery', 'bootloader', 'radio',
            'vendor', 'userdata', 'cache', 'misc', 'persist', 'vbmeta'
        }

    def _find_executable(self, name: str) -> str:
        """
        Locate an executable in system PATH or common SDK locations.
        
        Args:
            name: The name of the executable (e.g., 'adb', 'fastboot').
            
        Returns:
            The full path to the executable.
            
        Raises:
            FileNotFoundError: If the executable cannot be found.
        """
        # 1. Check if it's in the system PATH
        try:
            result = subprocess.run(['which' if platform.system() != 'Windows' else 'where', name], capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip().split('\n')[0]
        except FileNotFoundError:
            pass
            
        # 2. Check common manual installation paths
        home = Path.home()
        common_paths = [
            home / 'Android/Sdk/platform-tools',
            home / 'Library/Android/sdk/platform-tools',  # macOS
            Path('/usr/local/bin'),
            Path('/usr/bin'),
            home / 'AppData/Local/Android/sdk/platform-tools' # Windows
        ]
        
        for path in common_paths:
            executable_path = path / (name + ('.exe' if platform.system() == 'Windows' else ''))
            if executable_path.exists():
                return str(executable_path)
        
        raise FileNotFoundError(
            f"{name.upper()} not found. Please install Android SDK Platform-Tools and ensure it's in your system's PATH."
        )

    def run_command(self, command: List[str], timeout: int = 60) -> Tuple[bool, str, str]:
        """
        Execute a command with proper error handling and colored output.
        """
        try:
            print(f"{Colors.BLUE}Executing: {' '.join(command)}{Colors.ENDC}")
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout,
                check=False
            )
            success = result.returncode == 0
            if not success:
                 print(f"{Colors.RED}Error: {result.stderr.strip()}{Colors.ENDC}")
            return success, result.stdout.strip(), result.stderr.strip()
            
        except subprocess.TimeoutExpired:
            return False, "", f"Command timed out after {timeout} seconds."
        except Exception as e:
            return False, "", f"Command failed with an unexpected error: {e}"

    def get_device_info(self) -> Optional[DeviceInfo]:
        """
        Retrieve comprehensive information for a selected device.
        Handles device selection if multiple devices are connected.
        """
        success, stdout, _ = self.run_command([self.adb_path, 'devices'])
        if not success:
            return None

        lines = stdout.strip().split('\n')[1:]
        connected_devices = [tuple(line.split('\t')) for line in lines if '\t' in line]

        if not connected_devices:
            self.device_info = None
            return None

        if len(connected_devices) > 1:
            print(f"\n{Colors.YELLOW}Multiple devices connected:{Colors.ENDC}")
            for i, (serial, state) in enumerate(connected_devices):
                print(f"{i + 1}. {serial} ({state})")
            
            while True:
                try:
                    choice = int(input("Select device (number): ")) - 1
                    if 0 <= choice < len(connected_devices):
                        serial, state = connected_devices[choice]
                        break
                    else:
                        print(f"{Colors.RED}Invalid selection.{Colors.ENDC}")
                except ValueError:
                    print(f"{Colors.RED}Please enter a number.{Colors.ENDC}")
        else:
            serial, state = connected_devices[0]

        if state == 'unauthorized':
            print(f"\n{Colors.BOLD}{Colors.RED}Device {serial} is unauthorized.{Colors.ENDC}")
            print(f"{Colors.YELLOW}Please check your device screen and allow USB debugging.{Colors.ENDC}")
            self.device_info = DeviceInfo(serial, "Unknown", "Unknown", "Unknown", "Unknown", state)
            return self.device_info

        props = {}
        prop_commands = {
            'model': 'ro.product.model',
            'android_version': 'ro.build.version.release',
            'sdk_version': 'ro.build.version.sdk',
            'bootloader_version': 'ro.bootloader'
        }
        
        for key, prop in prop_commands.items():
            _, stdout, _ = self.run_command([self.adb_path, '-s', serial, 'shell', 'getprop', prop])
            props[key] = stdout or "Unknown"

        self.device_info = DeviceInfo(
            serial=serial,
            model=props['model'],
            android_version=props['android_version'],
            sdk_version=props['sdk_version'],
            bootloader_version=props['bootloader_version'],
            state=state
        )
        return self.device_info

    def display_device_info(self):
        """Display current device information in a formatted way."""
        clear_screen()
        if not self.device_info:
            print(f"{Colors.YELLOW}No device information available. Please connect a device.{Colors.ENDC}")
            return
        
        print("\n" + "="*50)
        print(f"{Colors.BOLD}{Colors.GREEN}CONNECTED DEVICE INFORMATION{Colors.ENDC}")
        print("="*50)
        print(f"{Colors.BOLD}Serial:{Colors.ENDC}           {self.device_info.serial}")
        print(f"{Colors.BOLD}Model:{Colors.ENDC}            {self.device_info.model}")
        print(f"{Colors.BOLD}Android Version:{Colors.ENDC}  {self.device_info.android_version}")
        print(f"{Colors.BOLD}SDK Version:{Colors.ENDC}      {self.device_info.sdk_version}")
        print(f"{Colors.BOLD}Bootloader:{Colors.ENDC}       {self.device_info.bootloader_version}")
        print(f"{Colors.BOLD}State:{Colors.ENDC}            {self.device_info.state}")
        print("="*50 + "\n")
        input(f"{Colors.YELLOW}Press Enter to return to the menu...{Colors.ENDC}")

    def confirm_action(self, message: str) -> bool:
        """Get user confirmation for potentially dangerous actions."""
        prompt = f"\n{Colors.BOLD}{Colors.YELLOW}CONFIRMATION:{Colors.ENDC} {message} (y/N): "
        while True:
            response = input(prompt).strip().lower()
            if response in ['y', 'yes']:
                return True
            elif response in ['n', 'no', '']:
                print(f"{Colors.RED}Operation cancelled.{Colors.ENDC}")
                return False
            else:
                print(f"{Colors.RED}Invalid input. Please enter 'y' or 'n'.{Colors.ENDC}")

    # --- File Operations ---
    def file_operations_menu(self):
        """Menu for file transfer and app management operations."""
        menu_options = {
            '1': ('Push File to Device', self.push_file),
            '2': ('Pull File from Device', self.pull_file),
            '3': ('Batch Push Directory to Device', self.batch_push),
            '4': ('Batch Pull Directory from Device', self.batch_pull),
            '5': ('Install APK', self.install_apk),
            '6': ('Uninstall Package', self.uninstall_package),
            '7': ('List Installed Packages', self.list_packages),
            '8': ('List Device Directory', self.list_device_directory),
            '9': ('Back to Main Menu', None)
        }
        self._run_menu("📁 FILE OPERATIONS", menu_options)

    def push_file(self):
        """Push a single file to the device."""
        local_path = input("Enter local file path: ").strip()
        if not Path(local_path).exists():
            print(f"{Colors.RED}Local file does not exist.{Colors.ENDC}")
            return
        remote_path = input("Enter device destination path (e.g., /sdcard/): ").strip()
        self._execute_file_transfer('push', local_path, remote_path)
    
    def pull_file(self):
        """Pull a single file from the device."""
        remote_path = input("Enter device file path: ").strip()
        local_path = input("Enter local destination path: ").strip()
        self._execute_file_transfer('pull', remote_path, local_path)

    def batch_push(self):
        """Push all files from a local directory to the device."""
        local_dir = input("Enter local directory path: ").strip()
        if not Path(local_dir).is_dir():
            print(f"{Colors.RED}Local directory does not exist.{Colors.ENDC}")
            return
        remote_dir = input("Enter device destination directory (e.g., /sdcard/): ").strip()
        
        for item in Path(local_dir).iterdir():
            if item.is_file():
                self._execute_file_transfer('push', str(item), remote_dir)
        print(f"\n{Colors.GREEN}Batch push complete.{Colors.ENDC}")

    def batch_pull(self):
        """Pull all files from a device directory to the local machine."""
        remote_dir = input("Enter device directory to pull from (e.g., /sdcard/Download/): ").strip()
        local_dir = input("Enter local destination directory: ").strip()
        Path(local_dir).mkdir(exist_ok=True)
        
        # This is a simplified pull. A full recursive pull is more complex.
        # We'll pull the files listed by 'ls -p' that are not directories.
        success, stdout, _ = self.run_command([self.adb_path, '-s', self.device_info.serial, 'shell', 'ls', '-p', remote_dir])
        if success:
            for filename in stdout.split():
                if not filename.endswith('/'): # ls -p appends / to directories
                    remote_file_path = f"{remote_dir.rstrip('/')}/{filename}"
                    self._execute_file_transfer('pull', remote_file_path, local_dir)
            print(f"\n{Colors.GREEN}Batch pull complete.{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Failed to list directory contents for batch pull.{Colors.ENDC}")

    def _execute_file_transfer(self, direction: str, source: str, dest: str):
        """Helper for executing push/pull commands."""
        command = [self.adb_path, '-s', self.device_info.serial, direction, source, dest]
        success, stdout, _ = self.run_command(command, timeout=300)
        if success:
            print(f"{Colors.GREEN}Successfully {direction}ed '{Path(source).name}'.{Colors.ENDC}")
            print(stdout)
        else:
            print(f"{Colors.RED}{direction.capitalize()} failed for '{Path(source).name}'.{Colors.ENDC}")

    def install_apk(self):
        """Install an APK file onto the device."""
        apk_path = input("Enter APK file path: ").strip()
        if not Path(apk_path).exists() or not apk_path.lower().endswith('.apk'):
            print(f"{Colors.RED}Invalid APK file path.{Colors.ENDC}")
            return
            
        command = [self.adb_path, '-s', self.device_info.serial, 'install', '-r', apk_path]
        success, stdout, _ = self.run_command(command, timeout=300)
        if success and ('Success' in stdout or 'success' in stdout):
            print(f"{Colors.GREEN}Successfully installed {Path(apk_path).name}{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Installation failed.{Colors.ENDC}")

    def uninstall_package(self):
        """Uninstall a package from the device."""
        package_name = input("Enter package name (e.g., com.example.app): ").strip()
        if not package_name: return
        
        command = [self.adb_path, '-s', self.device_info.serial, 'uninstall', package_name]
        success, stdout, _ = self.run_command(command)
        if success and 'Success' in stdout:
            print(f"{Colors.GREEN}Successfully uninstalled {package_name}{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Uninstall failed. The package may not exist.{Colors.ENDC}")
    
    def list_packages(self):
        """List all installed packages on the device."""
        command = [self.adb_path, '-s', self.device_info.serial, 'shell', 'pm', 'list', 'packages']
        success, stdout, _ = self.run_command(command)
        if success:
            packages = sorted([p.replace('package:', '') for p in stdout.split()])
            print(f"\n{Colors.GREEN}Found {len(packages)} packages:{Colors.ENDC}")
            print("-" * 60)
            for pkg in packages:
                print(pkg)
            print("-" * 60)
        else:
            print(f"{Colors.RED}Failed to list packages.{Colors.ENDC}")

    def list_device_directory(self):
        """List contents of a directory on the device."""
        directory = input("Enter device directory path (default: /sdcard/): ").strip() or "/sdcard/"
        command = [self.adb_path, '-s', self.device_info.serial, 'shell', 'ls', '-la', directory]
        success, stdout, _ = self.run_command(command)
        if success:
            print(f"\n{Colors.GREEN}Contents of {directory}:{Colors.ENDC}")
            print("-" * 60)
            print(stdout)
            print("-" * 60)
        else:
            print(f"{Colors.RED}Failed to list directory contents.{Colors.ENDC}")


    # --- Fastboot Operations ---
    def fastboot_menu(self):
        """Menu for dangerous Fastboot operations."""
        clear_screen()
        print(f"\n{Colors.BOLD}{Colors.RED}{'='*60}")
        print("         ⚠️  FASTBOOT MODE - EXTREME CAUTION REQUIRED ⚠️")
        print(f"{'='*60}{Colors.ENDC}")
        print(f"{Colors.YELLOW}Fastboot operations modify critical system partitions.")
        print("Incorrect usage can permanently brick your device!")
        print("Ensure you have the correct files for your specific device model.{Colors.ENDC}")
        
        if not self.confirm_action("Do you understand the risks and want to continue?"):
            return
            
        menu_options = {
            '1': ('Flash Partition', self.fastboot_flash),
            '2': ('Erase Partition', self.fastboot_erase),
            '3': ('Unlock Bootloader (Erases Data)', self.fastboot_unlock),
            '4': ('Lock Bootloader', self.fastboot_lock),
            '5': ('Reboot from Fastboot', self.fastboot_reboot),
            '6': ('Check Fastboot Devices', self.fastboot_devices),
            '7': ('Back to Main Menu', None)
        }
        self._run_menu("🔥 FASTBOOT OPERATIONS", menu_options)

    def fastboot_flash(self):
        """Flash a partition with an image file, with extensive safety checks."""
        partition = input("Enter partition name (e.g., boot, recovery, system): ").strip().lower()
        if not partition: return
        
        image_path = input("Enter image file path: ").strip()
        if not Path(image_path).exists():
            print(f"{Colors.RED}Image file does not exist.{Colors.ENDC}")
            return
            
        print(f"\n{Colors.BOLD}{Colors.RED}{'⚠️'*20}\nCRITICAL WARNING: PARTITION FLASHING\n{'⚠️'*20}{Colors.ENDC}")
        print(f"You are about to flash the file '{Path(image_path).name}' to the '{partition}' partition.")
        
        if partition in self.critical_partitions:
            print(f"{Colors.YELLOW}'{partition}' is a critical partition. A wrong image WILL brick your device.{Colors.ENDC}")

        if not self.confirm_action(f"Are you ABSOLUTELY SURE you want to flash '{partition}'?"):
            return
            
        if not self.confirm_action("FINAL CONFIRMATION. There is no going back. Proceed?"):
            return

        command = [self.fastboot_path, 'flash', partition, image_path]
        success, stdout, stderr = self.run_command(command, timeout=600)
        output = stdout + stderr
        if success:
            print(f"{Colors.GREEN}Flash successful!\n{output}{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Flash failed!\n{output}{Colors.ENDC}")

    def fastboot_erase(self):
        """Erase a partition, with safety checks."""
        partition = input("Enter partition name to ERASE (e.g., userdata, cache): ").strip().lower()
        if not partition: return

        print(f"\n{Colors.BOLD}{Colors.RED}{'⚠️'*20}\nCRITICAL WARNING: PARTITION ERASE\n{'⚠️'*20}{Colors.ENDC}")
        print(f"You are about to PERMANENTLY ERASE the '{partition}' partition. This is IRREVERSIBLE.")

        if partition in self.critical_partitions and partition != 'userdata' and partition != 'cache':
            print(f"{Colors.YELLOW}Erasing the critical partition '{partition}' will likely brick your device.{Colors.ENDC}")

        if not self.confirm_action(f"Are you sure you want to erase '{partition}'?"):
            return

        command = [self.fastboot_path, 'erase', partition]
        success, stdout, stderr = self.run_command(command)
        output = stdout + stderr
        if success:
            print(f"{Colors.GREEN}Erase successful!\n{output}{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Erase failed!\n{output}{Colors.ENDC}")

    def fastboot_unlock(self):
        """Unlock the device bootloader."""
        print(f"\n{Colors.BOLD}{Colors.RED}Unlocking the bootloader WILL WIPE ALL DATA on your device.{Colors.ENDC}")
        if not self.confirm_action("Do you want to proceed with unlocking?"):
            return
        
        # NOTE: The command can vary. 'flashing unlock' is standard, but some OEMs use 'oem unlock'.
        command = [self.fastboot_path, 'flashing', 'unlock']
        success, stdout, stderr = self.run_command(command)
        output = stdout + stderr
        if success:
            print(f"{Colors.GREEN}Unlock command sent. Please check your device screen to confirm.{Colors.ENDC}\n{output}")
        else:
            print(f"{Colors.RED}Unlock command failed. Your device might use a different command (e.g., 'fastboot oem unlock').{Colors.ENDC}\n{output}")

    def fastboot_lock(self):
        """Lock the device bootloader."""
        print(f"\n{Colors.BOLD}{Colors.YELLOW}Locking the bootloader is for returning to a factory state.")
        print(f"{Colors.RED}If you have custom software installed, this might BRICK your device.{Colors.ENDC}")
        if not self.confirm_action("Do you want to proceed with locking?"):
            return

        command = [self.fastboot_path, 'flashing', 'lock']
        success, stdout, stderr = self.run_command(command)
        output = stdout + stderr
        if success:
            print(f"{Colors.GREEN}Lock command sent. Please check your device screen.{Colors.ENDC}\n{output}")
        else:
            print(f"{Colors.RED}Lock command failed.{Colors.ENDC}\n{output}")

    def fastboot_reboot(self):
        """Reboot the device from Fastboot mode."""
        reboot_options = {
            '1': ('Reboot to System', [self.fastboot_path, 'reboot']),
            '2': ('Reboot to Bootloader', [self.fastboot_path, 'reboot-bootloader']),
            '3': ('Reboot to Recovery', [self.fastboot_path, 'reboot', 'recovery']),
            '4': ('Cancel', None)
        }
        
        clear_screen()
        print(f"\n{Colors.BOLD}{Colors.GREEN}Fastboot Reboot Options{Colors.ENDC}")
        for key, (desc, _) in reboot_options.items():
            print(f"{key}. {desc}")
        
        choice = input("\nSelect option: ").strip()
        if choice in reboot_options and reboot_options[choice][1]:
            self.run_command(reboot_options[choice][1])
            print(f"{Colors.GREEN}Reboot command sent.{Colors.ENDC}")

    def fastboot_devices(self):
        """List devices currently in Fastboot mode."""
        success, stdout, _ = self.run_command([self.fastboot_path, 'devices'])
        if success:
            print(f"\n{Colors.GREEN}Fastboot devices:{Colors.ENDC}")
            print("-" * 30)
            if stdout:
                print(stdout)
            else:
                print("No devices in fastboot mode found.")
            print("-" * 30)

    # --- System Operations ---
    def system_operations_menu(self):
        menu_options = {
            '1': ('Reboot Device', self.reboot_device),
            '2': ('Reboot to Recovery', lambda: self.reboot_device('recovery')),
            '3': ('Reboot to Bootloader', lambda: self.reboot_device('bootloader')),
            '4': ('Take Screenshot', self.take_screenshot),
            '5': ('Screen Recording', self.screen_recording),
            '6': ('View Device Logs (Logcat)', self.logcat),
            '7': ('Interactive Shell Access', self.shell_access),
            '8': ('Back to Main Menu', None)
        }
        self._run_menu("⚙️ SYSTEM OPERATIONS", menu_options)

    def reboot_device(self, mode: str = ''):
        """Reboot the device, with optional mode (recovery, bootloader)."""
        if not self.confirm_action(f"Are you sure you want to reboot to '{mode or 'system'}'?"):
            return
        command = [self.adb_path, '-s', self.device_info.serial, 'reboot', mode]
        success, _, _ = self.run_command(command)
        if success:
            print(f"{Colors.GREEN}Reboot command sent successfully.{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Reboot command failed.{Colors.ENDC}")

    def take_screenshot(self):
        """Take a screenshot and pull it to the local machine."""
        timestamp = int(time.time())
        filename = f"screenshot_{timestamp}.png"
        device_path = f"/sdcard/{filename}"
        
        success, _, _ = self.run_command([self.adb_path, '-s', self.device_info.serial, 'shell', 'screencap', device_path])
        if success:
            self._execute_file_transfer('pull', device_path, '.')
            # Clean up the file from the device
            self.run_command([self.adb_path, '-s', self.device_info.serial, 'shell', 'rm', device_path])
        else:
            print(f"{Colors.RED}Failed to take screenshot on device.{Colors.ENDC}")
    
    def screen_recording(self):
        """Record the device screen."""
        try:
            duration = int(input("Enter recording duration in seconds (1-180, default 30): ").strip() or "30")
            if not 1 <= duration <= 180:
                raise ValueError
        except ValueError:
            print(f"{Colors.RED}Invalid duration. Please enter a number between 1 and 180.{Colors.ENDC}")
            return
            
        timestamp = int(time.time())
        filename = f"screenrecord_{timestamp}.mp4"
        device_path = f"/sdcard/{filename}"
        
        print(f"{Colors.YELLOW}Starting {duration}s screen recording... Press Ctrl+C to stop early.{Colors.ENDC}")
        
        record_command = [
            self.adb_path, '-s', self.device_info.serial, 'shell',
            'screenrecord', f'--time-limit={duration}', device_path
        ]

        try:
            self.run_command(record_command, timeout=duration + 10)
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Recording stopped by user.{Colors.ENDC}")
        finally:
            print(f"{Colors.YELLOW}Pulling video file...{Colors.ENDC}")
            self._execute_file_transfer('pull', device_path, '.')
            self.run_command([self.adb_path, '-s', self.device_info.serial, 'shell', 'rm', device_path])

    def logcat(self):
        """View device logs in real-time."""
        print(f"\n{Colors.YELLOW}Starting real-time log monitoring... Press Ctrl+C to stop.{Colors.ENDC}")
        try:
            process = subprocess.Popen([self.adb_path, '-s', self.device_info.serial, 'logcat'])
            process.wait()
        except KeyboardInterrupt:
            print(f"\n{Colors.GREEN}Logcat stopped.{Colors.ENDC}")
        finally:
            if 'process' in locals() and process.poll() is None:
                process.terminate()

    def shell_access(self):
        """Provide an interactive shell to the device."""
        print(f"\n{Colors.YELLOW}Starting interactive shell... Type 'exit' or press Ctrl+D to quit.{Colors.ENDC}")
        print("-" * 50)
        subprocess.run([self.adb_path, '-s', self.device_info.serial, 'shell'])
        print("-" * 50)
        print(f"{Colors.GREEN}Shell session ended.{Colors.ENDC}")

    # --- Main Menu Logic ---
    
    def _run_menu(self, title: str, options: dict):
        """Generic function to display and handle a menu."""
        while True:
            clear_screen()
            print(f"\n{Colors.BOLD}{Colors.GREEN}{title}{Colors.ENDC}")
            print("-" * 40)
            for key, (desc, _) in options.items():
                print(f"{Colors.YELLOW}{key}{Colors.ENDC}. {desc}")
            print("-" * 40)
            
            choice = input("Select option: ").strip()
            
            if choice in options:
                desc, func = options[choice]
                if func is None: # Exit option
                    break
                clear_screen()
                print(f"{Colors.HEADER}--- {desc} ---{Colors.ENDC}")
                func()
                input(f"\n{Colors.YELLOW}Press Enter to return to the menu...{Colors.ENDC}")
            else:
                print(f"{Colors.RED}Invalid choice. Please try again.{Colors.ENDC}")
                time.sleep(1)

    def main_menu(self):
        """The main application menu."""
        while True:
            clear_screen()
            print("\n" + "="*60)
            print(f"{Colors.BOLD}{Colors.BLUE}PYDROIDB MAIN MENU{Colors.ENDC}")
            print("="*60)

            if not self.device_info:
                print(f"\n{Colors.YELLOW}Searching for devices...{Colors.ENDC}")
                self.get_device_info()

            if self.device_info:
                state_color = Colors.GREEN if self.device_info.state == 'device' else Colors.RED
                print(f"Connected Device: {Colors.BOLD}{self.device_info.model}{Colors.ENDC} ({state_color}{self.device_info.state}{Colors.ENDC})")
            else:
                print(f"\n{Colors.BOLD}{Colors.RED}⚠️ No device connected.{Colors.ENDC}")
                print(f"{Colors.YELLOW}Please connect an Android device with USB debugging enabled.{Colors.ENDC}")
            
            print("="*60)

            menu_options = {
                '1': 'Device Information',
                '2': 'File Operations',
                '3': 'System Operations',
                '4': 'Fastboot Operations (DANGEROUS)',
                '5': 'Refresh Device List',
                '6': 'Exit'
            }

            for key, desc in menu_options.items():
                 print(f"{Colors.YELLOW}{key}{Colors.ENDC}. {desc}")

            choice = input("\nSelect option: ").strip()

            if choice == '1':
                if self.device_info: self.display_device_info()
            elif choice == '2':
                if self.device_info and self.device_info.state == 'device': self.file_operations_menu()
            elif choice == '3':
                if self.device_info and self.device_info.state == 'device': self.system_operations_menu()
            elif choice == '4':
                self.fastboot_menu()
            elif choice == '5':
                self.device_info = None # Force a refresh on the next loop
            elif choice == '6':
                print(f"{Colors.BOLD}{Colors.BLUE}Goodbye!{Colors.ENDC}")
                break
            else:
                print(f"{Colors.RED}Invalid choice. Please try again.{Colors.ENDC}")
                time.sleep(1)


def main():
    """Main application entry point."""
    try:
        clear_screen()
        display_banner()
        tool = ADBAutomationTool()
        tool.main_menu()
    
    except FileNotFoundError as e:
        print(f"\n{Colors.BOLD}{Colors.RED}FATAL ERROR: {e}{Colors.ENDC}")
        print("\nPlease install Android SDK Platform Tools from:")
        print("https://developer.android.com/studio/releases/platform-tools")
        print("Then, add the extracted directory to your system's PATH variable.")
    
    except KeyboardInterrupt:
        print(f"\n\n{Colors.YELLOW}Tool interrupted by user. Goodbye!{Colors.ENDC}")
    
    except Exception as e:
        print(f"\n{Colors.BOLD}{Colors.RED}An unexpected error occurred: {e}{Colors.ENDC}")
        print("Please report this issue on GitHub with the error details.")

if __name__ == "__main__":
    main()
