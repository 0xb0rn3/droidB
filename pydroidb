#!/usr/bin/env bash

VERSION="0.1.0"
BLUE='\033[94m'
GREEN='\033[92m'
RED='\033[91m'
YELLOW='\033[93m'
BOLD='\033[1m'
ENDC='\033[0m'

# Timeout configurations
DEFAULT_TIMEOUT=60
FILE_TIMEOUT=300
BACKUP_TIMEOUT=3600
FASTBOOT_TIMEOUT=600
SAMSUNG_FLASH_TIMEOUT=1800
SAMSUNG_PIT_TIMEOUT=300
SAMSUNG_NAND_TIMEOUT=3600

# Samsung device configuration
SAMSUNG_VENDOR_ID="04e8"
ODIN4_INSTALLED=false
HEIMDALL_INSTALLED=false

clear_screen() {
    clear
}

display_info() {
    echo -e "${BOLD}${BLUE}Pydroidb: ADB, Fastboot & Samsung Automation Tool v${VERSION}${ENDC}"
    echo -e "${GREEN}Author: 0xbv1 | 0xb0rn3${ENDC}"
    echo -e "${GREEN}GitHub: https://github.com/0xb0rn3/pydroidb${ENDC}"
    echo -e "${GREEN}Platform: $(uname -s) $(uname -m)${ENDC}"
    echo -e "${YELLOW}Samsung Support: Odin4 + Heimdall Integrated${ENDC}"
    echo -e "${RED}${BOLD}============================[ SAFETY WARNING ]============================${ENDC}"
    echo -e "${RED}This tool modifies device firmware and can cause permanent damage if used incorrectly.${ENDC}"
    echo -e "${RED}Samsung operations may void warranty and trigger Knox security features.${ENDC}"
    echo -e "${RED}Always back up data and have official recovery images. USE AT YOUR OWN RISK.${ENDC}"
    echo -e "${RED}${BOLD}=========================================================================${ENDC}"
    read -p "Press Enter to continue..."
}

install_dependencies() {
    echo -e "${BLUE}Installing core dependencies...${ENDC}"
    
    if [[ -f /etc/debian_version ]]; then
        INSTALL_CMD="sudo apt update && sudo apt install -y"
        PACKAGES="android-tools-adb android-tools-fastboot curl unzip wget libusb-1.0-0 libusb-1.0-0-dev"
    elif [[ -f /etc/redhat-release ]]; then
        INSTALL_CMD="sudo dnf install -y"
        PACKAGES="android-tools curl unzip wget libusb libusb-devel"
    elif [[ -f /etc/arch-release ]]; then
        INSTALL_CMD="sudo pacman -S --noconfirm"
        PACKAGES="android-tools curl unzip wget libusb"
    elif [[ -f /etc/SuSE-release ]]; then
        INSTALL_CMD="sudo zypper install -y"
        PACKAGES="android-tools curl unzip wget libusb-1_0-0 libusb-1_0-devel"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v brew &>/dev/null; then
            INSTALL_CMD="brew install"
            PACKAGES="android-platform-tools curl wget libusb"
        else
            echo -e "${RED}Homebrew required. Install from https://brew.sh${ENDC}"
            return 1
        fi
    else
        echo -e "${RED}Unsupported OS for automatic installation.${ENDC}"
        return 1
    fi
    
    $INSTALL_CMD $PACKAGES
}

setup_samsung_drivers() {
    if [[ "$OSTYPE" != "linux-gnu"* ]]; then
        echo -e "${YELLOW}Samsung drivers setup is Linux-specific.${ENDC}"
        return 0
    fi
    
    echo -e "${BLUE}Setting up Samsung device drivers...${ENDC}"
    
    # Create udev rules for Samsung devices
    UDEV_FILE="/etc/udev/rules.d/51-android-samsung.rules"
    if [[ ! -f "$UDEV_FILE" ]] || ! grep -q "04e8" "$UDEV_FILE"; then
        echo -e "${BLUE}Creating Samsung udev rules...${ENDC}"
        sudo tee "$UDEV_FILE" > /dev/null << 'EOF'
# Samsung devices
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", MODE="0666", GROUP="plugdev"
# Samsung download mode
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="685d", MODE="0666", GROUP="plugdev"
# Samsung mobile devices
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="6860", MODE="0666", GROUP="plugdev"
# Samsung composite devices
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="6864", MODE="0666", GROUP="plugdev"
EOF
        sudo udevadm control --reload-rules
        sudo udevadm trigger
        echo -e "${GREEN}Samsung udev rules created.${ENDC}"
    fi
    
    # Add user to plugdev group
    if ! groups $USER | grep -q plugdev; then
        echo -e "${BLUE}Adding user to plugdev group...${ENDC}"
        sudo usermod -a -G plugdev $USER
        echo -e "${YELLOW}Please log out and log back in for group changes to take effect.${ENDC}"
    fi
}

install_odin4() {
    if [[ "$OSTYPE" != "linux-gnu"* ]]; then
        echo -e "${YELLOW}Odin4 is only available for Linux.${ENDC}"
        return 1
    fi
    
    if command -v odin4 &>/dev/null; then
        echo -e "${GREEN}Odin4 already installed.${ENDC}"
        ODIN4_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Odin4Linux...${ENDC}"
    echo -e "${YELLOW}Note: This requires manual download from GitHub releases${ENDC}"
    echo -e "${YELLOW}Visit: https://github.com/amo13/Odin4/releases${ENDC}"
    
    read -p "Have you downloaded Odin4 Linux binary? (y/N): " DOWNLOADED
    if [[ ! "$DOWNLOADED" =~ ^[Yy] ]]; then
        echo -e "${YELLOW}Please download Odin4 Linux binary and retry.${ENDC}"
        return 1
    fi
    
    read -p "Enter path to Odin4 binary: " ODIN4_PATH
    if [[ ! -f "$ODIN4_PATH" ]]; then
        echo -e "${RED}Odin4 binary not found: $ODIN4_PATH${ENDC}"
        return 1
    fi
    
    sudo cp "$ODIN4_PATH" /usr/local/bin/odin4
    sudo chmod +x /usr/local/bin/odin4
    
    if command -v odin4 &>/dev/null; then
        echo -e "${GREEN}Odin4 installed successfully.${ENDC}"
        ODIN4_INSTALLED=true
    else
        echo -e "${RED}Odin4 installation failed.${ENDC}"
        return 1
    fi
}

install_heimdall() {
    if command -v heimdall &>/dev/null; then
        echo -e "${GREEN}Heimdall already installed.${ENDC}"
        HEIMDALL_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Heimdall...${ENDC}"
    
    if [[ -f /etc/debian_version ]]; then
        sudo apt update && sudo apt install -y heimdall-flash heimdall-flash-frontend
    elif [[ -f /etc/redhat-release ]]; then
        sudo dnf install -y heimdall
    elif [[ -f /etc/arch-release ]]; then
        sudo pacman -S --noconfirm heimdall
    elif [[ -f /etc/SuSE-release ]]; then
        sudo zypper install -y heimdall
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v brew &>/dev/null; then
            brew install heimdall
        else
            echo -e "${RED}Homebrew required for macOS installation.${ENDC}"
            return 1
        fi
    else
        echo -e "${RED}Unsupported OS for automatic Heimdall installation.${ENDC}"
        return 1
    fi
    
    if command -v heimdall &>/dev/null; then
        echo -e "${GREEN}Heimdall installed successfully.${ENDC}"
        HEIMDALL_INSTALLED=true
    else
        echo -e "${RED}Heimdall installation failed.${ENDC}"
        return 1
    fi
}

detect_samsung_download_mode() {
    echo -e "${BLUE}Scanning for Samsung devices in download mode...${ENDC}"
    
    SAMSUNG_DEVICES=()
    
    # Try Odin4 detection first
    if [[ $ODIN4_INSTALLED == true ]]; then
        echo -e "${BLUE}Checking with Odin4...${ENDC}"
        # Note: This is a placeholder - actual Odin4 detection syntax may vary
        if sudo odin4 --detect 2>/dev/null | grep -q "Device detected"; then
            SAMSUNG_DEVICES+=("ODIN4: Samsung device detected")
        fi
    fi
    
    # Try Heimdall detection
    if [[ $HEIMDALL_INSTALLED == true ]]; then
        echo -e "${BLUE}Checking with Heimdall...${ENDC}"
        if heimdall detect 2>/dev/null | grep -q "Device detected"; then
            SAMSUNG_DEVICES+=("HEIMDALL: Samsung device detected")
        fi
    fi
    
    # Manual USB detection fallback
    if command -v lsusb &>/dev/null; then
        USB_SAMSUNG=$(lsusb 2>/dev/null | grep "04e8:")
        if [[ -n "$USB_SAMSUNG" ]]; then
            SAMSUNG_DEVICES+=("USB: $USB_SAMSUNG")
        fi
    fi
    
    if [[ ${#SAMSUNG_DEVICES[@]} -eq 0 ]]; then
        echo -e "${RED}No Samsung devices found in download mode.${ENDC}"
        echo -e "${YELLOW}To enter download mode:${ENDC}"
        echo -e "${YELLOW}1. Power off device completely${ENDC}"
        echo -e "${YELLOW}2. Hold Volume Down + Power + Home (older devices)${ENDC}"
        echo -e "${YELLOW}3. Hold Volume Down + Power (newer devices)${ENDC}"
        echo -e "${YELLOW}4. Press Volume Up when prompted${ENDC}"
        return 1
    fi
    
    echo -e "${GREEN}Found ${#SAMSUNG_DEVICES[@]} Samsung device(s):${ENDC}"
    for i in "${!SAMSUNG_DEVICES[@]}"; do
        echo -e "${GREEN}$((i+1)). ${SAMSUNG_DEVICES[i]}${ENDC}"
    done
    
    return 0
}

check_requirements() {
    echo -e "${BLUE}Checking requirements...${ENDC}"
    
    # Check for core Android tools
    if ! command -v adb &>/dev/null || ! command -v fastboot &>/dev/null; then
        echo -e "${BLUE}Installing Android SDK Platform-Tools...${ENDC}"
        install_dependencies
    else
        echo -e "${GREEN}Requirements satisfied, skipping installation.${ENDC}"
    fi
    
    ADB=$(command -v adb)
    FASTBOOT=$(command -v fastboot)
    
    if [[ -n "$ADB" && -n "$FASTBOOT" ]]; then
        ADB_VERSION=$($ADB version | head -1)
        FASTBOOT_VERSION=$($FASTBOOT --version | head -1)
        echo -e "${BLUE}ADB: $ADB_VERSION${ENDC}"
        echo -e "${BLUE}Fastboot: $FASTBOOT_VERSION${ENDC}"
        $ADB start-server &>/dev/null && echo -e "${GREEN}ADB server started.${ENDC}"
    fi
    
    # Setup Samsung support
    setup_samsung_drivers
    
    # Install Samsung tools
    echo -e "${BLUE}Setting up Samsung tools...${ENDC}"
    install_odin4
    install_heimdall
    
    # Summary
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
    echo -e "${GREEN}Tool Status Summary:${ENDC}"
    echo -e "ADB/Fastboot: ${GREEN}✓ Installed${ENDC}"
    [[ $ODIN4_INSTALLED == true ]] && echo -e "Odin4: ${GREEN}✓ Installed${ENDC}" || echo -e "Odin4: ${RED}✗ Not Available${ENDC}"
    [[ $HEIMDALL_INSTALLED == true ]] && echo -e "Heimdall: ${GREEN}✓ Installed${ENDC}" || echo -e "Heimdall: ${RED}✗ Not Available${ENDC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${ENDC}"
}

get_device_info() {
    echo -e "${BLUE}Scanning devices...${ENDC}"
    DEVICES=$($ADB devices | tail -n +2 | awk '{print $1 "\t" $2}')
    if [[ -z "$DEVICES" ]]; then
        echo -e "${RED}No devices detected. Ensure USB debugging is enabled and device is authorized.${ENDC}"
        DEVICE_INFO=""
        return 1
    fi
    DEVICE_COUNT=$(echo "$DEVICES" | wc -l)
    if [[ $DEVICE_COUNT -gt 1 ]]; then
        echo -e "${GREEN}Multiple devices connected:${ENDC}"
        echo "$DEVICES" | nl -w 2 -s '. '
        while true; do
            read -p "Select device (number): " CHOICE
            if [[ $CHOICE =~ ^[0-9]+$ ]] && [[ $CHOICE -ge 1 ]] && [[ $CHOICE -le $DEVICE_COUNT ]]; then
                SERIAL=$(echo "$DEVICES" | sed -n "${CHOICE}p" | awk '{print $1}')
                STATE=$(echo "$DEVICES" | sed -n "${CHOICE}p" | awk '{print $2}')
                break
            else
                echo -e "${RED}Invalid selection.${ENDC}"
            fi
        done
    else
        SERIAL=$(echo "$DEVICES" | awk '{print $1}')
        STATE=$(echo "$DEVICES" | awk '{print $2}')
    fi
    if [[ "$STATE" == "unauthorized" ]]; then
        echo -e "${RED}${BOLD}Device $SERIAL unauthorized. Authorize on device screen.${ENDC}"
        DEVICE_INFO="serial=$SERIAL model=Unknown android_version=Unknown sdk_version=Unknown bootloader_version=Unknown kernel_version=Unknown manufacturer=Unknown architecture=Unknown state=$STATE"
        return 0
    fi
    MODEL=$($ADB -s $SERIAL shell getprop ro.product.model | tr -d '\r')
    ANDROID_VERSION=$($ADB -s $SERIAL shell getprop ro.build.version.release | tr -d '\r')
    SDK_VERSION=$($ADB -s $SERIAL shell getprop ro.build.version.sdk | tr -d '\r')
    BOOTLOADER_VERSION=$($ADB -s $SERIAL shell getprop ro.bootloader | tr -d '\r')
    KERNEL_VERSION=$($ADB -s $SERIAL shell cat /proc/version | tr -d '\r')
    MANUFACTURER=$($ADB -s $SERIAL shell getprop ro.product.manufacturer | tr -d '\r')
    ARCHITECTURE=$($ADB -s $SERIAL shell getprop ro.product.cpu.abi | tr -d '\r')
    DEVICE_INFO="serial=$SERIAL model=$MODEL android_version=$ANDROID_VERSION sdk_version=$SDK_VERSION bootloader_version=$BOOTLOADER_VERSION kernel_version=$KERNEL_VERSION manufacturer=$MANUFACTURER architecture=$ARCHITECTURE state=$STATE"
    echo -e "${GREEN}Device info gathered.${ENDC}"
}

display_device_info() {
    clear_screen
    if [[ -z "$DEVICE_INFO" ]]; then
        echo -e "${RED}No device info available. Connect a device.${ENDC}"
        read -p "Press Enter to return..."
        return
    fi
    echo -e "\n${BOLD}${GREEN}CONNECTED DEVICE INFORMATION${ENDC}"
    echo "=================================================="
    echo -e "${BOLD}Serial:${ENDC}           $(echo $DEVICE_INFO | grep -oP 'serial=\K[^ ]+')"
    echo -e "${BOLD}Manufacturer:${ENDC}     $(echo $DEVICE_INFO | grep -oP 'manufacturer=\K[^ ]+')"
    echo -e "${BOLD}Model:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+')"
    echo -e "${BOLD}Android Version:${ENDC}  $(echo $DEVICE_INFO | grep -oP 'android_version=\K[^ ]+')"
    echo -e "${BOLD}SDK Version:${ENDC}      $(echo $DEVICE_INFO | grep -oP 'sdk_version=\K[^ ]+')"
    echo -e "${BOLD}Architecture:${ENDC}     $(echo $DEVICE_INFO | grep -oP 'architecture=\K[^ ]+')"
    echo -e "${BOLD}Bootloader:${ENDC}       $(echo $DEVICE_INFO | grep -oP 'bootloader_version=\K[^ ]+')"
    echo -e "${BOLD}Kernel:${ENDC}           $(echo $DEVICE_INFO | grep -oP 'kernel_version=\K.+')"
    echo -e "${BOLD}State:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+')"
    echo "=================================================="
    read -p "Press Enter to return..."
}

confirm_action() {
    read -p "${BOLD}${GREEN}CONFIRMATION: $1 (y/N): ${ENDC}" RESPONSE
    RESPONSE=$(echo "$RESPONSE" | tr '[:upper:]' '[:lower:]')
    if [[ "$RESPONSE" == "y" || "$RESPONSE" == "yes" ]]; then
        return 0
    else
        echo -e "${RED}Operation cancelled.${ENDC}"
        return 1
    fi
}

run_command() {
    echo -e "${BLUE}Executing: $1${ENDC}"
    OUTPUT=$(timeout $2 bash -c "$1" 2>&1)
    STATUS=$?
    if [[ $STATUS -eq 124 ]]; then
        echo -e "${RED}Command timed out after $2 seconds${ENDC}"
        return 124
    elif [[ $STATUS -eq 0 ]]; then
        [[ -n "$OUTPUT" ]] && echo -e "${GREEN}$OUTPUT${ENDC}"
        return 0
    else
        echo -e "${RED}Error: $OUTPUT${ENDC}"
        return $STATUS
    fi
}

# File operations
push_file() {
    read -p "Local file path: " LOCAL_PATH
    if [[ ! -f "$LOCAL_PATH" ]]; then
        echo -e "${RED}File does not exist.${ENDC}"
        return
    fi
    FILE_SIZE=$(stat -c%s "$LOCAL_PATH" 2>/dev/null || stat -f%z "$LOCAL_PATH" 2>/dev/null)
    echo -e "${BLUE}File size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    read -p "Device destination path (e.g., /sdcard/): " REMOTE_PATH
    if ! $ADB -s $SERIAL shell test -d "$(dirname "$REMOTE_PATH")" 2>/dev/null; then
        echo -e "${RED}Destination directory does not exist on device.${ENDC}"
        return
    fi
    run_command "$ADB -s $SERIAL push \"$LOCAL_PATH\" \"$REMOTE_PATH\"" $FILE_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}File pushed successfully.${ENDC}"
}

pull_file() {
    read -p "Device file path: " REMOTE_PATH
    if ! $ADB -s $SERIAL shell test -f "$REMOTE_PATH" 2>/dev/null; then
        echo -e "${RED}File does not exist on device.${ENDC}"
        return
    fi
    FILE_SIZE=$($ADB -s $SERIAL shell stat -c%s "$REMOTE_PATH" 2>/dev/null)
    [[ -n "$FILE_SIZE" ]] && echo -e "${BLUE}File size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    read -p "Local destination path: " LOCAL_PATH
    run_command "$ADB -s $SERIAL pull \"$REMOTE_PATH\" \"$LOCAL_PATH\"" $FILE_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}File pulled successfully.${ENDC}"
}

batch_push() {
    read -p "Local directory path: " LOCAL_DIR
    if [[ ! -d "$LOCAL_DIR" ]]; then
        echo -e "${RED}Directory does not exist.${ENDC}"
        return
    fi
    read -p "Device destination directory (e.g., /sdcard/): " REMOTE_DIR
    if ! $ADB -s $SERIAL shell test -d "$REMOTE_DIR" 2>/dev/null; then
        echo -e "${RED}Destination directory does not exist on device.${ENDC}"
        return
    fi
    FILE_COUNT=$(find "$LOCAL_DIR" -type f | wc -l)
    echo -e "${BLUE}Found $FILE_COUNT files to push${ENDC}"
    confirm_action "Push $FILE_COUNT files?" || return
    CURRENT=0
    for FILE in "$LOCAL_DIR"/*; do
        if [[ -f "$FILE" ]]; then
            CURRENT=$((CURRENT + 1))
            echo -e "${BLUE}[$CURRENT/$FILE_COUNT] Pushing $(basename "$FILE")...${ENDC}"
            run_command "$ADB -s $SERIAL push \"$FILE\" \"$REMOTE_DIR\"" $FILE_TIMEOUT
        fi
    done
    echo -e "${GREEN}Batch push complete: $CURRENT files processed.${ENDC}"
}

batch_pull() {
    read -p "Device directory path (e.g., /sdcard/Download/): " REMOTE_DIR
    if ! $ADB -s $SERIAL shell test -d "$REMOTE_DIR" 2>/dev/null; then
        echo -e "${RED}Directory does not exist on device.${ENDC}"
        return
    fi
    read -p "Local destination directory: " LOCAL_DIR
    mkdir -p "$LOCAL_DIR"
    FILES=$($ADB -s $SERIAL shell find "$REMOTE_DIR" -type f 2>/dev/null | tr -d '\r')
    FILE_COUNT=$(echo "$FILES" | wc -l)
    echo -e "${BLUE}Found $FILE_COUNT files to pull${ENDC}"
    confirm_action "Pull $FILE_COUNT files?" || return
    CURRENT=0
    while IFS= read -r FILE; do
        if [[ -n "$FILE" ]]; then
            CURRENT=$((CURRENT + 1))
            echo -e "${BLUE}[$CURRENT/$FILE_COUNT] Pulling $(basename "$FILE")...${ENDC}"
            run_command "$ADB -s $SERIAL pull \"$FILE\" \"$LOCAL_DIR\"" $FILE_TIMEOUT
        fi
    done <<< "$FILES"
    echo -e "${GREEN}Batch pull complete: $CURRENT files processed.${ENDC}"
}

install_apk() {
    read -p "APK file path: " APK_PATH
    if [[ ! -f "$APK_PATH" || ! "$APK_PATH" =~ \.apk$ ]]; then
        echo -e "${RED}Invalid APK file.${ENDC}"
        return
    fi
    FILE_SIZE=$(stat -c%s "$APK_PATH" 2>/dev/null || stat -f%z "$APK_PATH" 2>/dev/null)
    echo -e "${BLUE}APK: $(basename "$APK_PATH") Size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    if command -v aapt &>/dev/null; then
        PKG=$(aapt dump badging "$APK_PATH" 2>/dev/null | grep "package:" | sed "s/.*name='\([^']*\)'.*/\1/")
        [[ -n "$PKG" ]] && echo -e "${BLUE}Package: $PKG${ENDC}"
    fi
    OUTPUT=$(run_command "$ADB -s $SERIAL install -r \"$APK_PATH\"" $FILE_TIMEOUT)
    [[ $? -eq 0 && "$OUTPUT" =~ Success ]] && echo -e "${GREEN}APK installed: $(basename "$APK_PATH")${ENDC}" || echo -e "${RED}Installation failed.${ENDC}"
}

uninstall_package() {
    read -p "Package name (e.g., com.example.app): " PKG
    if [[ -z "$PKG" ]]; then
        echo -e "${RED}Package name required.${ENDC}"
        return
    fi
    if ! $ADB -s $SERIAL shell pm list packages | grep -q "package:$PKG"; then
        echo -e "${RED}Package not found: $PKG${ENDC}"
        return
    fi
    confirm_action "Uninstall $PKG?" || return
    OUTPUT=$(run_command "$ADB -s $SERIAL uninstall $PKG" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 && "$OUTPUT" =~ Success ]] && echo -e "${GREEN}Package uninstalled: $PKG${ENDC}" || echo -e "${RED}Uninstall failed.${ENDC}"
}

list_packages() {
    echo -e "${GREEN}Package List Options${ENDC}"
    echo "1. All packages"
    echo "2. System packages"
    echo "3. User packages"
    echo "4. Enabled packages"
    echo "5. Disabled packages"
    read -p "Select option (1-5): " CHOICE
    case $CHOICE in
        1) FILTER="" ;;
        2) FILTER="-s" ;;
        3) FILTER="-3" ;;
        4) FILTER="-e" ;;
        5) FILTER="-d" ;;
        *) echo -e "${RED}Invalid choice.${ENDC}"; return ;;
    esac
    OUTPUT=$(run_command "$ADB -s $SERIAL shell pm list packages $FILTER" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        PKG_COUNT=$(echo "$OUTPUT" | wc -l)
        echo -e "${GREEN}Found $PKG_COUNT packages:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT" | sed 's/package://' | sort
        echo "------------------------------------------------------------"
    else
        echo -e "${RED}Failed to list packages.${ENDC}"
    fi
}

list_device_directory() {
    read -p "Device directory path (default: /sdcard/): " DIR
    DIR=${DIR:-/sdcard/}
    if ! $ADB -s $SERIAL shell test -d "$DIR" 2>/dev/null; then
        echo -e "${RED}Directory does not exist on device.${ENDC}"
        return
    fi
    OUTPUT=$(run_command "$ADB -s $SERIAL shell ls -la \"$DIR\"" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Contents of $DIR:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT"
        echo "------------------------------------------------------------"
        FILE_COUNT=$(echo "$OUTPUT" | grep -c "^-")
        DIR_COUNT=$(echo "$OUTPUT" | grep -c "^d")
        echo -e "${BLUE}Summary: $DIR_COUNT directories, $FILE_COUNT files${ENDC}"
    else
        echo -e "${RED}Failed to list directory.${ENDC}"
    fi
}

pull_kernel() {
    echo -e "${BLUE}Gathering kernel info...${ENDC}"
    KERNEL_INFO=$(run_command "$ADB -s $SERIAL shell cat /proc/version" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        FILENAME="kernel_info_$TIMESTAMP.txt"
        {
            echo "Kernel Information Report"
            echo "Generated: $(date)"
            echo "Device: $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+')"
            echo "Serial: $(echo $DEVICE_INFO | grep -oP 'serial=\K[^ ]+')"
            echo -e "\nKernel Version"
            echo "$KERNEL_INFO"
            echo -e "\nCPU Information"
            $ADB -s $SERIAL shell cat /proc/cpuinfo 2>/dev/null
            echo -e "\nMemory Information"
            $ADB -s $SERIAL shell cat /proc/meminfo 2>/dev/null
        } > "$FILENAME"
        FILE_SIZE=$(stat -c%s "$FILENAME" 2>/dev/null || stat -f%z "$FILENAME" 2>/dev/null)
        echo -e "${GREEN}Kernel info saved to $FILENAME ($FILE_SIZE bytes)${ENDC}"
    else
        echo -e "${RED}Failed to pull kernel info.${ENDC}"
    fi
}

# Fastboot operations
fastboot_flash() {
    read -p "Partition name (e.g., boot, recovery): " PARTITION
    if [[ -z "$PARTITION" ]]; then return; fi
    read -p "Image file path: " IMAGE_PATH
    if [[ ! -f "$IMAGE_PATH" ]]; then
        echo -e "${RED}Image file does not exist.${ENDC}"
        return
    fi
    echo -e "${RED}${BOLD}⚠️ CRITICAL WARNING: FLASHING $PARTITION ⚠️${ENDC}"
    if [[ " boot system
