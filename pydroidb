#!/usr/bin/env bash

# PyDroidb: Complete ADB, Fastboot, GSI & Samsung Automation Tool
# Enhanced with system-wide installation and GSI flashing support
# Author: 0xbv1 | 0xb0rn3
# Version: 0.3.0

VERSION="0.3.0"
SCRIPT_NAME="pydroidb"
INSTALL_DIR="/usr/local/bin"
SCRIPT_PATH="$(readlink -f "$0")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"

# Color definitions
BLUE='\033[94m'
GREEN='\033[92m'
RED='\033[91m'
YELLOW='\033[93m'
BOLD='\033[1m'
ENDC='\033[0m'
CYAN='\033[96m'
MAGENTA='\033[95m'

# Timeout configurations
DEFAULT_TIMEOUT=60
FILE_TIMEOUT=300
BACKUP_TIMEOUT=3600
FASTBOOT_TIMEOUT=600
SAMSUNG_FLASH_TIMEOUT=1800
SAMSUNG_PIT_TIMEOUT=300
SAMSUNG_NAND_TIMEOUT=3600
GSI_FLASH_TIMEOUT=900

# Samsung device configuration
SAMSUNG_VENDOR_ID="04e8"
ODIN4_INSTALLED=false
HEIMDALL_INSTALLED=false

# GSI Support variables
GSI_DETECTED=false
DEVICE_ARCH=""
AB_DEVICE=false
TREBLE_ENABLED=false

# Installation functions
check_installation() {
    if [[ -f "$INSTALL_DIR/$SCRIPT_NAME" ]]; then
        INSTALLED_VERSION=$(grep "^VERSION=" "$INSTALL_DIR/$SCRIPT_NAME" 2>/dev/null | cut -d'"' -f2)
        if [[ "$SCRIPT_PATH" == "$INSTALL_DIR/$SCRIPT_NAME" ]]; then
            return 0  # Running from installed location
        else
            return 1  # Script exists but running from different location
        fi
    else
        return 2  # Not installed
    fi
}

# GSI (Generic System Image) Operations
check_gsi_compatibility() {
    echo -e "${BLUE}Checking GSI compatibility...${ENDC}"
    
    # Check Treble support
    TREBLE=$($ADB -s $SERIAL shell getprop ro.treble.enabled 2>/dev/null | tr -d '\r')
    if [[ "$TREBLE" != "true" ]]; then
        echo -e "${RED}Device does not support Treble. GSI cannot be installed.${ENDC}"
        return 1
    fi
    
    # Check A/B partition
    AB_UPDATE=$($ADB -s $SERIAL shell getprop ro.build.ab_update 2>/dev/null | tr -d '\r')
    if [[ "$AB_UPDATE" == "true" ]]; then
        AB_DEVICE=true
        echo -e "${GREEN}Device uses A/B partition scheme${ENDC}"
    else
        AB_DEVICE=false
        echo -e "${GREEN}Device uses A-only partition scheme${ENDC}"
    fi
    
    # Check architecture
    ARCH=$($ADB -s $SERIAL shell getprop ro.product.cpu.abi 2>/dev/null | tr -d '\r')
    case "$ARCH" in
        arm64-v8a)
            DEVICE_ARCH="arm64"
            echo -e "${GREEN}Architecture: ARM64 (64-bit)${ENDC}"
            ;;
        armeabi-v7a)
            DEVICE_ARCH="arm32"
            echo -e "${GREEN}Architecture: ARM (32-bit)${ENDC}"
            ;;
        x86_64)
            DEVICE_ARCH="x86_64"
            echo -e "${GREEN}Architecture: x86_64${ENDC}"
            ;;
        *)
            echo -e "${YELLOW}Architecture: $ARCH (verify GSI compatibility)${ENDC}"
            DEVICE_ARCH="$ARCH"
            ;;
    esac
    
    # Check bootloader status
    BOOTLOADER=$($FASTBOOT getvar unlocked 2>&1 | grep unlocked | awk '{print $2}')
    if [[ "$BOOTLOADER" == "yes" ]]; then
        echo -e "${GREEN}Bootloader: Unlocked${ENDC}"
    else
        echo -e "${RED}Bootloader appears locked. Unlock required for GSI.${ENDC}"
        return 1
    fi
    
    GSI_DETECTED=true
    echo -e "${GREEN}✓ Device is GSI compatible${ENDC}"
    return 0
}

flash_gsi_mediatek() {
    echo -e "${BOLD}${CYAN}MediaTek GSI Flash Process${ENDC}"
    echo -e "${YELLOW}Based on Lenovo P11 Gen 2 (TB350XU) recovery method${ENDC}"
    
    echo -e "${RED}${BOLD}WARNING: This process will:${ENDC}"
    echo -e "${RED}• Wipe all user data${ENDC}"
    echo -e "${RED}• Replace system with GSI${ENDC}"
    echo -e "${RED}• May brick device if done incorrectly${ENDC}"
    
    confirm_action "Proceed with MediaTek GSI flash?" || return
    
    # Step 1: Check for stock vbmeta files
    echo -e "${BLUE}Step 1: Checking for stock vbmeta files...${ENDC}"
    read -p "Path to stock firmware directory (containing vbmeta.img): " STOCK_DIR
    
    if [[ ! -f "$STOCK_DIR/vbmeta.img" ]]; then
        echo -e "${RED}vbmeta.img not found in $STOCK_DIR${ENDC}"
        echo -e "${YELLOW}Stock vbmeta is REQUIRED for MediaTek devices${ENDC}"
        return 1
    fi
    
    # Step 2: Select GSI image
    read -p "Path to GSI image (.img file): " GSI_PATH
    if [[ ! -f "$GSI_PATH" ]]; then
        echo -e "${RED}GSI image not found: $GSI_PATH${ENDC}"
        return 1
    fi
    
    GSI_SIZE=$(stat -c%s "$GSI_PATH" 2>/dev/null || stat -f%z "$GSI_PATH" 2>/dev/null)
    echo -e "${BLUE}GSI: $(basename "$GSI_PATH")${ENDC}"
    echo -e "${BLUE}Size: $(numfmt --to=iec-i --suffix=B $GSI_SIZE)${ENDC}"
    
    # Step 3: Enter fastboot mode
    echo -e "${BLUE}Step 3: Entering fastboot mode...${ENDC}"
    echo -e "${YELLOW}Manual action required:${ENDC}"
    echo -e "1. Power off device"
    echo -e "2. Hold Volume Up + Power"
    echo -e "3. Connect USB when in fastboot mode"
    read -p "Press Enter when device is in fastboot mode..."
    
    # Verify fastboot connection
    if ! $FASTBOOT devices | grep -q .; then
        echo -e "${RED}No device detected in fastboot mode${ENDC}"
        return 1
    fi
    
    echo -e "${GREEN}Device detected in fastboot${ENDC}"
    
    # Step 4: Flash stock vbmeta to restore chain
    echo -e "${BLUE}Step 4: Restoring stock vbmeta chain...${ENDC}"
    
    if [[ $AB_DEVICE == true ]]; then
        run_command "$FASTBOOT flash vbmeta_a \"$STOCK_DIR/vbmeta.img\"" $FASTBOOT_TIMEOUT
        run_command "$FASTBOOT flash vbmeta_b \"$STOCK_DIR/vbmeta.img\"" $FASTBOOT_TIMEOUT
    else
        run_command "$FASTBOOT flash vbmeta \"$STOCK_DIR/vbmeta.img\"" $FASTBOOT_TIMEOUT
    fi
    
    # Step 5: Flash GSI to system
    echo -e "${BLUE}Step 5: Flashing GSI to system partition...${ENDC}"
    echo -e "${YELLOW}This may take several minutes for large images...${ENDC}"
    
    run_command "$FASTBOOT flash system \"$GSI_PATH\"" $GSI_FLASH_TIMEOUT
    
    if [[ $? -ne 0 ]]; then
        echo -e "${RED}GSI flash failed${ENDC}"
        return 1
    fi
    
    # Step 6: Disable vbmeta verification
    echo -e "${BLUE}Step 6: Disabling vbmeta verification...${ENDC}"
    
    if [[ $AB_DEVICE == true ]]; then
        run_command "$FASTBOOT --disable-verity --disable-verification flash vbmeta_a \"$STOCK_DIR/vbmeta.img\"" $FASTBOOT_TIMEOUT
        run_command "$FASTBOOT --disable-verity --disable-verification flash vbmeta_b \"$STOCK_DIR/vbmeta.img\"" $FASTBOOT_TIMEOUT
    else
        run_command "$FASTBOOT --disable-verity --disable-verification flash vbmeta \"$STOCK_DIR/vbmeta.img\"" $FASTBOOT_TIMEOUT
    fi
    
    # Step 7: Format userdata (critical)
    echo -e "${BLUE}Step 7: Formatting userdata (CRITICAL STEP)...${ENDC}"
    run_command "$FASTBOOT format userdata" $FASTBOOT_TIMEOUT
    
    if [[ $? -ne 0 ]]; then
        echo -e "${YELLOW}Format failed, trying wipe instead...${ENDC}"
        run_command "$FASTBOOT -w" $FASTBOOT_TIMEOUT
    fi
    
    # Step 8: Reboot
    echo -e "${BLUE}Step 8: Rebooting device...${ENDC}"
    run_command "$FASTBOOT reboot" $DEFAULT_TIMEOUT
    
    echo -e "${GREEN}═══════════════════════════════════════════════════════${ENDC}"
    echo -e "${GREEN}GSI Flash Complete!${ENDC}"
    echo -e "${GREEN}Device should boot into GSI now.${ENDC}"
    echo -e "${YELLOW}First boot may take 5-10 minutes.${ENDC}"
    echo -e "${GREEN}═══════════════════════════════════════════════════════${ENDC}"
}

flash_gsi_standard() {
    echo -e "${BOLD}${CYAN}Standard GSI Flash Process${ENDC}"
    
    check_gsi_compatibility || return
    
    echo -e "${RED}${BOLD}WARNING: This will wipe all data!${ENDC}"
    confirm_action "Proceed with GSI installation?" || return
    
    # Select GSI image
    read -p "Path to GSI image: " GSI_PATH
    if [[ ! -f "$GSI_PATH" ]]; then
        echo -e "${RED}GSI image not found${ENDC}"
        return 1
    fi
    
    # Check GSI compatibility with device
    GSI_NAME=$(basename "$GSI_PATH")
    if [[ $AB_DEVICE == true && ! "$GSI_NAME" =~ (ab|AB) ]]; then
        echo -e "${YELLOW}Warning: Device is A/B but GSI may be A-only${ENDC}"
        confirm_action "Continue anyway?" || return
    fi
    
    if [[ "$DEVICE_ARCH" == "arm64" && ! "$GSI_NAME" =~ (arm64|ARM64|64) ]]; then
        echo -e "${YELLOW}Warning: Architecture mismatch possible${ENDC}"
        confirm_action "Continue anyway?" || return
    fi
    
    # Enter fastboot
    echo -e "${BLUE}Rebooting to bootloader...${ENDC}"
    run_command "$ADB -s $SERIAL reboot bootloader" $DEFAULT_TIMEOUT
    sleep 5
    
    # Verify fastboot connection
    if ! $FASTBOOT devices | grep -q .; then
        echo -e "${RED}Device not detected in fastboot${ENDC}"
        return 1
    fi
    
    # Disable vbmeta verification
    echo -e "${BLUE}Disabling vbmeta verification...${ENDC}"
    
    # Create empty vbmeta image
    EMPTY_VBMETA="/tmp/empty_vbmeta.img"
    dd if=/dev/zero of="$EMPTY_VBMETA" bs=1 count=256 2>/dev/null
    
    if [[ $AB_DEVICE == true ]]; then
        run_command "$FASTBOOT --disable-verity --disable-verification flash vbmeta_a $EMPTY_VBMETA" $DEFAULT_TIMEOUT
        run_command "$FASTBOOT --disable-verity --disable-verification flash vbmeta_b $EMPTY_VBMETA" $DEFAULT_TIMEOUT
    else
        run_command "$FASTBOOT --disable-verity --disable-verification flash vbmeta $EMPTY_VBMETA" $DEFAULT_TIMEOUT
    fi
    
    # Wipe system
    echo -e "${BLUE}Erasing system partition...${ENDC}"
    run_command "$FASTBOOT erase system" $DEFAULT_TIMEOUT
    
    # Flash GSI
    echo -e "${BLUE}Flashing GSI image...${ENDC}"
    run_command "$FASTBOOT flash system \"$GSI_PATH\"" $GSI_FLASH_TIMEOUT
    
    # Wipe userdata
    echo -e "${BLUE}Wiping userdata...${ENDC}"
    run_command "$FASTBOOT -w" $FASTBOOT_TIMEOUT
    
    # Reboot
    echo -e "${BLUE}Rebooting...${ENDC}"
    run_command "$FASTBOOT reboot" $DEFAULT_TIMEOUT
    
    echo -e "${GREEN}GSI installation complete!${ENDC}"
    echo -e "${YELLOW}First boot may take several minutes.${ENDC}"
}

backup_current_rom() {
    echo -e "${BOLD}${CYAN}ROM Backup Utility${ENDC}"
    
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    BACKUP_DIR="backup_${MODEL}_${TIMESTAMP}"
    mkdir -p "$BACKUP_DIR"
    
    echo -e "${BLUE}Backing up to: $BACKUP_DIR${ENDC}"
    
    # Enter fastboot
    echo -e "${BLUE}Rebooting to bootloader...${ENDC}"
    run_command "$ADB -s $SERIAL reboot bootloader" $DEFAULT_TIMEOUT
    sleep 5
    
    if ! $FASTBOOT devices | grep -q .; then
        echo -e "${RED}Device not in fastboot mode${ENDC}"
        return 1
    fi
    
    # Get partition list
    echo -e "${BLUE}Getting partition information...${ENDC}"
    PARTITIONS=$($FASTBOOT getvar all 2>&1 | grep "partition-size" | cut -d: -f2 | cut -d: -f1)
    
    echo -e "${YELLOW}Found partitions to backup:${ENDC}"
    echo "$PARTITIONS"
    
    confirm_action "Backup these partitions?" || return
    
    # Backup each partition
    for PARTITION in boot recovery system vendor vbmeta; do
        if echo "$PARTITIONS" | grep -q "$PARTITION"; then
            echo -e "${BLUE}Backing up $PARTITION...${ENDC}"
            run_command "$FASTBOOT fetch $PARTITION $BACKUP_DIR/${PARTITION}.img" $BACKUP_TIMEOUT
        fi
    done
    
    echo -e "${GREEN}Backup complete! Files saved to $BACKUP_DIR${ENDC}"
    
    # Reboot to system
    run_command "$FASTBOOT reboot" $DEFAULT_TIMEOUT
}

# Fastboot operations
fastboot_flash() {
    read -p "Partition name (e.g., boot, recovery): " PARTITION
    if [[ -z "$PARTITION" ]]; then return; fi
    read -p "Image file path: " IMAGE_PATH
    if [[ ! -f "$IMAGE_PATH" ]]; then
        echo -e "${RED}Image file does not exist.${ENDC}"
        return
    fi
    echo -e "${RED}${BOLD}⚠️ CRITICAL WARNING: FLASHING $PARTITION ⚠️${ENDC}"
    if [[ " boot system recovery bootloader radio vendor userdata cache misc persist vbmeta " =~ " $PARTITION " ]]; then
        echo -e "${RED}$PARTITION is critical. Wrong image may brick device.${ENDC}"
    fi
    confirm_action "Flash $PARTITION with $(basename "$IMAGE_PATH")?" || return
    confirm_action "FINAL CONFIRMATION. Proceed?" || return
    OUTPUT=$(run_command "$FASTBOOT flash $PARTITION \"$IMAGE_PATH\"" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Flash successful.${ENDC}" || echo -e "${RED}Flash failed.${ENDC}"
}

fastboot_erase() {
    read -p "Partition name to ERASE (e.g., userdata, cache): " PARTITION
    if [[ -z "$PARTITION" ]]; then return; fi
    echo -e "${RED}${BOLD}⚠️ CRITICAL WARNING: ERASING $PARTITION ⚠️${ENDC}"
    if [[ " boot system recovery bootloader radio vendor misc persist vbmeta " =~ " $PARTITION " ]]; then
        echo -e "${RED}Erasing $PARTITION may brick device.${ENDC}"
    fi
    confirm_action "Erase $PARTITION?" || return
    OUTPUT=$(run_command "$FASTBOOT erase $PARTITION" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Erase successful.${ENDC}" || echo -e "${RED}Erase failed.${ENDC}"
}

fastboot_format() {
    read -p "Partition to FORMAT (e.g., userdata): " PARTITION
    read -p "Filesystem type (e.g., ext4, f2fs): " FSTYPE
    if [[ -z "$PARTITION" || -z "$FSTYPE" ]]; then return; fi
    echo -e "${RED}${BOLD}⚠️ CRITICAL WARNING: FORMATTING $PARTITION ⚠️${ENDC}"
    confirm_action "Format $PARTITION as $FSTYPE?" || return
    OUTPUT=$(run_command "$FASTBOOT format:$FSTYPE $PARTITION" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Format successful.${ENDC}" || echo -e "${RED}Format failed.${ENDC}"
}

fastboot_boot() {
    read -p "Image file path to boot: " IMAGE_PATH
    if [[ ! -f "$IMAGE_PATH" ]]; then
        echo -e "${RED}Image file does not exist.${ENDC}"
        return
    fi
    confirm_action "Boot $(basename "$IMAGE_PATH")?" || return
    OUTPUT=$(run_command "$FASTBOOT boot \"$IMAGE_PATH\"" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Boot command sent.${ENDC}" || echo -e "${RED}Boot failed.${ENDC}"
}

fastboot_unlock() {
    echo -e "${RED}${BOLD}Unlocking bootloader WIPES ALL DATA.${ENDC}"
    confirm_action "Proceed with unlocking?" || return
    OUTPUT=$(run_command "$FASTBOOT flashing unlock" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Unlock command sent. Check device screen.${ENDC}" || echo -e "${RED}Unlock failed. Try 'fastboot oem unlock'.${ENDC}"
}

fastboot_lock() {
    echo -e "${RED}${BOLD}Locking bootloader may brick device with custom software.${ENDC}"
    confirm_action "Proceed with locking?" || return
    OUTPUT=$(run_command "$FASTBOOT flashing lock" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Lock command sent. Check device screen.${ENDC}" || echo -e "${RED}Lock command failed.${ENDC}"
}

fastboot_set_active_slot() {
    read -p "Slot to set active ('a' or 'b'): " SLOT
    if [[ "$SLOT" != "a" && "$SLOT" != "b" ]]; then
        echo -e "${RED}Invalid slot. Use 'a' or 'b'.${ENDC}"
        return
    fi
    confirm_action "Set active slot to $SLOT?" || return
    OUTPUT=$(run_command "$FASTBOOT --set-active=$SLOT" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Active slot set to $SLOT.${ENDC}" || echo -e "${RED}Failed to set active slot.${ENDC}"
}

fastboot_getvar_all() {
    echo -e "${BLUE}Fetching bootloader variables...${ENDC}"
    OUTPUT=$(run_command "$FASTBOOT getvar all" $DEFAULT_TIMEOUT 2>&1)
    if [[ $? -eq 0 || -n "$OUTPUT" ]]; then
        echo -e "${GREEN}Device Variables:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT"
        echo "------------------------------------------------------------"
    else
        echo -e "${RED}Failed to get variables.${ENDC}"
    fi
}

fastboot_reboot() {
    clear_screen
    echo -e "${BOLD}${GREEN}Fastboot Reboot Options${ENDC}"
    echo "1. Reboot to System"
    echo "2. Reboot to Bootloader"
    echo "3. Reboot to Recovery"
    echo "4. Continue Boot"
    echo "5. Cancel"
    read -p "Select option: " CHOICE
    case $CHOICE in
        1) run_command "$FASTBOOT reboot" $DEFAULT_TIMEOUT && echo -e "${GREEN}Reboot command sent.${ENDC}";;
        2) run_command "$FASTBOOT reboot-bootloader" $DEFAULT_TIMEOUT && echo -e "${GREEN}Reboot command sent.${ENDC}";;
        3) run_command "$FASTBOOT reboot recovery" $DEFAULT_TIMEOUT && echo -e "${GREEN}Reboot command sent.${ENDC}";;
        4) run_command "$FASTBOOT continue" $DEFAULT_TIMEOUT && echo -e "${GREEN}Continue command sent.${ENDC}";;
        5) ;;
        *) echo -e "${RED}Invalid choice.${ENDC}";;
    esac
}

fastboot_devices() {
    OUTPUT=$(run_command "$FASTBOOT devices" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Fastboot devices:${ENDC}"
        echo "------------------------------"
        [[ -n "$OUTPUT" ]] && echo "$OUTPUT" || echo "No devices found."
        echo "------------------------------"
    fi
}

fastboot_flash_all() {
    read -p "Path to image directory: " IMG_DIR
    if [[ ! -d "$IMG_DIR" ]]; then
        echo -e "${RED}Directory does not exist.${ENDC}"
        return
    fi
    echo -e "${RED}${BOLD}⚠️ CRITICAL WARNING: FLASHING ALL PARTITIONS ⚠️${ENDC}"
    confirm_action "Flash all partitions in $IMG_DIR?" || return
    confirm_action "FINAL CONFIRMATION. Proceed?" || return
    for IMG in "$IMG_DIR"/*.img; do
        if [[ -f "$IMG" ]]; then
            PARTITION=$(basename "$IMG" .img)
            run_command "$FASTBOOT flash $PARTITION \"$IMG\"" $FASTBOOT_TIMEOUT
        fi
    done
    echo -e "${GREEN}Flash all complete.${ENDC}"
}

fastboot_wipe() {
    echo -e "${RED}${BOLD}⚠️ Wiping device will ERASE ALL DATA ⚠️${ENDC}"
    confirm_action "Wipe device?" || return
    OUTPUT=$(run_command "$FASTBOOT -w" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Wipe successful.${ENDC}" || echo -e "${RED}Wipe failed.${ENDC}"
}

fastboot_oem_commands() {
    echo -e "${GREEN}OEM Commands${ENDC}"
    echo "1. OEM Unlock"
    echo "2. OEM Lock"
    echo "3. OEM Device Info"
    echo "4. OEM Custom Command"
    echo "5. Cancel"
    read -p "Select option: " CHOICE
    case $CHOICE in
        1) confirm_action "OEM Unlock (wipes data)?" && run_command "$FASTBOOT oem unlock" $DEFAULT_TIMEOUT && echo -e "${GREEN}OEM Unlock sent.${ENDC}";;
        2) confirm_action "OEM Lock?" && run_command "$FASTBOOT oem lock" $DEFAULT_TIMEOUT && echo -e "${GREEN}OEM Lock sent.${ENDC}";;
        3) run_command "$FASTBOOT oem device-info" $DEFAULT_TIMEOUT;;
        4) read -p "Enter OEM command: " CMD && run_command "$FASTBOOT oem $CMD" $DEFAULT_TIMEOUT;;
        5) ;;
        *) echo -e "${RED}Invalid choice.${ENDC}";;
    esac
}

# System operations
reboot_device() {
    read -p "Reboot mode (system/recovery/bootloader/download, default system): " MODE
    MODE=${MODE:-system}
    confirm_action "Reboot to $MODE?" || return
    if [[ "$MODE" == "system" ]]; then
        run_command "$ADB -s $SERIAL reboot" $DEFAULT_TIMEOUT
    else
        run_command "$ADB -s $SERIAL reboot $MODE" $DEFAULT_TIMEOUT
    fi
    [[ $? -eq 0 ]] && echo -e "${GREEN}Reboot command sent.${ENDC}" || echo -e "${RED}Reboot failed.${ENDC}"
}

take_screenshot() {
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    DEVICE_PATH="/sdcard/screenshot_$TIMESTAMP.png"
    LOCAL_DEST="$(pwd)/screenshot_$TIMESTAMP.png"
    run_command "$ADB -s $SERIAL shell screencap $DEVICE_PATH" $DEFAULT_TIMEOUT
    if [[ $? -eq 0 ]]; then
        echo -e "${BLUE}Pulling screenshot...${ENDC}"
        run_command "$ADB -s $SERIAL pull $DEVICE_PATH \"$LOCAL_DEST\"" $FILE_TIMEOUT
        $ADB -s $SERIAL shell rm "$DEVICE_PATH" 2>/dev/null
        if [[ $? -eq 0 ]]; then
            FILE_SIZE=$(stat -c%s "$LOCAL_DEST" 2>/dev/null || stat -f%z "$LOCAL_DEST" 2>/dev/null)
            echo -e "${GREEN}Screenshot saved: $LOCAL_DEST ($FILE_SIZE bytes)${ENDC}"
        else
            echo -e "${RED}Failed to pull screenshot.${ENDC}"
        fi
    else
        echo -e "${RED}Failed to take screenshot.${ENDC}"
    fi
}

screen_recording() {
    read -p "Recording duration (1-180s, default 30): " DURATION
    DURATION=${DURATION:-30}
    if [[ ! $DURATION =~ ^[0-9]+$ || $DURATION -lt 1 || $DURATION -gt 180 ]]; then
        echo -e "${RED}Invalid duration (1-180).${ENDC}"
        return
    fi
    echo "1. Standard quality"
    echo "2. High quality"
    echo "3. Low quality"
    read -p "Select quality (1-3, default 1): " QUALITY
    case $QUALITY in
        2) QUALITY_ARG="--bit-rate 8000000" ;;
        3) QUALITY_ARG="--bit-rate 2000000" ;;
        *) QUALITY_ARG="" ;;
    esac
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    DEVICE_PATH="/sdcard/screenrecord_$TIMESTAMP.mp4"
    LOCAL_DEST="$(pwd)/screenrecord_$TIMESTAMP.mp4"
    echo -e "${GREEN}Starting ${DURATION}s recording... Ctrl+C to stop.${ENDC}"
    run_command "$ADB -s $SERIAL shell screenrecord --time-limit=$DURATION $QUALITY_ARG $DEVICE_PATH" $((DURATION+15)) &
    PID=$!
    trap 'kill $PID; run_command "$ADB -s $SERIAL shell killall screenrecord" 10; echo -e "${GREEN}Recording stopped.${ENDC}"' INT
    wait $PID
    trap - INT
    echo -e "${BLUE}Pulling video...${ENDC}"
    run_command "$ADB -s $SERIAL pull $DEVICE_PATH \"$LOCAL_DEST\"" $FILE_TIMEOUT
    $ADB -s $SERIAL shell rm "$DEVICE_PATH" 2>/dev/null
    if [[ $? -eq 0 ]]; then
        FILE_SIZE=$(stat -c%s "$LOCAL_DEST" 2>/dev/null || stat -f%z "$LOCAL_DEST" 2>/dev/null)
        echo -e "${GREEN}Video saved: $LOCAL_DEST ($FILE_SIZE bytes)${ENDC}"
    else
        echo -e "${RED}Failed to pull video.${ENDC}"
    fi
}

logcat() {
    echo -e "${GREEN}Logcat Options${ENDC}"
    echo "1. All logs"
    echo "2. Filter by tag"
    echo "3. Filter by priority"
    read -p "Select option (1-3): " CHOICE
    case $CHOICE in
        1) FILTER="" ;;
        2) read -p "Enter tag (e.g., ActivityManager): " TAG; FILTER="$TAG:*" ;;
        3) read -p "Enter priority (V/D/I/W/E/F): " PRIORITY; FILTER="*:$PRIORITY" ;;
        *) echo -e "${RED}Invalid choice.${ENDC}"; return ;;
    esac
    echo -e "${GREEN}Starting logcat... Ctrl+C to stop.${ENDC}"
    $ADB -s $SERIAL logcat $FILTER
    echo -e "${GREEN}Logcat stopped.${ENDC}"
}

shell_access() {
    echo -e "${GREEN}Starting shell... Type 'exit' or Ctrl+D to quit.${ENDC}"
    echo "--------------------------------------------------"
    $ADB -s $SERIAL shell
    echo "--------------------------------------------------"
    echo -e "${GREEN}Shell session ended.${ENDC}"
}

get_battery_info() {
    OUTPUT=$(run_command "$ADB -s $SERIAL shell dumpsys battery" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Battery Information:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT"
        echo "------------------------------------------------------------"
    else
        echo -e "${RED}Failed to get battery info.${ENDC}"
    fi
}

get_device_ip() {
    OUTPUT=$(run_command "$ADB -s $SERIAL shell ip addr show wlan0" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 && "$OUTPUT" =~ inet ]]; then
        IP=$(echo "$OUTPUT" | grep -oP 'inet \K[\d.]+' | head -1)
        echo -e "${GREEN}Device Wi-Fi IP: ${BOLD}$IP${ENDC}"
    else
        echo -e "${RED}Could not get IP. Device on Wi-Fi?${ENDC}"
    fi
}

toggle_wifi() {
    echo "1. Enable Wi-Fi"
    echo "2. Disable Wi-Fi"
    read -p "Select option (1/2): " CHOICE
    if [[ "$CHOICE" == "1" ]]; then
        CMD="enable"
        ACTION="Enabling"
        FINAL="enabled"
    elif [[ "$CHOICE" == "2" ]]; then
        CMD="disable"
        ACTION="Disabling"
        FINAL="disabled"
    else
        echo -e "${RED}Invalid choice.${ENDC}"
        return
    fi
    echo -e "${BLUE}$ACTION Wi-Fi...${ENDC}"
    run_command "$ADB -s $SERIAL shell svc wifi $CMD" $DEFAULT_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}Wi-Fi $FINAL.${ENDC}" || echo -e "${RED}Failed to change Wi-Fi state.${ENDC}"
}

adb_advanced() {
    echo -e "${BOLD}${GREEN}ADB Advanced Operations${ENDC}"
    echo "1. Backup Device"
    echo "2. Restore Backup"
    echo "3. Install Multiple APKs"
    echo "4. Clear App Data"
    echo "5. Force Stop App"
    echo "6. Get System Properties"
    echo "7. Start Activity"
    echo "8. Simulate Input"
    echo "9. Generate Bug Report"
    echo "10. Enable Wi-Fi Debugging"
    echo "11. Screen Mirroring (scrcpy)"
    echo "12. Back to System Menu"
    read -p "Select option: " CHOICE
    case $CHOICE in
        1)
            read -p "Backup file path (e.g., backup.ab): " BACKUP_PATH
            run_command "$ADB -s $SERIAL backup -all -f \"$BACKUP_PATH\"" $BACKUP_TIMEOUT
            ;;
        2)
            read -p "Backup file path: " BACKUP_PATH
            if [[ ! -f "$BACKUP_PATH" ]]; then
                echo -e "${RED}Backup file does not exist.${ENDC}"
                return
            fi
            run_command "$ADB -s $SERIAL restore \"$BACKUP_PATH\"" $BACKUP_TIMEOUT
            ;;
        3)
            read -p "Directory with APKs: " APK_DIR
            if [[ ! -d "$APK_DIR" ]]; then
                echo -e "${RED}Directory does not exist.${ENDC}"
                return
            fi
            FILE_COUNT=$(find "$APK_DIR" -type f -name "*.apk" | wc -l)
            echo -e "${BLUE}Found $FILE_COUNT APKs${ENDC}"
            confirm_action "Install $FILE_COUNT APKs?" || return
            CURRENT=0
            for APK in "$APK_DIR"/*.apk; do
                if [[ -f "$APK" ]]; then
                    CURRENT=$((CURRENT + 1))
                    echo -e "${BLUE}[$CURRENT/$FILE_COUNT] Installing $(basename "$APK")...${ENDC}"
                    run_command "$ADB -s $SERIAL install -r \"$APK\"" $FILE_TIMEOUT
                fi
            done
            echo -e "${GREEN}Multiple APK installation complete.${ENDC}"
            ;;
        4)
            read -p "Package name to clear data: " PKG
            run_command "$ADB -s $SERIAL shell pm clear $PKG" $DEFAULT_TIMEOUT
            ;;
        5)
            read -p "Package name to force stop: " PKG
            run_command "$ADB -s $SERIAL shell am force-stop $PKG" $DEFAULT_TIMEOUT
            ;;
        6)
            OUTPUT=$(run_command "$ADB -s $SERIAL shell getprop" $DEFAULT_TIMEOUT)
            if [[ $? -eq 0 ]]; then
                echo -e "${GREEN}System Properties:${ENDC}"
                echo "------------------------------------------------------------"
                echo "$OUTPUT"
                echo "------------------------------------------------------------"
            fi
            ;;
        7)
            read -p "Activity (e.g., com.example/.MainActivity): " ACTIVITY
            run_command "$ADB -s $SERIAL shell am start -n $ACTIVITY" $DEFAULT_TIMEOUT
            ;;
        8)
            read -p "Input command (e.g., 'text hello' or 'keyevent 26'): " INPUT
            run_command "$ADB -s $SERIAL shell input $INPUT" $DEFAULT_TIMEOUT
            ;;
        9)
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            BUGREPORT="bugreport_$TIMESTAMP.zip"
            echo -e "${BLUE}Generating bug report...${ENDC}"
            run_command "$ADB -s $SERIAL bugreport \"$BUGREPORT\"" $BACKUP_TIMEOUT
            [[ $? -eq 0 ]] && echo -e "${GREEN}Bug report saved: $BUGREPORT${ENDC}"
            ;;
        10)
            read -p "Port for Wi-Fi debugging (default 5555): " PORT
            PORT=${PORT:-5555}
            IP=$($ADB -s $SERIAL shell ip addr show wlan0 2>/dev/null | grep -oP 'inet \K[\d.]+' | head -1)
            if [[ -z "$IP" ]]; then
                echo -e "${RED}Could not get IP. Ensure Wi-Fi is enabled.${ENDC}"
                return
            fi
            run_command "$ADB -s $SERIAL tcpip $PORT" $DEFAULT_TIMEOUT
            echo -e "${GREEN}Wi-Fi debugging enabled. Connect with: adb connect $IP:$PORT${ENDC}"
            ;;
        11)
            if command -v scrcpy &>/dev/null; then
                echo -e "${BLUE}Starting screen mirroring with scrcpy...${ENDC}"
                scrcpy -s $SERIAL
            else
                echo -e "${RED}scrcpy not found. Install from https://github.com/Genymobile/scrcpy${ENDC}"
            fi
            ;;
        12) return ;;
        *) echo -e "${RED}Invalid choice.${ENDC}";;
    esac
    read -p "Press Enter to return..."

install_systemwide() {
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════${ENDC}"
    echo -e "${BOLD}${CYAN}       PyDroidb System-wide Installation Setup         ${ENDC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════${ENDC}"
    
    check_installation
    INSTALL_STATUS=$?
    
    if [[ $INSTALL_STATUS -eq 0 ]]; then
        echo -e "${YELLOW}PyDroidb is already installed system-wide (v$INSTALLED_VERSION)${ENDC}"
        echo -e "${YELLOW}Current version: v$VERSION${ENDC}"
        read -p "Do you want to update/reinstall? (y/N): " UPDATE_CHOICE
        if [[ ! "$UPDATE_CHOICE" =~ ^[Yy] ]]; then
            echo -e "${GREEN}Installation cancelled.${ENDC}"
            return 0
        fi
    elif [[ $INSTALL_STATUS -eq 1 ]]; then
        echo -e "${YELLOW}PyDroidb is installed (v$INSTALLED_VERSION) but you're running from:${ENDC}"
        echo -e "${YELLOW}$SCRIPT_PATH${ENDC}"
        echo -e "${CYAN}System installation location: $INSTALL_DIR/$SCRIPT_NAME${ENDC}"
        read -p "Update system installation with this version? (y/N): " UPDATE_CHOICE
        if [[ ! "$UPDATE_CHOICE" =~ ^[Yy] ]]; then
            return 0
        fi
    else
        echo -e "${GREEN}Installing PyDroidb system-wide for the first time...${ENDC}"
    fi
    
    # Check for root/sudo access
    if [[ $EUID -eq 0 ]]; then
        SUDO_CMD=""
    else
        echo -e "${YELLOW}System-wide installation requires sudo privileges.${ENDC}"
        SUDO_CMD="sudo"
        if ! sudo -v 2>/dev/null; then
            echo -e "${RED}Failed to obtain sudo privileges. Installation aborted.${ENDC}"
            return 1
        fi
    fi
    
    echo -e "\n${BOLD}${BLUE}Installation Details:${ENDC}"
    echo -e "├─ ${CYAN}Source:${ENDC} $SCRIPT_PATH"
    echo -e "├─ ${CYAN}Target:${ENDC} $INSTALL_DIR/$SCRIPT_NAME"
    echo -e "├─ ${CYAN}Version:${ENDC} $VERSION"
    echo -e "└─ ${CYAN}Access:${ENDC} System-wide (all users)"
    
    echo -e "\n${YELLOW}This will:${ENDC}"
    echo -e "  • Copy PyDroidb to $INSTALL_DIR/"
    echo -e "  • Make it executable for all users"
    echo -e "  • Allow running 'pydroidb' from anywhere"
    
    read -p $'\n'"Proceed with installation? (y/N): " CONFIRM
    if [[ ! "$CONFIRM" =~ ^[Yy] ]]; then
        echo -e "${RED}Installation cancelled.${ENDC}"
        return 1
    fi
    
    echo -e "\n${BLUE}Installing PyDroidb...${ENDC}"
    
    if [[ -f "$INSTALL_DIR/$SCRIPT_NAME" ]]; then
        echo -e "${BLUE}Creating backup of existing installation...${ENDC}"
        $SUDO_CMD cp "$INSTALL_DIR/$SCRIPT_NAME" "$INSTALL_DIR/${SCRIPT_NAME}.backup" 2>/dev/null
    fi
    
    echo -e "${BLUE}Copying script to $INSTALL_DIR...${ENDC}"
    if $SUDO_CMD cp "$SCRIPT_PATH" "$INSTALL_DIR/$SCRIPT_NAME" 2>/dev/null; then
        echo -e "${GREEN}✓ Script copied successfully${ENDC}"
    else
        echo -e "${RED}✗ Failed to copy script${ENDC}"
        return 1
    fi
    
    echo -e "${BLUE}Setting executable permissions...${ENDC}"
    if $SUDO_CMD chmod 755 "$INSTALL_DIR/$SCRIPT_NAME" 2>/dev/null; then
        echo -e "${GREEN}✓ Permissions set successfully${ENDC}"
    else
        echo -e "${RED}✗ Failed to set permissions${ENDC}"
        return 1
    fi
    
    echo -e "${BLUE}Verifying installation...${ENDC}"
    if [[ -f "$INSTALL_DIR/$SCRIPT_NAME" ]] && [[ -x "$INSTALL_DIR/$SCRIPT_NAME" ]]; then
        INSTALLED_VER=$("$INSTALL_DIR/$SCRIPT_NAME" --version 2>/dev/null | grep -oP '\d+\.\d+\.\d+' || echo "unknown")
        echo -e "${GREEN}✓ Installation verified (v$INSTALLED_VER)${ENDC}"
    else
        echo -e "${RED}✗ Installation verification failed${ENDC}"
        return 1
    fi
    
    if ! echo "$PATH" | grep -q "$INSTALL_DIR"; then
        echo -e "\n${YELLOW}⚠ Warning: $INSTALL_DIR is not in your PATH${ENDC}"
        echo -e "${YELLOW}Add the following to your ~/.bashrc or ~/.zshrc:${ENDC}"
        echo -e "${CYAN}export PATH=\"\$PATH:$INSTALL_DIR\"${ENDC}"
    fi
    
    if [[ ! -f "/usr/bin/$SCRIPT_NAME" ]]; then
        echo -e "\n${BLUE}Creating symlink in /usr/bin for compatibility...${ENDC}"
        if $SUDO_CMD ln -sf "$INSTALL_DIR/$SCRIPT_NAME" "/usr/bin/$SCRIPT_NAME" 2>/dev/null; then
            echo -e "${GREEN}✓ Symlink created in /usr/bin${ENDC}"
        else
            echo -e "${YELLOW}Note: Could not create symlink in /usr/bin (non-critical)${ENDC}"
        fi
    fi
    
    echo -e "\n${BOLD}${GREEN}═══════════════════════════════════════════════════════${ENDC}"
    echo -e "${BOLD}${GREEN}         Installation Completed Successfully!          ${ENDC}"
    echo -e "${BOLD}${GREEN}═══════════════════════════════════════════════════════${ENDC}"
    echo -e "\n${CYAN}You can now run PyDroidb from anywhere by typing:${ENDC}"
    echo -e "${BOLD}${YELLOW}  pydroidb${ENDC}"
    echo -e "\n${CYAN}Available commands:${ENDC}"
    echo -e "  ${GREEN}pydroidb${ENDC}           - Launch PyDroidb"
    echo -e "  ${GREEN}pydroidb --help${ENDC}     - Show help"
    echo -e "  ${GREEN}pydroidb --version${ENDC}  - Show version"
    echo -e "  ${GREEN}pydroidb --install${ENDC}  - Install/update system-wide"
    echo -e "  ${GREEN}pydroidb --uninstall${ENDC} - Remove system installation"
    
    return 0
}

uninstall_systemwide() {
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════${ENDC}"
    echo -e "${BOLD}${RED}        PyDroidb System-wide Uninstallation           ${ENDC}"
    echo -e "${BOLD}${RED}═══════════════════════════════════════════════════════${ENDC}"
    
    if [[ ! -f "$INSTALL_DIR/$SCRIPT_NAME" ]]; then
        echo -e "${YELLOW}PyDroidb is not installed system-wide.${ENDC}"
        return 0
    fi
    
    echo -e "${YELLOW}This will remove:${ENDC}"
    echo -e "  • $INSTALL_DIR/$SCRIPT_NAME"
    [[ -L "/usr/bin/$SCRIPT_NAME" ]] && echo -e "  • /usr/bin/$SCRIPT_NAME (symlink)"
    [[ -f "$INSTALL_DIR/${SCRIPT_NAME}.backup" ]] && echo -e "  • $INSTALL_DIR/${SCRIPT_NAME}.backup"
    
    read -p $'\n'"Confirm uninstallation? (y/N): " CONFIRM
    if [[ ! "$CONFIRM" =~ ^[Yy] ]]; then
        echo -e "${GREEN}Uninstallation cancelled.${ENDC}"
        return 0
    fi
    
    if [[ $EUID -ne 0 ]]; then
        echo -e "${YELLOW}Uninstallation requires sudo privileges.${ENDC}"
        SUDO_CMD="sudo"
        if ! sudo -v 2>/dev/null; then
            echo -e "${RED}Failed to obtain sudo privileges.${ENDC}"
            return 1
        fi
    else
        SUDO_CMD=""
    fi
    
    echo -e "${BLUE}Removing $INSTALL_DIR/$SCRIPT_NAME...${ENDC}"
    if $SUDO_CMD rm -f "$INSTALL_DIR/$SCRIPT_NAME" 2>/dev/null; then
        echo -e "${GREEN}✓ Script removed${ENDC}"
    else
        echo -e "${RED}✗ Failed to remove script${ENDC}"
    fi
    
    if [[ -L "/usr/bin/$SCRIPT_NAME" ]]; then
        echo -e "${BLUE}Removing /usr/bin/$SCRIPT_NAME symlink...${ENDC}"
        $SUDO_CMD rm -f "/usr/bin/$SCRIPT_NAME" 2>/dev/null
        echo -e "${GREEN}✓ Symlink removed${ENDC}"
    fi
    
    if [[ -f "$INSTALL_DIR/${SCRIPT_NAME}.backup" ]]; then
        echo -e "${BLUE}Removing backup...${ENDC}"
        $SUDO_CMD rm -f "$INSTALL_DIR/${SCRIPT_NAME}.backup" 2>/dev/null
        echo -e "${GREEN}✓ Backup removed${ENDC}"
    fi
    
    echo -e "\n${BOLD}${GREEN}Uninstallation completed successfully!${ENDC}"
    return 0
}

show_version() {
    echo -e "${BOLD}${CYAN}PyDroidb${ENDC} - ADB, Fastboot, GSI & Samsung Automation Tool"
    echo -e "Version: ${GREEN}$VERSION${ENDC}"
    echo -e "Author: ${YELLOW}0xbv1 | 0xb0rn3${ENDC}"
    
    check_installation
    case $? in
        0) echo -e "Status: ${GREEN}Installed system-wide${ENDC}" ;;
        1) echo -e "Status: ${YELLOW}Installed but running from different location${ENDC}" ;;
        2) echo -e "Status: ${YELLOW}Not installed system-wide${ENDC}" ;;
    esac
}

show_help() {
    echo -e "${BOLD}${CYAN}PyDroidb - Advanced Android Device Manager${ENDC}"
    echo -e "${GREEN}Version $VERSION${ENDC}"
    echo ""
    echo -e "${BOLD}USAGE:${ENDC}"
    echo -e "  ${CYAN}pydroidb${ENDC} [OPTIONS]"
    echo ""
    echo -e "${BOLD}OPTIONS:${ENDC}"
    echo -e "  ${GREEN}(none)${ENDC}         Launch interactive menu"
    echo -e "  ${GREEN}--help, -h${ENDC}     Show this help message"
    echo -e "  ${GREEN}--version, -v${ENDC}  Show version information"
    echo -e "  ${GREEN}--install${ENDC}      Install PyDroidb system-wide"
    echo -e "  ${GREEN}--uninstall${ENDC}    Remove system-wide installation"
    echo -e "  ${GREEN}--check-deps${ENDC}   Check and install dependencies only"
    echo ""
    echo -e "${BOLD}FEATURES:${ENDC}"
    echo -e "  • Complete ADB & Fastboot operations"
    echo -e "  • GSI (Generic System Image) flashing support"
    echo -e "  • Samsung device support (Odin4/Heimdall)"
    echo -e "  • MediaTek device recovery"
    echo -e "  • File management & APK installation"
    echo -e "  • System operations & debugging"
    echo -e "  • Custom recovery & firmware flashing"
    echo -e "  • Screenshot & screen recording"
    echo -e "  • Device backup & restore"
    echo ""
    echo -e "${BOLD}EXAMPLES:${ENDC}"
    echo -e "  ${CYAN}pydroidb${ENDC}              # Start interactive mode"
    echo -e "  ${CYAN}pydroidb --install${ENDC}    # Install system-wide"
    echo -e "  ${CYAN}sudo pydroidb${ENDC}         # Run with elevated privileges"
    echo ""
    echo -e "${BOLD}DOCUMENTATION:${ENDC}"
    echo -e "  ${BLUE}https://github.com/0xb0rn3/pydroidb${ENDC}"
}

# Core utility functions
clear_screen() {
    clear
}

display_info() {
    echo -e "${BOLD}${BLUE}PyDroidb: ADB, Fastboot, GSI & Samsung Automation Tool v${VERSION}${ENDC}"
    echo -e "${GREEN}Author: 0xbv1 | 0xb0rn3${ENDC}"
    echo -e "${GREEN}GitHub: https://github.com/0xb0rn3/pydroidb${ENDC}"
    echo -e "${GREEN}Platform: $(uname -s) $(uname -m)${ENDC}"
    
    check_installation
    case $? in
        0) echo -e "${GREEN}Installation: System-wide (/usr/bin/pydroidb)${ENDC}" ;;
        1) echo -e "${YELLOW}Installation: System-wide (different version)${ENDC}" ;;
        2) echo -e "${YELLOW}Installation: Local only - run with --install for system-wide${ENDC}" ;;
    esac
    
    echo -e "${YELLOW}Samsung Support: Odin4 + Heimdall Integrated${ENDC}"
    echo -e "${CYAN}GSI Support: MediaTek & Qualcomm Recovery${ENDC}"
    echo -e "${RED}${BOLD}============================[ SAFETY WARNING ]============================${ENDC}"
    echo -e "${RED}This tool modifies device firmware and can cause permanent damage if used incorrectly.${ENDC}"
    echo -e "${RED}Samsung operations may void warranty and trigger Knox security features.${ENDC}"
    echo -e "${RED}GSI flashing requires unlocked bootloader and may brick your device.${ENDC}"
    echo -e "${RED}Always back up data and have official recovery images. USE AT YOUR OWN RISK.${ENDC}"
    echo -e "${RED}${BOLD}=========================================================================${ENDC}"
    read -p "Press Enter to continue..."
}

install_dependencies() {
    echo -e "${BLUE}Installing core dependencies...${ENDC}"
    
    if [[ -f /etc/debian_version ]]; then
        INSTALL_CMD="sudo apt update && sudo apt install -y"
        PACKAGES="android-tools-adb android-tools-fastboot curl unzip wget libusb-1.0-0 libusb-1.0-0-dev"
    elif [[ -f /etc/redhat-release ]]; then
        INSTALL_CMD="sudo dnf install -y"
        PACKAGES="android-tools curl unzip wget libusb libusb-devel"
    elif [[ -f /etc/arch-release ]]; then
        INSTALL_CMD="sudo pacman -S --noconfirm"
        PACKAGES="android-tools curl unzip wget libusb"
    elif [[ -f /etc/SuSE-release ]]; then
        INSTALL_CMD="sudo zypper install -y"
        PACKAGES="android-tools curl unzip wget libusb-1_0-0 libusb-1_0-devel"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v brew &>/dev/null; then
            INSTALL_CMD="brew install"
            PACKAGES="android-platform-tools curl wget libusb"
        else
            echo -e "${RED}Homebrew required. Install from https://brew.sh${ENDC}"
            return 1
        fi
    else
        echo -e "${RED}Unsupported OS for automatic installation.${ENDC}"
        return 1
    fi
    
    eval "$INSTALL_CMD $PACKAGES"
}

setup_samsung_drivers() {
    if [[ "$OSTYPE" != "linux-gnu"* ]]; then
        echo -e "${YELLOW}Samsung drivers setup is Linux-specific.${ENDC}"
        return 0
    fi
    
    echo -e "${BLUE}Setting up Samsung device drivers...${ENDC}"
    
    UDEV_FILE="/etc/udev/rules.d/51-android-samsung.rules"
    if [[ ! -f "$UDEV_FILE" ]] || ! grep -q "04e8" "$UDEV_FILE" 2>/dev/null; then
        echo -e "${BLUE}Creating Samsung udev rules...${ENDC}"
        sudo tee "$UDEV_FILE" > /dev/null << 'EOF'
# Samsung devices
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", MODE="0666", GROUP="plugdev"
# Samsung download mode
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="685d", MODE="0666", GROUP="plugdev"
# Samsung mobile devices
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="6860", MODE="0666", GROUP="plugdev"
# Samsung composite devices
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="6864", MODE="0666", GROUP="plugdev"
EOF
        sudo udevadm control --reload-rules 2>/dev/null
        sudo udevadm trigger 2>/dev/null
        echo -e "${GREEN}Samsung udev rules created.${ENDC}"
    fi
    
    if ! groups $USER | grep -q plugdev 2>/dev/null; then
        echo -e "${BLUE}Adding user to plugdev group...${ENDC}"
        sudo usermod -a -G plugdev $USER 2>/dev/null
        echo -e "${YELLOW}Please log out and log back in for group changes to take effect.${ENDC}"
    fi
}

install_odin4() {
    if [[ "$OSTYPE" != "linux-gnu"* ]]; then
        echo -e "${YELLOW}Odin4 is only available for Linux.${ENDC}"
        return 1
    fi
    
    if command -v odin4 &>/dev/null; then
        echo -e "${GREEN}Odin4 already installed.${ENDC}"
        ODIN4_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Odin4Linux...${ENDC}"
    echo -e "${YELLOW}Note: This requires manual download from GitHub releases${ENDC}"
    echo -e "${YELLOW}Visit: https://github.com/amo13/Odin4/releases${ENDC}"
    
    read -p "Have you downloaded Odin4 Linux binary? (y/N): " DOWNLOADED
    if [[ ! "$DOWNLOADED" =~ ^[Yy] ]]; then
        echo -e "${YELLOW}Please download Odin4 Linux binary and retry.${ENDC}"
        return 1
    fi
    
    read -p "Enter path to Odin4 binary: " ODIN4_PATH
    if [[ ! -f "$ODIN4_PATH" ]]; then
        echo -e "${RED}Odin4 binary not found: $ODIN4_PATH${ENDC}"
        return 1
    fi
    
    sudo cp "$ODIN4_PATH" /usr/local/bin/odin4 2>/dev/null
    sudo chmod +x /usr/local/bin/odin4 2>/dev/null
    
    if command -v odin4 &>/dev/null; then
        echo -e "${GREEN}Odin4 installed successfully.${ENDC}"
        ODIN4_INSTALLED=true
    else
        echo -e "${RED}Odin4 installation failed.${ENDC}"
        return 1
    fi
}

install_heimdall() {
    if command -v heimdall &>/dev/null; then
        echo -e "${GREEN}Heimdall already installed.${ENDC}"
        HEIMDALL_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Heimdall...${ENDC}"
    
    if [[ -f /etc/debian_version ]]; then
        sudo apt update && sudo apt install -y heimdall-flash
    elif [[ -f /etc/redhat-release ]]; then
        sudo dnf install -y heimdall
    elif [[ -f /etc/arch-release ]]; then
        sudo pacman -S --noconfirm heimdall
    elif [[ -f /etc/SuSE-release ]]; then
        sudo zypper install -y heimdall
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v brew &>/dev/null; then
            brew install heimdall
        else
            echo -e "${RED}Homebrew required for macOS installation.${ENDC}"
            return 1
        fi
    else
        echo -e "${RED}Unsupported OS for automatic Heimdall installation.${ENDC}"
        return 1
    fi
    
    if command -v heimdall &>/dev/null; then
        echo -e "${GREEN}Heimdall installed successfully.${ENDC}"
        HEIMDALL_INSTALLED=true
    else
        echo -e "${RED}Heimdall installation failed.${ENDC}"
        return 1
    fi
}

detect_samsung_download_mode() {
    echo -e "${BLUE}Scanning for Samsung devices in download mode...${ENDC}"
    
    SAMSUNG_DEVICES=()
    
    if [[ $ODIN4_INSTALLED == true ]]; then
        echo -e "${BLUE}Checking with Odin4...${ENDC}"
        if sudo odin4 --detect 2>/dev/null | grep -q "Device detected"; then
            SAMSUNG_DEVICES+=("ODIN4: Samsung device detected")
        fi
    fi
    
    if [[ $HEIMDALL_INSTALLED == true ]]; then
        echo -e "${BLUE}Checking with Heimdall...${ENDC}"
        if heimdall detect 2>/dev/null | grep -q "Device detected"; then
            SAMSUNG_DEVICES+=("HEIMDALL: Samsung device detected")
        fi
    fi
    
    if command -v lsusb &>/dev/null; then
        USB_SAMSUNG=$(lsusb 2>/dev/null | grep "04e8:")
        if [[ -n "$USB_SAMSUNG" ]]; then
            SAMSUNG_DEVICES+=("USB: $USB_SAMSUNG")
        fi
    fi
    
    if [[ ${#SAMSUNG_DEVICES[@]} -eq 0 ]]; then
        echo -e "${RED}No Samsung devices found in download mode.${ENDC}"
        echo -e "${YELLOW}To enter download mode:${ENDC}"
        echo -e "${YELLOW}1. Power off device completely${ENDC}"
        echo -e "${YELLOW}2. Hold Volume Down + Power + Home (older devices)${ENDC}"
        echo -e "${YELLOW}3. Hold Volume Down + Power (newer devices)${ENDC}"
        echo -e "${YELLOW}4. Press Volume Up when prompted${ENDC}"
        return 1
    fi
    
    echo -e "${GREEN}Found ${#SAMSUNG_DEVICES[@]} Samsung device(s):${ENDC}"
    for i in "${!SAMSUNG_DEVICES[@]}"; do
        echo -e "${GREEN}$((i+1)). ${SAMSUNG_DEVICES[i]}${ENDC}"
    done
    
    return 0
}

check_requirements() {
    echo -e "${BLUE}Checking requirements...${ENDC}"
    
    if ! command -v adb &>/dev/null || ! command -v fastboot &>/dev/null; then
        echo -e "${BLUE}Installing Android SDK Platform-Tools...${ENDC}"
        install_dependencies
    else
        echo -e "${GREEN}Requirements satisfied, skipping installation.${ENDC}"
    fi
    
    ADB=$(command -v adb)
    FASTBOOT=$(command -v fastboot)
    
    if [[ -n "$ADB" && -n "$FASTBOOT" ]]; then
        ADB_VERSION=$($ADB version | head -1 2>/dev/null)
        FASTBOOT_VERSION=$($FASTBOOT --version | head -1 2>/dev/null)
        echo -e "${BLUE}ADB: $ADB_VERSION${ENDC}"
        echo -e "${BLUE}Fastboot: $FASTBOOT_VERSION${ENDC}"
        $ADB start-server &>/dev/null && echo -e "${GREEN}ADB server started.${ENDC}"
    fi
    
    setup_samsung_drivers
    
    echo -e "${BLUE}Setting up Samsung tools...${ENDC}"
    install_odin4
    install_heimdall
    
    echo -e "${GREEN}════════════════════════════════════════════════════════${ENDC}"
    echo -e "${GREEN}Tool Status Summary:${ENDC}"
    echo -e "ADB/Fastboot: ${GREEN}✓ Installed${ENDC}"
    [[ $ODIN4_INSTALLED == true ]] && echo -e "Odin4: ${GREEN}✓ Installed${ENDC}" || echo -e "Odin4: ${RED}✗ Not Available${ENDC}"
    [[ $HEIMDALL_INSTALLED == true ]] && echo -e "Heimdall: ${GREEN}✓ Installed${ENDC}" || echo -e "Heimdall: ${RED}✗ Not Available${ENDC}"
    echo -e "${GREEN}════════════════════════════════════════════════════════${ENDC}"
}

get_device_info() {
    echo -e "${BLUE}Scanning devices...${ENDC}"
    DEVICES=$($ADB devices 2>/dev/null | tail -n +2 | grep -v "^$" | awk '{print $1 "\t" $2}')
    if [[ -z "$DEVICES" ]]; then
        echo -e "${RED}No devices detected. Ensure USB debugging is enabled and device is authorized.${ENDC}"
        DEVICE_INFO=""
        return 1
    fi
    DEVICE_COUNT=$(echo "$DEVICES" | wc -l)
    if [[ $DEVICE_COUNT -gt 1 ]]; then
        echo -e "${GREEN}Multiple devices connected:${ENDC}"
        echo "$DEVICES" | nl -w 2 -s '. '
        while true; do
            read -p "Select device (number): " CHOICE
            if [[ $CHOICE =~ ^[0-9]+$ ]] && [[ $CHOICE -ge 1 ]] && [[ $CHOICE -le $DEVICE_COUNT ]]; then
                SERIAL=$(echo "$DEVICES" | sed -n "${CHOICE}p" | awk '{print $1}')
                STATE=$(echo "$DEVICES" | sed -n "${CHOICE}p" | awk '{print $2}')
                break
            else
                echo -e "${RED}Invalid selection.${ENDC}"
            fi
        done
    else
        SERIAL=$(echo "$DEVICES" | awk '{print $1}')
        STATE=$(echo "$DEVICES" | awk '{print $2}')
    fi
    if [[ "$STATE" == "unauthorized" ]]; then
        echo -e "${RED}${BOLD}Device $SERIAL unauthorized. Authorize on device screen.${ENDC}"
        DEVICE_INFO="serial=$SERIAL model=Unknown android_version=Unknown sdk_version=Unknown bootloader_version=Unknown kernel_version=Unknown manufacturer=Unknown architecture=Unknown state=$STATE"
        return 0
    fi
    MODEL=$($ADB -s $SERIAL shell getprop ro.product.model 2>/dev/null | tr -d '\r')
    ANDROID_VERSION=$($ADB -s $SERIAL shell getprop ro.build.version.release 2>/dev/null | tr -d '\r')
    SDK_VERSION=$($ADB -s $SERIAL shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r')
    BOOTLOADER_VERSION=$($ADB -s $SERIAL shell getprop ro.bootloader 2>/dev/null | tr -d '\r')
    KERNEL_VERSION=$($ADB -s $SERIAL shell cat /proc/version 2>/dev/null | tr -d '\r')
    MANUFACTURER=$($ADB -s $SERIAL shell getprop ro.product.manufacturer 2>/dev/null | tr -d '\r')
    ARCHITECTURE=$($ADB -s $SERIAL shell getprop ro.product.cpu.abi 2>/dev/null | tr -d '\r')
    
    # Check for GSI/Treble support
    TREBLE_ENABLED=$($ADB -s $SERIAL shell getprop ro.treble.enabled 2>/dev/null | tr -d '\r')
    AB_UPDATE=$($ADB -s $SERIAL shell getprop ro.build.ab_update 2>/dev/null | tr -d '\r')
    
    DEVICE_INFO="serial=$SERIAL model=$MODEL android_version=$ANDROID_VERSION sdk_version=$SDK_VERSION bootloader_version=$BOOTLOADER_VERSION kernel_version=$KERNEL_VERSION manufacturer=$MANUFACTURER architecture=$ARCHITECTURE state=$STATE treble=$TREBLE_ENABLED ab_update=$AB_UPDATE"
    echo -e "${GREEN}Device info gathered.${ENDC}"
}

display_device_info() {
    clear_screen
    if [[ -z "$DEVICE_INFO" ]]; then
        echo -e "${RED}No device info available. Connect a device.${ENDC}"
        read -p "Press Enter to return..."
        return
    fi
    echo -e "\n${BOLD}${GREEN}CONNECTED DEVICE INFORMATION${ENDC}"
    echo "=================================================="
    echo -e "${BOLD}Serial:${ENDC}           $(echo $DEVICE_INFO | grep -oP 'serial=\K[^ ]+')"
    echo -e "${BOLD}Manufacturer:${ENDC}     $(echo $DEVICE_INFO | grep -oP 'manufacturer=\K[^ ]+')"
    echo -e "${BOLD}Model:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+')"
    echo -e "${BOLD}Android Version:${ENDC}  $(echo $DEVICE_INFO | grep -oP 'android_version=\K[^ ]+')"
    echo -e "${BOLD}SDK Version:${ENDC}      $(echo $DEVICE_INFO | grep -oP 'sdk_version=\K[^ ]+')"
    echo -e "${BOLD}Architecture:${ENDC}     $(echo $DEVICE_INFO | grep -oP 'architecture=\K[^ ]+')"
    echo -e "${BOLD}Bootloader:${ENDC}       $(echo $DEVICE_INFO | grep -oP 'bootloader_version=\K[^ ]+')"
    echo -e "${BOLD}Kernel:${ENDC}           $(echo $DEVICE_INFO | grep -oP 'kernel_version=\K.+')"
    echo -e "${BOLD}State:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+')"
    
    # GSI/Treble info
    TREBLE=$(echo $DEVICE_INFO | grep -oP 'treble=\K[^ ]+')
    AB=$(echo $DEVICE_INFO | grep -oP 'ab_update=\K[^ ]+')
    if [[ "$TREBLE" == "true" ]]; then
        echo -e "${BOLD}Treble:${ENDC}           ${GREEN}Supported (GSI Compatible)${ENDC}"
    else
        echo -e "${BOLD}Treble:${ENDC}           ${RED}Not Supported${ENDC}"
    fi
    if [[ "$AB" == "true" ]]; then
        echo -e "${BOLD}A/B Partition:${ENDC}    ${GREEN}Yes (Seamless Updates)${ENDC}"
    else
        echo -e "${BOLD}A/B Partition:${ENDC}    No (A-only)"
    fi
    echo "=================================================="
    read -p "Press Enter to return..."
}

confirm_action() {
    read -p "${BOLD}${GREEN}CONFIRMATION: $1 (y/N): ${ENDC}" RESPONSE
    RESPONSE=$(echo "$RESPONSE" | tr '[:upper:]' '[:lower:]')
    if [[ "$RESPONSE" == "y" || "$RESPONSE" == "yes" ]]; then
        return 0
    else
        echo -e "${RED}Operation cancelled.${ENDC}"
        return 1
    fi
}

run_command() {
    local cmd="$1"
    local timeout="${2:-$DEFAULT_TIMEOUT}"
    echo -e "${BLUE}Executing: $cmd${ENDC}"
    
    OUTPUT=$(timeout $timeout bash -c "$cmd" 2>&1)
    STATUS=$?
    if [[ $STATUS -eq 124 ]]; then
        echo -e "${RED}Command timed out after $timeout seconds${ENDC}"
        return 124
    elif [[ $STATUS -eq 0 ]]; then
        [[ -n "$OUTPUT" ]] && echo -e "${GREEN}$OUTPUT${ENDC}"
        return 0
    else
        echo -e "${RED}Error: $OUTPUT${ENDC}"
        return $STATUS
    fi
}

# File operations
push_file() {
    read -p "Local file path: " LOCAL_PATH
    if [[ ! -f "$LOCAL_PATH" ]]; then
        echo -e "${RED}File does not exist.${ENDC}"
        return
    fi
    FILE_SIZE=$(stat -c%s "$LOCAL_PATH" 2>/dev/null || stat -f%z "$LOCAL_PATH" 2>/dev/null)
    echo -e "${BLUE}File size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    read -p "Device destination path (e.g., /sdcard/): " REMOTE_PATH
    if ! $ADB -s $SERIAL shell test -d "$(dirname "$REMOTE_PATH")" 2>/dev/null; then
        echo -e "${RED}Destination directory does not exist on device.${ENDC}"
        return
    fi
    run_command "$ADB -s $SERIAL push \"$LOCAL_PATH\" \"$REMOTE_PATH\"" $FILE_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}File pushed successfully.${ENDC}"
}

pull_file() {
    read -p "Device file path: " REMOTE_PATH
    if ! $ADB -s $SERIAL shell test -f "$REMOTE_PATH" 2>/dev/null; then
        echo -e "${RED}File does not exist on device.${ENDC}"
        return
    fi
    FILE_SIZE=$($ADB -s $SERIAL shell stat -c%s "$REMOTE_PATH" 2>/dev/null)
    [[ -n "$FILE_SIZE" ]] && echo -e "${BLUE}File size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    read -p "Local destination path: " LOCAL_PATH
    run_command "$ADB -s $SERIAL pull \"$REMOTE_PATH\" \"$LOCAL_PATH\"" $FILE_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}File pulled successfully.${ENDC}"
}

batch_push() {
    read -p "Local directory path: " LOCAL_DIR
    if [[ ! -d "$LOCAL_DIR" ]]; then
        echo -e "${RED}Directory does not exist.${ENDC}"
        return
    fi
    read -p "Device destination directory (e.g., /sdcard/): " REMOTE_DIR
    if ! $ADB -s $SERIAL shell test -d "$REMOTE_DIR" 2>/dev/null; then
        echo -e "${RED}Destination directory does not exist on device.${ENDC}"
        return
    fi
    FILE_COUNT=$(find "$LOCAL_DIR" -type f | wc -l)
    echo -e "${BLUE}Found $FILE_COUNT files to push${ENDC}"
    confirm_action "Push $FILE_COUNT files?" || return
    CURRENT=0
    for FILE in "$LOCAL_DIR"/*; do
        if [[ -f "$FILE" ]]; then
            CURRENT=$((CURRENT + 1))
            echo -e "${BLUE}[$CURRENT/$FILE_COUNT] Pushing $(basename "$FILE")...${ENDC}"
            run_command "$ADB -s $SERIAL push \"$FILE\" \"$REMOTE_DIR\"" $FILE_TIMEOUT
        fi
    done
    echo -e "${GREEN}Batch push complete: $CURRENT files processed.${ENDC}"
}

batch_pull() {
    read -p "Device directory path (e.g., /sdcard/Download/): " REMOTE_DIR
    if ! $ADB -s $SERIAL shell test -d "$REMOTE_DIR" 2>/dev/null; then
        echo -e "${RED}Directory does not exist on device.${ENDC}"
        return
    fi
    read -p "Local destination directory: " LOCAL_DIR
    mkdir -p "$LOCAL_DIR"
    FILES=$($ADB -s $SERIAL shell find "$REMOTE_DIR" -type f 2>/dev/null | tr -d '\r')
    FILE_COUNT=$(echo "$FILES" | wc -l)
    echo -e "${BLUE}Found $FILE_COUNT files to pull${ENDC}"
    confirm_action "Pull $FILE_COUNT files?" || return
    CURRENT=0
    while IFS= read -r FILE; do
        if [[ -n "$FILE" ]]; then
            CURRENT=$((CURRENT + 1))
            echo -e "${BLUE}[$CURRENT/$FILE_COUNT] Pulling $(basename "$FILE")...${ENDC}"
            run_command "$ADB -s $SERIAL pull \"$FILE\" \"$LOCAL_DIR\"" $FILE_TIMEOUT
        fi
    done <<< "$FILES"
    echo -e "${GREEN}Batch pull complete: $CURRENT files processed.${ENDC}"
}

install_apk() {
    read -p "APK file path: " APK_PATH
    if [[ ! -f "$APK_PATH" || ! "$APK_PATH" =~ \.apk$ ]]; then
        echo -e "${RED}Invalid APK file.${ENDC}"
        return
    fi
    FILE_SIZE=$(stat -c%s "$APK_PATH" 2>/dev/null || stat -f%z "$APK_PATH" 2>/dev/null)
    echo -e "${BLUE}APK: $(basename "$APK_PATH") Size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    if command -v aapt &>/dev/null; then
        PKG=$(aapt dump badging "$APK_PATH" 2>/dev/null | grep "package:" | sed "s/.*name='\([^']*\)'.*/\1/")
        [[ -n "$PKG" ]] && echo -e "${BLUE}Package: $PKG${ENDC}"
    fi
    OUTPUT=$(run_command "$ADB -s $SERIAL install -r \"$APK_PATH\"" $FILE_TIMEOUT)
    [[ $? -eq 0 && "$OUTPUT" =~ Success ]] && echo -e "${GREEN}APK installed: $(basename "$APK_PATH")${ENDC}" || echo -e "${RED}Installation failed.${ENDC}"
}

uninstall_package() {
    read -p "Package name (e.g., com.example.app): " PKG
    if [[ -z "$PKG" ]]; then
        echo -e "${RED}Package name required.${ENDC}"
        return
    fi
    if ! $ADB -s $SERIAL shell pm list packages 2>/dev/null | grep -q "package:$PKG"; then
        echo -e "${RED}Package not found: $PKG${ENDC}"
        return
    fi
    confirm_action "Uninstall $PKG?" || return
    OUTPUT=$(run_command "$ADB -s $SERIAL uninstall $PKG" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 && "$OUTPUT" =~ Success ]] && echo -e "${GREEN}Package uninstalled: $PKG${ENDC}" || echo -e "${RED}Uninstall failed.${ENDC}"
}

list_packages() {
    echo -e "${GREEN}Package List Options${ENDC}"
    echo "1. All packages"
    echo "2. System packages"
    echo "3. User packages"
    echo "4. Enabled packages"
    echo "5. Disabled packages"
    read -p "Select option (1-5): " CHOICE
    case $CHOICE in
        1) FILTER="" ;;
        2) FILTER="-s" ;;
        3) FILTER="-3" ;;
        4) FILTER="-e" ;;
        5) FILTER="-d" ;;
        *) echo -e "${RED}Invalid choice.${ENDC}"; return ;;
    esac
    OUTPUT=$(run_command "$ADB -s $SERIAL shell pm list packages $FILTER" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        PKG_COUNT=$(echo "$OUTPUT" | wc -l)
        echo -e "${GREEN}Found $PKG_COUNT packages:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT" | sed 's/package://' | sort
        echo "------------------------------------------------------------"
    else
        echo -e "${RED}Failed to list packages.${ENDC}"
    fi
}

list_device_directory() {
    read -p "Device directory path (default: /sdcard/): " DIR
    DIR=${DIR:-/sdcard/}
    if ! $ADB -s $SERIAL shell test -d "$DIR" 2>/dev/null; then
        echo -e "${RED}Directory does not exist on device.${ENDC}"
        return
    fi
    OUTPUT=$(run_command "$ADB -s $SERIAL shell ls -la \"$DIR\"" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Contents of $DIR:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT"
        echo "------------------------------------------------------------"
        FILE_COUNT=$(echo "$OUTPUT" | grep -c "^-")
        DIR_COUNT=$(echo "$OUTPUT" | grep -c "^d")
        echo -e "${BLUE}Summary: $DIR_COUNT directories, $FILE_COUNT files${ENDC}"
    else
        echo -e "${RED}Failed to list directory.${ENDC}"
    fi
}

pull_kernel() {
    echo -e "${BLUE}Gathering kernel info...${ENDC}"
    KERNEL_INFO=$(run_command "$ADB -s $SERIAL shell cat /proc/version" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        FILENAME="kernel_info_$TIMESTAMP.txt"
        {
            echo "Kernel Information Report"
            echo "Generated: $(date)"
            echo "Device: $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+')"
            echo "Serial: $(echo $DEVICE_INFO | grep -oP 'serial=\K[^ ]+')"
            echo -e "\nKernel Version"
            echo "$KERNEL_INFO"
            echo -e "\nCPU Information"
            $ADB -s $SERIAL shell cat /proc/cpuinfo 2>/dev/null
            echo -e "\nMemory Information"
            $ADB -s $SERIAL shell cat /proc/meminfo 2>/dev/null
        } > "$FILENAME"
        FILE_SIZE=$(stat -c%s "$FILENAME" 2>/dev/null || stat -f%z "$FILENAME" 2>/dev/null)
        echo -e "${GREEN}Kernel info saved to $FILENAME ($FILE_SIZE bytes)${ENDC}"
    else
        echo -e "${RED}Failed to pull kernel info.${ENDC}"
    fi
