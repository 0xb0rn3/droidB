#!/usr/bin/env bash

VERSION="0.1.0"
BLUE='\033[94m'
GREEN='\033[92m'
RED='\033[91m'
YELLOW='\033[93m'
BOLD='\033[1m'
ENDC='\033[0m'

# Timeout configurations
DEFAULT_TIMEOUT=60
FILE_TIMEOUT=300
BACKUP_TIMEOUT=3600
FASTBOOT_TIMEOUT=600
SAMSUNG_FLASH_TIMEOUT=1800
SAMSUNG_PIT_TIMEOUT=300
SAMSUNG_NAND_TIMEOUT=3600

# Samsung device configuration
SAMSUNG_VENDOR_ID="04e8"
ODIN4_INSTALLED=false
HEIMDALL_INSTALLED=false

clear_screen() {
    clear
}

display_info() {
    echo -e "${BOLD}${BLUE}Pydroidb: ADB, Fastboot & Samsung Automation Tool v${VERSION}${ENDC}"
    echo -e "${GREEN}Author: 0xbv1 | 0xb0rn3${ENDC}"
    echo -e "${GREEN}GitHub: https://github.com/0xb0rn3/pydroidb${ENDC}"
    echo -e "${GREEN}Platform: $(uname -s) $(uname -m)${ENDC}"
    echo -e "${YELLOW}Samsung Support: Odin4 + Heimdall Integrated${ENDC}"
    echo -e "${RED}${BOLD}============================[ SAFETY WARNING ]============================${ENDC}"
    echo -e "${RED}This tool modifies device firmware and can cause permanent damage if used incorrectly.${ENDC}"
    echo -e "${RED}Samsung operations may void warranty and trigger Knox security features.${ENDC}"
    echo -e "${RED}Always back up data and have official recovery images. USE AT YOUR OWN RISK.${ENDC}"
    echo -e "${RED}${BOLD}=========================================================================${ENDC}"
    read -p "Press Enter to continue..."
}

install_dependencies() {
    echo -e "${BLUE}Installing core dependencies...${ENDC}"
    
    if [[ -f /etc/debian_version ]]; then
        INSTALL_CMD="sudo apt update && sudo apt install -y"
        PACKAGES="android-tools-adb android-tools-fastboot curl unzip wget libusb-1.0-0 libusb-1.0-0-dev"
    elif [[ -f /etc/redhat-release ]]; then
        INSTALL_CMD="sudo dnf install -y"
        PACKAGES="android-tools curl unzip wget libusb libusb-devel"
    elif [[ -f /etc/arch-release ]]; then
        INSTALL_CMD="sudo pacman -S --noconfirm"
        PACKAGES="android-tools curl unzip wget libusb"
    elif [[ -f /etc/SuSE-release ]]; then
        INSTALL_CMD="sudo zypper install -y"
        PACKAGES="android-tools curl unzip wget libusb-1_0-0 libusb-1_0-devel"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v brew &>/dev/null; then
            INSTALL_CMD="brew install"
            PACKAGES="android-platform-tools curl wget libusb"
        else
            echo -e "${RED}Homebrew required. Install from https://brew.sh${ENDC}"
            return 1
        fi
    else
        echo -e "${RED}Unsupported OS for automatic installation.${ENDC}"
        return 1
    fi
    
    eval "$INSTALL_CMD $PACKAGES"
}

setup_samsung_drivers() {
    if [[ "$OSTYPE" != "linux-gnu"* ]]; then
        echo -e "${YELLOW}Samsung drivers setup is Linux-specific.${ENDC}"
        return 0
    fi
    
    echo -e "${BLUE}Setting up Samsung device drivers...${ENDC}"
    
    # Create udev rules for Samsung devices
    UDEV_FILE="/etc/udev/rules.d/51-android-samsung.rules"
    if [[ ! -f "$UDEV_FILE" ]] || ! grep -q "04e8" "$UDEV_FILE" 2>/dev/null; then
        echo -e "${BLUE}Creating Samsung udev rules...${ENDC}"
        sudo tee "$UDEV_FILE" > /dev/null << 'EOF'
# Samsung devices
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", MODE="0666", GROUP="plugdev"
# Samsung download mode
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="685d", MODE="0666", GROUP="plugdev"
# Samsung mobile devices
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="6860", MODE="0666", GROUP="plugdev"
# Samsung composite devices
SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", ATTR{idProduct}=="6864", MODE="0666", GROUP="plugdev"
EOF
        sudo udevadm control --reload-rules 2>/dev/null
        sudo udevadm trigger 2>/dev/null
        echo -e "${GREEN}Samsung udev rules created.${ENDC}"
    fi
    
    # Add user to plugdev group
    if ! groups $USER | grep -q plugdev 2>/dev/null; then
        echo -e "${BLUE}Adding user to plugdev group...${ENDC}"
        sudo usermod -a -G plugdev $USER 2>/dev/null
        echo -e "${YELLOW}Please log out and log back in for group changes to take effect.${ENDC}"
    fi
}

install_odin4() {
    if [[ "$OSTYPE" != "linux-gnu"* ]]; then
        echo -e "${YELLOW}Odin4 is only available for Linux.${ENDC}"
        return 1
    fi
    
    if command -v odin4 &>/dev/null; then
        echo -e "${GREEN}Odin4 already installed.${ENDC}"
        ODIN4_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Odin4Linux...${ENDC}"
    echo -e "${YELLOW}Note: This requires manual download from GitHub releases${ENDC}"
    echo -e "${YELLOW}Visit: https://github.com/amo13/Odin4/releases${ENDC}"
    
    read -p "Have you downloaded Odin4 Linux binary? (y/N): " DOWNLOADED
    if [[ ! "$DOWNLOADED" =~ ^[Yy] ]]; then
        echo -e "${YELLOW}Please download Odin4 Linux binary and retry.${ENDC}"
        return 1
    fi
    
    read -p "Enter path to Odin4 binary: " ODIN4_PATH
    if [[ ! -f "$ODIN4_PATH" ]]; then
        echo -e "${RED}Odin4 binary not found: $ODIN4_PATH${ENDC}"
        return 1
    fi
    
    sudo cp "$ODIN4_PATH" /usr/local/bin/odin4 2>/dev/null
    sudo chmod +x /usr/local/bin/odin4 2>/dev/null
    
    if command -v odin4 &>/dev/null; then
        echo -e "${GREEN}Odin4 installed successfully.${ENDC}"
        ODIN4_INSTALLED=true
    else
        echo -e "${RED}Odin4 installation failed.${ENDC}"
        return 1
    fi
}

install_heimdall() {
    if command -v heimdall &>/dev/null; then
        echo -e "${GREEN}Heimdall already installed.${ENDC}"
        HEIMDALL_INSTALLED=true
        return 0
    fi
    
    echo -e "${BLUE}Installing Heimdall...${ENDC}"
    
    if [[ -f /etc/debian_version ]]; then
        sudo apt update && sudo apt install -y heimdall-flash
    elif [[ -f /etc/redhat-release ]]; then
        sudo dnf install -y heimdall
    elif [[ -f /etc/arch-release ]]; then
        sudo pacman -S --noconfirm heimdall
    elif [[ -f /etc/SuSE-release ]]; then
        sudo zypper install -y heimdall
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        if command -v brew &>/dev/null; then
            brew install heimdall
        else
            echo -e "${RED}Homebrew required for macOS installation.${ENDC}"
            return 1
        fi
    else
        echo -e "${RED}Unsupported OS for automatic Heimdall installation.${ENDC}"
        return 1
    fi
    
    if command -v heimdall &>/dev/null; then
        echo -e "${GREEN}Heimdall installed successfully.${ENDC}"
        HEIMDALL_INSTALLED=true
    else
        echo -e "${RED}Heimdall installation failed.${ENDC}"
        return 1
    fi
}

detect_samsung_download_mode() {
    echo -e "${BLUE}Scanning for Samsung devices in download mode...${ENDC}"
    
    SAMSUNG_DEVICES=()
    
    # Try Odin4 detection first
    if [[ $ODIN4_INSTALLED == true ]]; then
        echo -e "${BLUE}Checking with Odin4...${ENDC}"
        if sudo odin4 --detect 2>/dev/null | grep -q "Device detected"; then
            SAMSUNG_DEVICES+=("ODIN4: Samsung device detected")
        fi
    fi
    
    # Try Heimdall detection
    if [[ $HEIMDALL_INSTALLED == true ]]; then
        echo -e "${BLUE}Checking with Heimdall...${ENDC}"
        if heimdall detect 2>/dev/null | grep -q "Device detected"; then
            SAMSUNG_DEVICES+=("HEIMDALL: Samsung device detected")
        fi
    fi
    
    # Manual USB detection fallback
    if command -v lsusb &>/dev/null; then
        USB_SAMSUNG=$(lsusb 2>/dev/null | grep "04e8:")
        if [[ -n "$USB_SAMSUNG" ]]; then
            SAMSUNG_DEVICES+=("USB: $USB_SAMSUNG")
        fi
    fi
    
    if [[ ${#SAMSUNG_DEVICES[@]} -eq 0 ]]; then
        echo -e "${RED}No Samsung devices found in download mode.${ENDC}"
        echo -e "${YELLOW}To enter download mode:${ENDC}"
        echo -e "${YELLOW}1. Power off device completely${ENDC}"
        echo -e "${YELLOW}2. Hold Volume Down + Power + Home (older devices)${ENDC}"
        echo -e "${YELLOW}3. Hold Volume Down + Power (newer devices)${ENDC}"
        echo -e "${YELLOW}4. Press Volume Up when prompted${ENDC}"
        return 1
    fi
    
    echo -e "${GREEN}Found ${#SAMSUNG_DEVICES[@]} Samsung device(s):${ENDC}"
    for i in "${!SAMSUNG_DEVICES[@]}"; do
        echo -e "${GREEN}$((i+1)). ${SAMSUNG_DEVICES[i]}${ENDC}"
    done
    
    return 0
}

check_requirements() {
    echo -e "${BLUE}Checking requirements...${ENDC}"
    
    # Check for core Android tools
    if ! command -v adb &>/dev/null || ! command -v fastboot &>/dev/null; then
        echo -e "${BLUE}Installing Android SDK Platform-Tools...${ENDC}"
        install_dependencies
    else
        echo -e "${GREEN}Requirements satisfied, skipping installation.${ENDC}"
    fi
    
    ADB=$(command -v adb)
    FASTBOOT=$(command -v fastboot)
    
    if [[ -n "$ADB" && -n "$FASTBOOT" ]]; then
        ADB_VERSION=$($ADB version | head -1 2>/dev/null)
        FASTBOOT_VERSION=$($FASTBOOT --version | head -1 2>/dev/null)
        echo -e "${BLUE}ADB: $ADB_VERSION${ENDC}"
        echo -e "${BLUE}Fastboot: $FASTBOOT_VERSION${ENDC}"
        $ADB start-server &>/dev/null && echo -e "${GREEN}ADB server started.${ENDC}"
    fi
    
    # Setup Samsung support
    setup_samsung_drivers
    
    # Install Samsung tools
    echo -e "${BLUE}Setting up Samsung tools...${ENDC}"
    install_odin4
    install_heimdall
    
    # Summary
    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${ENDC}"
    echo -e "${GREEN}Tool Status Summary:${ENDC}"
    echo -e "ADB/Fastboot: ${GREEN}‚úì Installed${ENDC}"
    [[ $ODIN4_INSTALLED == true ]] && echo -e "Odin4: ${GREEN}‚úì Installed${ENDC}" || echo -e "Odin4: ${RED}‚úó Not Available${ENDC}"
    [[ $HEIMDALL_INSTALLED == true ]] && echo -e "Heimdall: ${GREEN}‚úì Installed${ENDC}" || echo -e "Heimdall: ${RED}‚úó Not Available${ENDC}"
    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${ENDC}"
}

get_device_info() {
    echo -e "${BLUE}Scanning devices...${ENDC}"
    DEVICES=$($ADB devices 2>/dev/null | tail -n +2 | grep -v "^$" | awk '{print $1 "\t" $2}')
    if [[ -z "$DEVICES" ]]; then
        echo -e "${RED}No devices detected. Ensure USB debugging is enabled and device is authorized.${ENDC}"
        DEVICE_INFO=""
        return 1
    fi
    DEVICE_COUNT=$(echo "$DEVICES" | wc -l)
    if [[ $DEVICE_COUNT -gt 1 ]]; then
        echo -e "${GREEN}Multiple devices connected:${ENDC}"
        echo "$DEVICES" | nl -w 2 -s '. '
        while true; do
            read -p "Select device (number): " CHOICE
            if [[ $CHOICE =~ ^[0-9]+$ ]] && [[ $CHOICE -ge 1 ]] && [[ $CHOICE -le $DEVICE_COUNT ]]; then
                SERIAL=$(echo "$DEVICES" | sed -n "${CHOICE}p" | awk '{print $1}')
                STATE=$(echo "$DEVICES" | sed -n "${CHOICE}p" | awk '{print $2}')
                break
            else
                echo -e "${RED}Invalid selection.${ENDC}"
            fi
        done
    else
        SERIAL=$(echo "$DEVICES" | awk '{print $1}')
        STATE=$(echo "$DEVICES" | awk '{print $2}')
    fi
    if [[ "$STATE" == "unauthorized" ]]; then
        echo -e "${RED}${BOLD}Device $SERIAL unauthorized. Authorize on device screen.${ENDC}"
        DEVICE_INFO="serial=$SERIAL model=Unknown android_version=Unknown sdk_version=Unknown bootloader_version=Unknown kernel_version=Unknown manufacturer=Unknown architecture=Unknown state=$STATE"
        return 0
    fi
    MODEL=$($ADB -s $SERIAL shell getprop ro.product.model 2>/dev/null | tr -d '\r')
    ANDROID_VERSION=$($ADB -s $SERIAL shell getprop ro.build.version.release 2>/dev/null | tr -d '\r')
    SDK_VERSION=$($ADB -s $SERIAL shell getprop ro.build.version.sdk 2>/dev/null | tr -d '\r')
    BOOTLOADER_VERSION=$($ADB -s $SERIAL shell getprop ro.bootloader 2>/dev/null | tr -d '\r')
    KERNEL_VERSION=$($ADB -s $SERIAL shell cat /proc/version 2>/dev/null | tr -d '\r')
    MANUFACTURER=$($ADB -s $SERIAL shell getprop ro.product.manufacturer 2>/dev/null | tr -d '\r')
    ARCHITECTURE=$($ADB -s $SERIAL shell getprop ro.product.cpu.abi 2>/dev/null | tr -d '\r')
    DEVICE_INFO="serial=$SERIAL model=$MODEL android_version=$ANDROID_VERSION sdk_version=$SDK_VERSION bootloader_version=$BOOTLOADER_VERSION kernel_version=$KERNEL_VERSION manufacturer=$MANUFACTURER architecture=$ARCHITECTURE state=$STATE"
    echo -e "${GREEN}Device info gathered.${ENDC}"
}

display_device_info() {
    clear_screen
    if [[ -z "$DEVICE_INFO" ]]; then
        echo -e "${RED}No device info available. Connect a device.${ENDC}"
        read -p "Press Enter to return..."
        return
    fi
    echo -e "\n${BOLD}${GREEN}CONNECTED DEVICE INFORMATION${ENDC}"
    echo "=================================================="
    echo -e "${BOLD}Serial:${ENDC}           $(echo $DEVICE_INFO | grep -oP 'serial=\K[^ ]+')"
    echo -e "${BOLD}Manufacturer:${ENDC}     $(echo $DEVICE_INFO | grep -oP 'manufacturer=\K[^ ]+')"
    echo -e "${BOLD}Model:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+')"
    echo -e "${BOLD}Android Version:${ENDC}  $(echo $DEVICE_INFO | grep -oP 'android_version=\K[^ ]+')"
    echo -e "${BOLD}SDK Version:${ENDC}      $(echo $DEVICE_INFO | grep -oP 'sdk_version=\K[^ ]+')"
    echo -e "${BOLD}Architecture:${ENDC}     $(echo $DEVICE_INFO | grep -oP 'architecture=\K[^ ]+')"
    echo -e "${BOLD}Bootloader:${ENDC}       $(echo $DEVICE_INFO | grep -oP 'bootloader_version=\K[^ ]+')"
    echo -e "${BOLD}Kernel:${ENDC}           $(echo $DEVICE_INFO | grep -oP 'kernel_version=\K.+')"
    echo -e "${BOLD}State:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+')"
    echo "=================================================="
    read -p "Press Enter to return..."
}

confirm_action() {
    read -p "${BOLD}${GREEN}CONFIRMATION: $1 (y/N): ${ENDC}" RESPONSE
    RESPONSE=$(echo "$RESPONSE" | tr '[:upper:]' '[:lower:]')
    if [[ "$RESPONSE" == "y" || "$RESPONSE" == "yes" ]]; then
        return 0
    else
        echo -e "${RED}Operation cancelled.${ENDC}"
        return 1
    fi
}

run_command() {
    local cmd="$1"
    local timeout="${2:-$DEFAULT_TIMEOUT}"
    echo -e "${BLUE}Executing: $cmd${ENDC}"
    
    OUTPUT=$(timeout $timeout bash -c "$cmd" 2>&1)
    STATUS=$?
    if [[ $STATUS -eq 124 ]]; then
        echo -e "${RED}Command timed out after $timeout seconds${ENDC}"
        return 124
    elif [[ $STATUS -eq 0 ]]; then
        [[ -n "$OUTPUT" ]] && echo -e "${GREEN}$OUTPUT${ENDC}"
        return 0
    else
        echo -e "${RED}Error: $OUTPUT${ENDC}"
        return $STATUS
    fi
}

# File operations
push_file() {
    read -p "Local file path: " LOCAL_PATH
    if [[ ! -f "$LOCAL_PATH" ]]; then
        echo -e "${RED}File does not exist.${ENDC}"
        return
    fi
    FILE_SIZE=$(stat -c%s "$LOCAL_PATH" 2>/dev/null || stat -f%z "$LOCAL_PATH" 2>/dev/null)
    echo -e "${BLUE}File size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    read -p "Device destination path (e.g., /sdcard/): " REMOTE_PATH
    if ! $ADB -s $SERIAL shell test -d "$(dirname "$REMOTE_PATH")" 2>/dev/null; then
        echo -e "${RED}Destination directory does not exist on device.${ENDC}"
        return
    fi
    run_command "$ADB -s $SERIAL push \"$LOCAL_PATH\" \"$REMOTE_PATH\"" $FILE_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}File pushed successfully.${ENDC}"
}

pull_file() {
    read -p "Device file path: " REMOTE_PATH
    if ! $ADB -s $SERIAL shell test -f "$REMOTE_PATH" 2>/dev/null; then
        echo -e "${RED}File does not exist on device.${ENDC}"
        return
    fi
    FILE_SIZE=$($ADB -s $SERIAL shell stat -c%s "$REMOTE_PATH" 2>/dev/null)
    [[ -n "$FILE_SIZE" ]] && echo -e "${BLUE}File size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    read -p "Local destination path: " LOCAL_PATH
    run_command "$ADB -s $SERIAL pull \"$REMOTE_PATH\" \"$LOCAL_PATH\"" $FILE_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}File pulled successfully.${ENDC}"
}

batch_push() {
    read -p "Local directory path: " LOCAL_DIR
    if [[ ! -d "$LOCAL_DIR" ]]; then
        echo -e "${RED}Directory does not exist.${ENDC}"
        return
    fi
    read -p "Device destination directory (e.g., /sdcard/): " REMOTE_DIR
    if ! $ADB -s $SERIAL shell test -d "$REMOTE_DIR" 2>/dev/null; then
        echo -e "${RED}Destination directory does not exist on device.${ENDC}"
        return
    fi
    FILE_COUNT=$(find "$LOCAL_DIR" -type f | wc -l)
    echo -e "${BLUE}Found $FILE_COUNT files to push${ENDC}"
    confirm_action "Push $FILE_COUNT files?" || return
    CURRENT=0
    for FILE in "$LOCAL_DIR"/*; do
        if [[ -f "$FILE" ]]; then
            CURRENT=$((CURRENT + 1))
            echo -e "${BLUE}[$CURRENT/$FILE_COUNT] Pushing $(basename "$FILE")...${ENDC}"
            run_command "$ADB -s $SERIAL push \"$FILE\" \"$REMOTE_DIR\"" $FILE_TIMEOUT
        fi
    done
    echo -e "${GREEN}Batch push complete: $CURRENT files processed.${ENDC}"
}

batch_pull() {
    read -p "Device directory path (e.g., /sdcard/Download/): " REMOTE_DIR
    if ! $ADB -s $SERIAL shell test -d "$REMOTE_DIR" 2>/dev/null; then
        echo -e "${RED}Directory does not exist on device.${ENDC}"
        return
    fi
    read -p "Local destination directory: " LOCAL_DIR
    mkdir -p "$LOCAL_DIR"
    FILES=$($ADB -s $SERIAL shell find "$REMOTE_DIR" -type f 2>/dev/null | tr -d '\r')
    FILE_COUNT=$(echo "$FILES" | wc -l)
    echo -e "${BLUE}Found $FILE_COUNT files to pull${ENDC}"
    confirm_action "Pull $FILE_COUNT files?" || return
    CURRENT=0
    while IFS= read -r FILE; do
        if [[ -n "$FILE" ]]; then
            CURRENT=$((CURRENT + 1))
            echo -e "${BLUE}[$CURRENT/$FILE_COUNT] Pulling $(basename "$FILE")...${ENDC}"
            run_command "$ADB -s $SERIAL pull \"$FILE\" \"$LOCAL_DIR\"" $FILE_TIMEOUT
        fi
    done <<< "$FILES"
    echo -e "${GREEN}Batch pull complete: $CURRENT files processed.${ENDC}"
}

install_apk() {
    read -p "APK file path: " APK_PATH
    if [[ ! -f "$APK_PATH" || ! "$APK_PATH" =~ \.apk$ ]]; then
        echo -e "${RED}Invalid APK file.${ENDC}"
        return
    fi
    FILE_SIZE=$(stat -c%s "$APK_PATH" 2>/dev/null || stat -f%z "$APK_PATH" 2>/dev/null)
    echo -e "${BLUE}APK: $(basename "$APK_PATH") Size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    if command -v aapt &>/dev/null; then
        PKG=$(aapt dump badging "$APK_PATH" 2>/dev/null | grep "package:" | sed "s/.*name='\([^']*\)'.*/\1/")
        [[ -n "$PKG" ]] && echo -e "${BLUE}Package: $PKG${ENDC}"
    fi
    OUTPUT=$(run_command "$ADB -s $SERIAL install -r \"$APK_PATH\"" $FILE_TIMEOUT)
    [[ $? -eq 0 && "$OUTPUT" =~ Success ]] && echo -e "${GREEN}APK installed: $(basename "$APK_PATH")${ENDC}" || echo -e "${RED}Installation failed.${ENDC}"
}

uninstall_package() {
    read -p "Package name (e.g., com.example.app): " PKG
    if [[ -z "$PKG" ]]; then
        echo -e "${RED}Package name required.${ENDC}"
        return
    fi
    if ! $ADB -s $SERIAL shell pm list packages 2>/dev/null | grep -q "package:$PKG"; then
        echo -e "${RED}Package not found: $PKG${ENDC}"
        return
    fi
    confirm_action "Uninstall $PKG?" || return
    OUTPUT=$(run_command "$ADB -s $SERIAL uninstall $PKG" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 && "$OUTPUT" =~ Success ]] && echo -e "${GREEN}Package uninstalled: $PKG${ENDC}" || echo -e "${RED}Uninstall failed.${ENDC}"
}

list_packages() {
    echo -e "${GREEN}Package List Options${ENDC}"
    echo "1. All packages"
    echo "2. System packages"
    echo "3. User packages"
    echo "4. Enabled packages"
    echo "5. Disabled packages"
    read -p "Select option (1-5): " CHOICE
    case $CHOICE in
        1) FILTER="" ;;
        2) FILTER="-s" ;;
        3) FILTER="-3" ;;
        4) FILTER="-e" ;;
        5) FILTER="-d" ;;
        *) echo -e "${RED}Invalid choice.${ENDC}"; return ;;
    esac
    OUTPUT=$(run_command "$ADB -s $SERIAL shell pm list packages $FILTER" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        PKG_COUNT=$(echo "$OUTPUT" | wc -l)
        echo -e "${GREEN}Found $PKG_COUNT packages:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT" | sed 's/package://' | sort
        echo "------------------------------------------------------------"
    else
        echo -e "${RED}Failed to list packages.${ENDC}"
    fi
}

list_device_directory() {
    read -p "Device directory path (default: /sdcard/): " DIR
    DIR=${DIR:-/sdcard/}
    if ! $ADB -s $SERIAL shell test -d "$DIR" 2>/dev/null; then
        echo -e "${RED}Directory does not exist on device.${ENDC}"
        return
    fi
    OUTPUT=$(run_command "$ADB -s $SERIAL shell ls -la \"$DIR\"" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Contents of $DIR:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT"
        echo "------------------------------------------------------------"
        FILE_COUNT=$(echo "$OUTPUT" | grep -c "^-")
        DIR_COUNT=$(echo "$OUTPUT" | grep -c "^d")
        echo -e "${BLUE}Summary: $DIR_COUNT directories, $FILE_COUNT files${ENDC}"
    else
        echo -e "${RED}Failed to list directory.${ENDC}"
    fi
}

pull_kernel() {
    echo -e "${BLUE}Gathering kernel info...${ENDC}"
    KERNEL_INFO=$(run_command "$ADB -s $SERIAL shell cat /proc/version" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        FILENAME="kernel_info_$TIMESTAMP.txt"
        {
            echo "Kernel Information Report"
            echo "Generated: $(date)"
            echo "Device: $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+')"
            echo "Serial: $(echo $DEVICE_INFO | grep -oP 'serial=\K[^ ]+')"
            echo -e "\nKernel Version"
            echo "$KERNEL_INFO"
            echo -e "\nCPU Information"
            $ADB -s $SERIAL shell cat /proc/cpuinfo 2>/dev/null
            echo -e "\nMemory Information"
            $ADB -s $SERIAL shell cat /proc/meminfo 2>/dev/null
        } > "$FILENAME"
        FILE_SIZE=$(stat -c%s "$FILENAME" 2>/dev/null || stat -f%z "$FILENAME" 2>/dev/null)
        echo -e "${GREEN}Kernel info saved to $FILENAME ($FILE_SIZE bytes)${ENDC}"
    else
        echo -e "${RED}Failed to pull kernel info.${ENDC}"
    fi
}

# Fastboot operations
fastboot_flash() {
    read -p "Partition name (e.g., boot, recovery): " PARTITION
    if [[ -z "$PARTITION" ]]; then return; fi
    read -p "Image file path: " IMAGE_PATH
    if [[ ! -f "$IMAGE_PATH" ]]; then
        echo -e "${RED}Image file does not exist.${ENDC}"
        return
    fi
    echo -e "${RED}${BOLD}‚ö†Ô∏è CRITICAL WARNING: FLASHING $PARTITION ‚ö†Ô∏è${ENDC}"
    if [[ " boot system recovery bootloader radio vendor userdata cache misc persist vbmeta " =~ " $PARTITION " ]]; then
        echo -e "${RED}$PARTITION is critical. Wrong image may brick device.${ENDC}"
    fi
    confirm_action "Flash $PARTITION with $(basename "$IMAGE_PATH")?" || return
    confirm_action "FINAL CONFIRMATION. Proceed?" || return
    OUTPUT=$(run_command "$FASTBOOT flash $PARTITION \"$IMAGE_PATH\"" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Flash successful.${ENDC}" || echo -e "${RED}Flash failed.${ENDC}"
}

fastboot_erase() {
    read -p "Partition name to ERASE (e.g., userdata, cache): " PARTITION
    if [[ -z "$PARTITION" ]]; then return; fi
    echo -e "${RED}${BOLD}‚ö†Ô∏è CRITICAL WARNING: ERASING $PARTITION ‚ö†Ô∏è${ENDC}"
    if [[ " boot system recovery bootloader radio vendor misc persist vbmeta " =~ " $PARTITION " ]]; then
        echo -e "${RED}Erasing $PARTITION may brick device.${ENDC}"
    fi
    confirm_action "Erase $PARTITION?" || return
    OUTPUT=$(run_command "$FASTBOOT erase $PARTITION" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Erase successful.${ENDC}" || echo -e "${RED}Erase failed.${ENDC}"
}

fastboot_format() {
    read -p "Partition to FORMAT (e.g., userdata): " PARTITION
    read -p "Filesystem type (e.g., ext4, f2fs): " FSTYPE
    if [[ -z "$PARTITION" || -z "$FSTYPE" ]]; then return; fi
    echo -e "${RED}${BOLD}‚ö†Ô∏è CRITICAL WARNING: FORMATTING $PARTITION ‚ö†Ô∏è${ENDC}"
    confirm_action "Format $PARTITION as $FSTYPE?" || return
    OUTPUT=$(run_command "$FASTBOOT format:$FSTYPE $PARTITION" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Format successful.${ENDC}" || echo -e "${RED}Format failed.${ENDC}"
}

fastboot_boot() {
    read -p "Image file path to boot: " IMAGE_PATH
    if [[ ! -f "$IMAGE_PATH" ]]; then
        echo -e "${RED}Image file does not exist.${ENDC}"
        return
    fi
    confirm_action "Boot $(basename "$IMAGE_PATH")?" || return
    OUTPUT=$(run_command "$FASTBOOT boot \"$IMAGE_PATH\"" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Boot command sent.${ENDC}" || echo -e "${RED}Boot failed.${ENDC}"
}

fastboot_unlock() {
    echo -e "${RED}${BOLD}Unlocking bootloader WIPES ALL DATA.${ENDC}"
    confirm_action "Proceed with unlocking?" || return
    OUTPUT=$(run_command "$FASTBOOT flashing unlock" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Unlock command sent. Check device screen.${ENDC}" || echo -e "${RED}Unlock failed. Try 'fastboot oem unlock'.${ENDC}"
}

fastboot_lock() {
    echo -e "${RED}${BOLD}Locking bootloader may brick device with custom software.${ENDC}"
    confirm_action "Proceed with locking?" || return
    OUTPUT=$(run_command "$FASTBOOT flashing lock" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Lock command sent. Check device screen.${ENDC}" || echo -e "${RED}Lock command failed.${ENDC}"
}

fastboot_set_active_slot() {
    read -p "Slot to set active ('a' or 'b'): " SLOT
    if [[ "$SLOT" != "a" && "$SLOT" != "b" ]]; then
        echo -e "${RED}Invalid slot. Use 'a' or 'b'.${ENDC}"
        return
    fi
    confirm_action "Set active slot to $SLOT?" || return
    OUTPUT=$(run_command "$FASTBOOT --set-active=$SLOT" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Active slot set to $SLOT.${ENDC}" || echo -e "${RED}Failed to set active slot.${ENDC}"
}

fastboot_getvar_all() {
    echo -e "${BLUE}Fetching bootloader variables...${ENDC}"
    OUTPUT=$(run_command "$FASTBOOT getvar all" $DEFAULT_TIMEOUT 2>&1)
    if [[ $? -eq 0 || -n "$OUTPUT" ]]; then
        echo -e "${GREEN}Device Variables:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT"
        echo "------------------------------------------------------------"
    else
        echo -e "${RED}Failed to get variables.${ENDC}"
    fi
}

fastboot_reboot() {
    clear_screen
    echo -e "${BOLD}${GREEN}Fastboot Reboot Options${ENDC}"
    echo "1. Reboot to System"
    echo "2. Reboot to Bootloader"
    echo "3. Reboot to Recovery"
    echo "4. Continue Boot"
    echo "5. Cancel"
    read -p "Select option: " CHOICE
    case $CHOICE in
        1) run_command "$FASTBOOT reboot" $DEFAULT_TIMEOUT && echo -e "${GREEN}Reboot command sent.${ENDC}";;
        2) run_command "$FASTBOOT reboot-bootloader" $DEFAULT_TIMEOUT && echo -e "${GREEN}Reboot command sent.${ENDC}";;
        3) run_command "$FASTBOOT reboot recovery" $DEFAULT_TIMEOUT && echo -e "${GREEN}Reboot command sent.${ENDC}";;
        4) run_command "$FASTBOOT continue" $DEFAULT_TIMEOUT && echo -e "${GREEN}Continue command sent.${ENDC}";;
        5) ;;
        *) echo -e "${RED}Invalid choice.${ENDC}";;
    esac
}

fastboot_devices() {
    OUTPUT=$(run_command "$FASTBOOT devices" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Fastboot devices:${ENDC}"
        echo "------------------------------"
        [[ -n "$OUTPUT" ]] && echo "$OUTPUT" || echo "No devices found."
        echo "------------------------------"
    fi
}

fastboot_flash_all() {
    read -p "Path to image directory: " IMG_DIR
    if [[ ! -d "$IMG_DIR" ]]; then
        echo -e "${RED}Directory does not exist.${ENDC}"
        return
    fi
    echo -e "${RED}${BOLD}‚ö†Ô∏è CRITICAL WARNING: FLASHING ALL PARTITIONS ‚ö†Ô∏è${ENDC}"
    confirm_action "Flash all partitions in $IMG_DIR?" || return
    confirm_action "FINAL CONFIRMATION. Proceed?" || return
    for IMG in "$IMG_DIR"/*.img; do
        if [[ -f "$IMG" ]]; then
            PARTITION=$(basename "$IMG" .img)
            run_command "$FASTBOOT flash $PARTITION \"$IMG\"" $FASTBOOT_TIMEOUT
        fi
    done
    echo -e "${GREEN}Flash all complete.${ENDC}"
}

fastboot_wipe() {
    echo -e "${RED}${BOLD}‚ö†Ô∏è Wiping device will ERASE ALL DATA ‚ö†Ô∏è${ENDC}"
    confirm_action "Wipe device?" || return
    OUTPUT=$(run_command "$FASTBOOT -w" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Wipe successful.${ENDC}" || echo -e "${RED}Wipe failed.${ENDC}"
}

fastboot_oem_commands() {
    echo -e "${GREEN}OEM Commands${ENDC}"
    echo "1. OEM Unlock"
    echo "2. OEM Lock"
    echo "3. OEM Device Info"
    echo "4. OEM Custom Command"
    echo "5. Cancel"
    read -p "Select option: " CHOICE
    case $CHOICE in
        1) confirm_action "OEM Unlock (wipes data)?" && run_command "$FASTBOOT oem unlock" $DEFAULT_TIMEOUT && echo -e "${GREEN}OEM Unlock sent.${ENDC}";;
        2) confirm_action "OEM Lock?" && run_command "$FASTBOOT oem lock" $DEFAULT_TIMEOUT && echo -e "${GREEN}OEM Lock sent.${ENDC}";;
        3) run_command "$FASTBOOT oem device-info" $DEFAULT_TIMEOUT;;
        4) read -p "Enter OEM command: " CMD && run_command "$FASTBOOT oem $CMD" $DEFAULT_TIMEOUT;;
        5) ;;
        *) echo -e "${RED}Invalid choice.${ENDC}";;
    esac
}

# System operations
reboot_device() {
    read -p "Reboot mode (system/recovery/bootloader/download, default system): " MODE
    MODE=${MODE:-system}
    confirm_action "Reboot to $MODE?" || return
    if [[ "$MODE" == "system" ]]; then
        run_command "$ADB -s $SERIAL reboot" $DEFAULT_TIMEOUT
    else
        run_command "$ADB -s $SERIAL reboot $MODE" $DEFAULT_TIMEOUT
    fi
    [[ $? -eq 0 ]] && echo -e "${GREEN}Reboot command sent.${ENDC}" || echo -e "${RED}Reboot failed.${ENDC}"
}

take_screenshot() {
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    DEVICE_PATH="/sdcard/screenshot_$TIMESTAMP.png"
    LOCAL_DEST="$(pwd)/screenshot_$TIMESTAMP.png"
    run_command "$ADB -s $SERIAL shell screencap $DEVICE_PATH" $DEFAULT_TIMEOUT
    if [[ $? -eq 0 ]]; then
        echo -e "${BLUE}Pulling screenshot...${ENDC}"
        run_command "$ADB -s $SERIAL pull $DEVICE_PATH \"$LOCAL_DEST\"" $FILE_TIMEOUT
        $ADB -s $SERIAL shell rm "$DEVICE_PATH" 2>/dev/null
        if [[ $? -eq 0 ]]; then
            FILE_SIZE=$(stat -c%s "$LOCAL_DEST" 2>/dev/null || stat -f%z "$LOCAL_DEST" 2>/dev/null)
            echo -e "${GREEN}Screenshot saved: $LOCAL_DEST ($FILE_SIZE bytes)${ENDC}"
        else
            echo -e "${RED}Failed to pull screenshot.${ENDC}"
        fi
    else
        echo -e "${RED}Failed to take screenshot.${ENDC}"
    fi
}

screen_recording() {
    read -p "Recording duration (1-180s, default 30): " DURATION
    DURATION=${DURATION:-30}
    if [[ ! $DURATION =~ ^[0-9]+$ || $DURATION -lt 1 || $DURATION -gt 180 ]]; then
        echo -e "${RED}Invalid duration (1-180).${ENDC}"
        return
    fi
    echo "1. Standard quality"
    echo "2. High quality"
    echo "3. Low quality"
    read -p "Select quality (1-3, default 1): " QUALITY
    case $QUALITY in
        2) QUALITY_ARG="--bit-rate 8000000" ;;
        3) QUALITY_ARG="--bit-rate 2000000" ;;
        *) QUALITY_ARG="" ;;
    esac
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    DEVICE_PATH="/sdcard/screenrecord_$TIMESTAMP.mp4"
    LOCAL_DEST="$(pwd)/screenrecord_$TIMESTAMP.mp4"
    echo -e "${GREEN}Starting ${DURATION}s recording... Ctrl+C to stop.${ENDC}"
    run_command "$ADB -s $SERIAL shell screenrecord --time-limit=$DURATION $QUALITY_ARG $DEVICE_PATH" $((DURATION+15)) &
    PID=$!
    trap 'kill $PID; run_command "$ADB -s $SERIAL shell killall screenrecord" 10; echo -e "${GREEN}Recording stopped.${ENDC}"' INT
    wait $PID
    trap - INT
    echo -e "${BLUE}Pulling video...${ENDC}"
    run_command "$ADB -s $SERIAL pull $DEVICE_PATH \"$LOCAL_DEST\"" $FILE_TIMEOUT
    $ADB -s $SERIAL shell rm "$DEVICE_PATH" 2>/dev/null
    if [[ $? -eq 0 ]]; then
        FILE_SIZE=$(stat -c%s "$LOCAL_DEST" 2>/dev/null || stat -f%z "$LOCAL_DEST" 2>/dev/null)
        echo -e "${GREEN}Video saved: $LOCAL_DEST ($FILE_SIZE bytes)${ENDC}"
    else
        echo -e "${RED}Failed to pull video.${ENDC}"
    fi
}

logcat() {
    echo -e "${GREEN}Logcat Options${ENDC}"
    echo "1. All logs"
    echo "2. Filter by tag"
    echo "3. Filter by priority"
    read -p "Select option (1-3): " CHOICE
    case $CHOICE in
        1) FILTER="" ;;
        2) read -p "Enter tag (e.g., ActivityManager): " TAG; FILTER="$TAG:*" ;;
        3) read -p "Enter priority (V/D/I/W/E/F): " PRIORITY; FILTER="*:$PRIORITY" ;;
        *) echo -e "${RED}Invalid choice.${ENDC}"; return ;;
    esac
    echo -e "${GREEN}Starting logcat... Ctrl+C to stop.${ENDC}"
    $ADB -s $SERIAL logcat $FILTER
    echo -e "${GREEN}Logcat stopped.${ENDC}"
}

shell_access() {
    echo -e "${GREEN}Starting shell... Type 'exit' or Ctrl+D to quit.${ENDC}"
    echo "--------------------------------------------------"
    $ADB -s $SERIAL shell
    echo "--------------------------------------------------"
    echo -e "${GREEN}Shell session ended.${ENDC}"
}

get_battery_info() {
    OUTPUT=$(run_command "$ADB -s $SERIAL shell dumpsys battery" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Battery Information:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT"
        echo "------------------------------------------------------------"
    else
        echo -e "${RED}Failed to get battery info.${ENDC}"
    fi
}

get_device_ip() {
    OUTPUT=$(run_command "$ADB -s $SERIAL shell ip addr show wlan0" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 && "$OUTPUT" =~ inet ]]; then
        IP=$(echo "$OUTPUT" | grep -oP 'inet \K[\d.]+' | head -1)
        echo -e "${GREEN}Device Wi-Fi IP: ${BOLD}$IP${ENDC}"
    else
        echo -e "${RED}Could not get IP. Device on Wi-Fi?${ENDC}"
    fi
}

toggle_wifi() {
    echo "1. Enable Wi-Fi"
    echo "2. Disable Wi-Fi"
    read -p "Select option (1/2): " CHOICE
    if [[ "$CHOICE" == "1" ]]; then
        CMD="enable"
        ACTION="Enabling"
        FINAL="enabled"
    elif [[ "$CHOICE" == "2" ]]; then
        CMD="disable"
        ACTION="Disabling"
        FINAL="disabled"
    else
        echo -e "${RED}Invalid choice.${ENDC}"
        return
    fi
    echo -e "${BLUE}$ACTION Wi-Fi...${ENDC}"
    run_command "$ADB -s $SERIAL shell svc wifi $CMD" $DEFAULT_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}Wi-Fi $FINAL.${ENDC}" || echo -e "${RED}Failed to change Wi-Fi state.${ENDC}"
}

adb_advanced() {
    echo -e "${BOLD}${GREEN}ADB Advanced Operations${ENDC}"
    echo "1. Backup Device"
    echo "2. Restore Backup"
    echo "3. Install Multiple APKs"
    echo "4. Clear App Data"
    echo "5. Force Stop App"
    echo "6. Get System Properties"
    echo "7. Start Activity"
    echo "8. Simulate Input"
    echo "9. Generate Bug Report"
    echo "10. Enable Wi-Fi Debugging"
    echo "11. Screen Mirroring (scrcpy)"
    echo "12. Back to System Menu"
    read -p "Select option: " CHOICE
    case $CHOICE in
        1)
            read -p "Backup file path (e.g., backup.ab): " BACKUP_PATH
            run_command "$ADB -s $SERIAL backup -all -f \"$BACKUP_PATH\"" $BACKUP_TIMEOUT
            ;;
        2)
            read -p "Backup file path: " BACKUP_PATH
            if [[ ! -f "$BACKUP_PATH" ]]; then
                echo -e "${RED}Backup file does not exist.${ENDC}"
                return
            fi
            run_command "$ADB -s $SERIAL restore \"$BACKUP_PATH\"" $BACKUP_TIMEOUT
            ;;
        3)
            read -p "Directory with APKs: " APK_DIR
            if [[ ! -d "$APK_DIR" ]]; then
                echo -e "${RED}Directory does not exist.${ENDC}"
                return
            fi
            FILE_COUNT=$(find "$APK_DIR" -type f -name "*.apk" | wc -l)
            echo -e "${BLUE}Found $FILE_COUNT APKs${ENDC}"
            confirm_action "Install $FILE_COUNT APKs?" || return
            CURRENT=0
            for APK in "$APK_DIR"/*.apk; do
                if [[ -f "$APK" ]]; then
                    CURRENT=$((CURRENT + 1))
                    echo -e "${BLUE}[$CURRENT/$FILE_COUNT] Installing $(basename "$APK")...${ENDC}"
                    run_command "$ADB -s $SERIAL install -r \"$APK\"" $FILE_TIMEOUT
                fi
            done
            echo -e "${GREEN}Multiple APK installation complete.${ENDC}"
            ;;
        4)
            read -p "Package name to clear data: " PKG
            run_command "$ADB -s $SERIAL shell pm clear $PKG" $DEFAULT_TIMEOUT
            ;;
        5)
            read -p "Package name to force stop: " PKG
            run_command "$ADB -s $SERIAL shell am force-stop $PKG" $DEFAULT_TIMEOUT
            ;;
        6)
            OUTPUT=$(run_command "$ADB -s $SERIAL shell getprop" $DEFAULT_TIMEOUT)
            if [[ $? -eq 0 ]]; then
                echo -e "${GREEN}System Properties:${ENDC}"
                echo "------------------------------------------------------------"
                echo "$OUTPUT"
                echo "------------------------------------------------------------"
            fi
            ;;
        7)
            read -p "Activity (e.g., com.example/.MainActivity): " ACTIVITY
            run_command "$ADB -s $SERIAL shell am start -n $ACTIVITY" $DEFAULT_TIMEOUT
            ;;
        8)
            read -p "Input command (e.g., 'text hello' or 'keyevent 26'): " INPUT
            run_command "$ADB -s $SERIAL shell input $INPUT" $DEFAULT_TIMEOUT
            ;;
        9)
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            BUGREPORT="bugreport_$TIMESTAMP.zip"
            echo -e "${BLUE}Generating bug report...${ENDC}"
            run_command "$ADB -s $SERIAL bugreport \"$BUGREPORT\"" $BACKUP_TIMEOUT
            [[ $? -eq 0 ]] && echo -e "${GREEN}Bug report saved: $BUGREPORT${ENDC}"
            ;;
        10)
            read -p "Port for Wi-Fi debugging (default 5555): " PORT
            PORT=${PORT:-5555}
            IP=$($ADB -s $SERIAL shell ip addr show wlan0 2>/dev/null | grep -oP 'inet \K[\d.]+' | head -1)
            if [[ -z "$IP" ]]; then
                echo -e "${RED}Could not get IP. Ensure Wi-Fi is enabled.${ENDC}"
                return
            fi
            run_command "$ADB -s $SERIAL tcpip $PORT" $DEFAULT_TIMEOUT
            echo -e "${GREEN}Wi-Fi debugging enabled. Connect with: adb connect $IP:$PORT${ENDC}"
            ;;
        11)
            if command -v scrcpy &>/dev/null; then
                echo -e "${BLUE}Starting screen mirroring with scrcpy...${ENDC}"
                scrcpy -s $SERIAL
            else
                echo -e "${RED}scrcpy not found. Install from https://github.com/Genymobile/scrcpy${ENDC}"
            fi
            ;;
        12) return ;;
        *) echo -e "${RED}Invalid choice.${ENDC}";;
    esac
    read -p "Press Enter to return..."
}

# Samsung operations
samsung_flash_firmware() {
    echo -e "${BOLD}${GREEN}Samsung Firmware Flash${ENDC}"
    echo -e "${RED}${BOLD}WARNING: This will completely replace device firmware${ENDC}"
    
    if [[ $ODIN4_INSTALLED == false && $HEIMDALL_INSTALLED == false ]]; then
        echo -e "${RED}No Samsung tools available. Please install Odin4 or Heimdall.${ENDC}"
        return 1
    fi
    
    detect_samsung_download_mode || return 1
    
    read -p "Path to BL (Bootloader) file: " BL_FILE
    read -p "Path to AP (Android/PDA) file: " AP_FILE
    read -p "Path to CP (Modem) file: " CP_FILE
    read -p "Path to CSC (Country/Region) file: " CSC_FILE
    
    # Validate files exist
    for file in "$BL_FILE" "$AP_FILE" "$CP_FILE" "$CSC_FILE"; do
        if [[ ! -f "$file" ]]; then
            echo -e "${RED}File not found: $file${ENDC}"
            return 1
        fi
        echo -e "${BLUE}$(basename "$file"): $(du -h "$file" 2>/dev/null | cut -f1)${ENDC}"
    done
    
    confirm_action "Flash complete firmware to Samsung device?" || return
    confirm_action "FINAL CONFIRMATION - This may void warranty and trigger Knox!" || return
    
    # Use available tool
    if [[ $ODIN4_INSTALLED == true ]]; then
        echo -e "${BLUE}Using Odin4 for firmware flash...${ENDC}"
        run_command "sudo odin4 --flash --bl \"$BL_FILE\" --ap \"$AP_FILE\" --cp \"$CP_FILE\" --csc \"$CSC_FILE\"" $SAMSUNG_FLASH_TIMEOUT
    elif [[ $HEIMDALL_INSTALLED == true ]]; then
        echo -e "${BLUE}Using Heimdall for firmware flash...${ENDC}"
        run_command "sudo heimdall flash --BOOTLOADER \"$BL_FILE\" --PDA \"$AP_FILE\" --MODEM \"$CP_FILE\" --CSC \"$CSC_FILE\"" $SAMSUNG_FLASH_TIMEOUT
    fi
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Firmware flash completed successfully!${ENDC}"
    else
        echo -e "${RED}Firmware flash failed.${ENDC}"
    fi
}

samsung_flash_recovery() {
    echo -e "${BOLD}${GREEN}Samsung Custom Recovery Flash${ENDC}"
    
    detect_samsung_download_mode || return 1
    
    read -p "Path to recovery image (.img or .tar): " RECOVERY_FILE
    if [[ ! -f "$RECOVERY_FILE" ]]; then
        echo -e "${RED}Recovery file not found: $RECOVERY_FILE${ENDC}"
        return
    fi
    
    confirm_action "Flash custom recovery to Samsung device?" || return
    
    if [[ $ODIN4_INSTALLED == true ]]; then
        echo -e "${BLUE}Using Odin4 for recovery flash...${ENDC}"
        run_command "sudo odin4 --flash-recovery \"$RECOVERY_FILE\"" $SAMSUNG_FLASH_TIMEOUT
    elif [[ $HEIMDALL_INSTALLED == true ]]; then
        echo -e "${BLUE}Using Heimdall for recovery flash...${ENDC}"
        run_command "sudo heimdall flash --RECOVERY \"$RECOVERY_FILE\"" $SAMSUNG_FLASH_TIMEOUT
    fi
    
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Custom recovery flashed successfully!${ENDC}"
    else
        echo -e "${RED}Recovery flash failed.${ENDC}"
    fi
}

# Menu functions
file_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${GREEN}üìÅ FILE OPERATIONS${ENDC}"
        echo "----------------------------------------"
        echo "1. Push File to Device"
        echo "2. Pull File from Device"
        echo "3. Batch Push Directory"
        echo "4. Batch Pull Directory"
        echo "5. Install APK"
        echo "6. Uninstall Package"
        echo "7. List Installed Packages"
        echo "8. List Device Directory"
        echo "9. Pull Kernel Information"
        echo "10. Back to Main Menu"
        echo "----------------------------------------"
        read -p "Select option: " CHOICE
        
        clear_screen
        case $CHOICE in
            1) push_file ;;
            2) pull_file ;;
            3) batch_push ;;
            4) batch_pull ;;
            5) install_apk ;;
            6) uninstall_package ;;
            7) list_packages ;;
            8) list_device_directory ;;
            9) pull_kernel ;;
            10) break ;;
            *) echo -e "${RED}Invalid choice.${ENDC}" ;;
        esac
        read -p "Press Enter to return..."
    done
}

fastboot_menu() {
    clear_screen
    echo -e "${BOLD}${RED}‚ö†Ô∏è FASTBOOT MODE - EXTREME CAUTION ‚ö†Ô∏è${ENDC}"
    echo -e "${RED}Incorrect usage may permanently brick your device.${ENDC}"
    confirm_action "Understand risks and continue to fastboot operations?" || return
    
    while true; do
        clear_screen
        echo -e "${BOLD}${GREEN}üî• FASTBOOT OPERATIONS${ENDC}"
        echo "----------------------------------------"
        echo "1. Flash Partition"
        echo "2. Erase Partition"
        echo "3. Format Partition"
        echo "4. Boot Image (Temporary)"
        echo "5. Unlock Bootloader (Wipes Data)"
        echo "6. Lock Bootloader"
        echo "7. Set Active Slot (A/B Devices)"
        echo "8. Get Device Variables"
        echo "9. Reboot Options"
        echo "10. Check Fastboot Devices"
        echo "11. Flash All Partitions"
        echo "12. Wipe Device"
        echo "13. OEM Commands"
        echo "14. Back to Main Menu"
        echo "----------------------------------------"
        read -p "Select option: " CHOICE
        
        clear_screen
        case $CHOICE in
            1) fastboot_flash ;;
            2) fastboot_erase ;;
            3) fastboot_format ;;
            4) fastboot_boot ;;
            5) fastboot_unlock ;;
            6) fastboot_lock ;;
            7) fastboot_set_active_slot ;;
            8) fastboot_getvar_all ;;
            9) fastboot_reboot ;;
            10) fastboot_devices ;;
            11) fastboot_flash_all ;;
            12) fastboot_wipe ;;
            13) fastboot_oem_commands ;;
            14) break ;;
            *) echo -e "${RED}Invalid choice.${ENDC}" ;;
        esac
        read -p "Press Enter to return..."
    done
}

system_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${GREEN}‚öôÔ∏è SYSTEM OPERATIONS${ENDC}"
        echo "----------------------------------------"
        echo "1. Reboot Device"
        echo "2. Take Screenshot"
        echo "3. Screen Recording"
        echo "4. View Device Logs (Logcat)"
        echo "5. Interactive Shell"
        echo "6. Get Battery Information"
        echo "7. Get Device IP Address"
        echo "8. Toggle Wi-Fi"
        echo "9. Advanced ADB Operations"
        echo "10. Back to Main Menu"
        echo "----------------------------------------"
        read -p "Select option: " CHOICE
        
        clear_screen
        case $CHOICE in
            1) reboot_device ;;
            2) take_screenshot ;;
            3) screen_recording ;;
            4) logcat ;;
            5) shell_access ;;
            6) get_battery_info ;;
            7) get_device_ip ;;
            8) toggle_wifi ;;
            9) adb_advanced ;;
            10) break ;;
            *) echo -e "${RED}Invalid choice.${ENDC}" ;;
        esac
        read -p "Press Enter to return..."
    done
}

samsung_menu() {
    # Ensure Samsung tools are available
    if [[ $ODIN4_INSTALLED == false && $HEIMDALL_INSTALLED == false ]]; then
        echo -e "${RED}No Samsung tools installed. Installing now...${ENDC}"
        install_odin4
        install_heimdall
        
        if [[ $ODIN4_INSTALLED == false && $HEIMDALL_INSTALLED == false ]]; then
            echo -e "${RED}Failed to install Samsung tools. Samsung features unavailable.${ENDC}"
            read -p "Press Enter to return..."
            return
        fi
    fi
    
    while true; do
        clear_screen
        echo -e "${BOLD}${GREEN}üì± SAMSUNG DEVICE OPERATIONS${ENDC}"
        echo -e "${YELLOW}Odin4: $([[ $ODIN4_INSTALLED == true ]] && echo "‚úì Available" || echo "‚úó Not Available")${ENDC}"
        echo -e "${YELLOW}Heimdall: $([[ $HEIMDALL_INSTALLED == true ]] && echo "‚úì Available" || echo "‚úó Not Available")${ENDC}"
        echo "----------------------------------------"
        echo "1. Flash Complete Firmware (BL/AP/CP/CSC)"
        echo "2. Flash Custom Recovery (TWRP/CWM)"
        echo "3. Flash Single Partition"
        echo "4. Detect Samsung Devices"
        echo "5. Samsung Tool Installation"
        echo "6. Back to Main Menu"
        echo "----------------------------------------"
        echo -e "${RED}Ensure device is in DOWNLOAD MODE for Samsung operations${ENDC}"
        echo -e "${YELLOW}Download Mode: Power + Volume Down + Home (then Volume Up)${ENDC}"
        read -p "Select option: " CHOICE
        
        clear_screen
        case $CHOICE in
            1) samsung_flash_firmware ;;
            2) samsung_flash_recovery ;;
            3) echo -e "${YELLOW}Single partition flash - Feature in development${ENDC}"; read -p "Press Enter..." ;;
            4) detect_samsung_download_mode; read -p "Press Enter..." ;;
            5)
                echo -e "${BLUE}Reinstalling Samsung tools...${ENDC}"
                install_odin4
                install_heimdall
                read -p "Press Enter..."
                ;;
            6) break ;;
            *) echo -e "${RED}Invalid choice.${ENDC}"; read -p "Press Enter..." ;;
        esac
    done
}

main_menu() {
    check_requirements
    clear_screen
    display_info
    
    while true; do
        clear_screen
        echo -e "\n${BOLD}${BLUE}PYDROIDB MAIN MENU${ENDC}"
        echo "=================================================="
        
        # Device status display
        if [[ -z "$DEVICE_INFO" ]]; then
            echo -e "${BLUE}Scanning for devices...${ENDC}"
            get_device_info
        fi
        
        if [[ -n "$DEVICE_INFO" ]]; then
            STATE=$(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+')
            MANUFACTURER=$(echo $DEVICE_INFO | grep -oP 'manufacturer=\K[^ ]+')
            COLOR=$([[ "$STATE" == "device" ]] && echo "${GREEN}" || echo "${RED}")
            
            echo -e "Connected Device: ${BOLD}$(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+') ${COLOR}($STATE)${ENDC}"
            
            if [[ "$MANUFACTURER" =~ [Ss]amsung ]]; then
                echo -e "Device Type: ${YELLOW}Samsung (Enhanced features available)${ENDC}"
            fi
        else
            echo -e "${BOLD}${RED}‚ö†Ô∏è No device connected or authorized${ENDC}"
            echo -e "${GREEN}Connect Android device with USB debugging OR Samsung device in download mode${ENDC}"
        fi
        
        echo "=================================================="
        echo "1. Device Information"
        echo "2. File Operations"
        echo "3. System Operations"
        echo "4. Fastboot Operations (DANGEROUS)"
        echo "5. Samsung Operations (Download Mode)"
        echo "6. Refresh Device List"
        echo "7. Tool Information & Setup"
        echo "8. Exit"
        echo "=================================================="
        
        read -p "Select option: " CHOICE
        
        # Check device state for operations requiring active connection
        if [[ -n "$DEVICE_INFO" && $(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+') != "device" && $CHOICE =~ ^[23]$ ]]; then
            echo -e "${RED}Selected operation requires device in 'authorized' state.${ENDC}"
            echo -e "${RED}Current state: $(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+')${ENDC}"
            echo -e "${YELLOW}Please authorize the device and try again.${ENDC}"
            read -p "Press Enter to continue..."
            continue
        fi
        
        case $CHOICE in
            1) [[ -n "$DEVICE_INFO" ]] && display_device_info || (echo -e "${RED}No device detected${ENDC}"; read -p "Press Enter...") ;;
            2) [[ -n "$DEVICE_INFO" ]] && file_operations_menu || (echo -e "${RED}No device detected${ENDC}"; read -p "Press Enter...") ;;
            3) [[ -n "$DEVICE_INFO" ]] && system_operations_menu || (echo -e "${RED}No device detected${ENDC}"; read -p "Press Enter...") ;;
            4) fastboot_menu ;;
            5) samsung_menu ;;
            6) DEVICE_INFO=""; echo -e "${BLUE}Refreshing device list...${ENDC}"; sleep 1 ;;
            7) 
                clear_screen
                echo -e "${BLUE}Tool Information:${ENDC}"
                echo -e "Version: $VERSION"
                echo -e "ADB: $([[ -n "$ADB" ]] && echo "‚úì $(basename $ADB)" || echo "‚úó Not found")"
                echo -e "Fastboot: $([[ -n "$FASTBOOT" ]] && echo "‚úì $(basename $FASTBOOT)" || echo "‚úó Not found")"
                echo -e "Odin4: $([[ $ODIN4_INSTALLED == true ]] && echo "‚úì Installed" || echo "‚úó Not available")"
                echo -e "Heimdall: $([[ $HEIMDALL_INSTALLED == true ]] && echo "‚úì Installed" || echo "‚úó Not available")"
                read -p "Reinstall tools? (y/N): " REINSTALL
                [[ "$REINSTALL" =~ ^[Yy] ]] && check_requirements
                read -p "Press Enter to continue..."
                ;;
            8) 
                echo -e "${BOLD}${BLUE}Thank you for using Pydroidb!${ENDC}"
                echo -e "${GREEN}Stay safe and always backup your devices.${ENDC}"
                exit 0 
                ;;
            *) 
                echo -e "${RED}Invalid choice. Please select 1-8.${ENDC}"
                sleep 1
                ;;
        esac
    done
}

# Error handling and cleanup
cleanup() {
    echo -e "\n${YELLOW}Cleaning up...${ENDC}"
    # Kill any background processes
    jobs -p | xargs -r kill 2>/dev/null
    echo -e "${GREEN}Cleanup complete. Goodbye!${ENDC}"
}

trap cleanup EXIT
trap 'echo -e "\n${YELLOW}Operation interrupted by user${ENDC}"; exit 130' INT

# Start the application
main_menu
