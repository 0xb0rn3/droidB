#!/usr/bin/env bash

VERSION="0.0.1"
BLUE='\033[94m'
GREEN='\033[92m'
RED='\033[91m'
BOLD='\033[1m'
ENDC='\033[0m'

DEFAULT_TIMEOUT=60
FILE_TIMEOUT=300
BACKUP_TIMEOUT=3600
FASTBOOT_TIMEOUT=600

clear_screen() {
    clear
}

display_info() {
    echo -e "${BOLD}${BLUE}Pydroidb: ADB and Fastboot Automation Tool v${VERSION}${ENDC}"
    echo -e "${GREEN}Author: 0xbv1 | 0xb0rn3${ENDC}"
    echo -e "${GREEN}GitHub: https://github.com/0xb0rn3/pydroidb${ENDC}"
    echo -e "${GREEN}Platform: $(uname -s) $(uname -m)${ENDC}"
    echo -e "${RED}${BOLD}============================[ SAFETY WARNING ]============================${ENDC}"
    echo -e "${RED}This tool modifies device firmware and can cause permanent damage if used incorrectly.${ENDC}"
    echo -e "${RED}Always back up data and have official recovery images. USE AT YOUR OWN RISK.${ENDC}"
    echo -e "${RED}${BOLD}=========================================================================${ENDC}"
    read -p "Press Enter to continue..."
}

check_requirements() {
    echo -e "${BLUE}Checking requirements...${ENDC}"
    if ! command -v adb &>/dev/null || ! command -v fastboot &>/dev/null; then
        echo -e "${BLUE}Installing Android SDK Platform-Tools...${ENDC}"
        if [[ -f /etc/debian_version ]]; then
            sudo apt update && sudo apt install -y android-tools-adb android-tools-fastboot
        elif [[ -f /etc/redhat-release ]]; then
            sudo dnf install -y android-tools
        elif [[ -f /etc/arch-release ]]; then
            sudo pacman -S --noconfirm android-tools
        elif [[ -f /etc/SuSE-release ]]; then
            sudo zypper install -y android-tools
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            if command -v brew &>/dev/null; then
                brew install android-platform-tools
            else
                echo -e "${RED}Homebrew not found. Install from https://brew.sh${ENDC}"
                exit 1
            fi
        else
            echo -e "${RED}Unsupported OS. Install ADB/Fastboot from https://developer.android.com/studio/releases/platform-tools${ENDC}"
            exit 1
        fi
    else
        echo -e "${GREEN}Requirements satisfied, skipping installation.${ENDC}"
    fi
    ADB=$(command -v adb)
    FASTBOOT=$(command -v fastboot)
    ADB_VERSION=$($ADB version | head -1)
    FASTBOOT_VERSION=$($FASTBOOT --version | head -1)
    echo -e "${BLUE}ADB: $ADB_VERSION${ENDC}"
    echo -e "${BLUE}Fastboot: $FASTBOOT_VERSION${ENDC}"
    $ADB start-server &>/dev/null && echo -e "${GREEN}ADB server started.${ENDC}"
}

setup_odin() {
    if [[ "$OSTYPE" != "linux-gnu"* ]]; then
        echo -e "${RED}Odin operations are only supported on Linux.${ENDC}"
        return 1
    fi
    echo -e "${BLUE}Checking Odin4...${ENDC}"
    if command -v odin4 &>/dev/null; then
        echo -e "${GREEN}Odin4 is installed.${ENDC}"
        return 0
    fi
    echo -e "${BLUE}Installing Odin4...${ENDC}"
    if ! command -v curl &>/dev/null || ! command -v unzip &>/dev/null; then
        echo -e "${BLUE}Installing curl and unzip...${ENDC}"
        if [[ -f /etc/debian_version ]]; then
            sudo apt update && sudo apt install -y curl unzip
        elif [[ -f /etc/redhat-release ]]; then
            sudo dnf install -y curl unzip
        elif [[ -f /etc/arch-release ]]; then
            sudo pacman -S --noconfirm curl unzip
        elif [[ -f /etc/SuSE-release ]]; then
            sudo zypper install -y curl unzip
        else
            echo -e "${RED}curl and unzip required. Install manually.${ENDC}"
            return 1
        fi
    fi
    TEMP_DIR=$(mktemp -d)
    curl -L https://technastic.com/wp-content/uploads/2023/06/Odin4-Linux.zip -o "$TEMP_DIR/Odin4-Linux.zip"
    unzip "$TEMP_DIR/Odin4-Linux.zip" -d "$TEMP_DIR"
    ODIN_BINARY=$(find "$TEMP_DIR" -name "odin4" -type f)
    if [[ -z "$ODIN_BINARY" ]]; then
        echo -e "${RED}Failed to find odin4 binary in zip.${ENDC}"
        rm -rf "$TEMP_DIR"
        return 1
    fi
    sudo cp "$ODIN_BINARY" /usr/local/bin/odin4
    sudo chmod +x /usr/local/bin/odin4
    echo -e "${GREEN}Odin4 installed successfully.${ENDC}"
    rm -rf "$TEMP_DIR"
    UDEV_FILE="/etc/udev/rules.d/51-android.rules"
    if [[ ! -f "$UDEV_FILE" ]] || ! grep -q 'ATTR{idVendor}=="04e8"' "$UDEV_FILE"; then
        echo -e "${BLUE}Setting up udev rules for Samsung devices...${ENDC}"
        echo 'SUBSYSTEM=="usb", ATTR{idVendor}=="04e8", MODE="0666", GROUP="plugdev"' | sudo tee -a "$UDEV_FILE"
        sudo udevadm control --reload-rules
        sudo udevadm trigger
    fi
    MODPROBE_FILE="/etc/modprobe.d/cdc_acm-blacklist.conf"
    if [[ ! -f "$MODPROBE_FILE" ]] || ! grep -q 'blacklist cdc_acm' "$MODPROBE_FILE"; then
        echo -e "${BLUE}Blacklisting cdc_acm module...${ENDC}"
        echo "blacklist cdc_acm" | sudo tee "$MODPROBE_FILE"
        sudo rmmod cdc_acm 2>/dev/null
    fi
}

get_odin_device() {
    echo -e "${BLUE}Listing devices in download mode...${ENDC}"
    DEVICES=$(sudo odin4 -l 2>/dev/null)
    if [[ -z "$DEVICES" ]]; then
        echo -e "${RED}No devices found. Ensure device is in download mode (Power + Volume Down + Home, then Volume Up).${ENDC}"
        return 1
    fi
    DEVICE_COUNT=$(echo "$DEVICES" | wc -l)
    if [[ $DEVICE_COUNT -gt 1 ]]; then
        echo -e "${GREEN}Multiple devices found:${ENDC}"
        echo "$DEVICES" | nl -w 2 -s '. '
        read -p "Select device (number): " CHOICE
        if [[ $CHOICE =~ ^[0-9]+$ ]] && [[ $CHOICE -ge 1 ]] && [[ $CHOICE -le $DEVICE_COUNT ]]; then
            DEVICE_PATH=$(echo "$DEVICES" | sed -n "${CHOICE}p")
        else
            echo -e "${RED}Invalid selection.${ENDC}"
            return 1
        fi
    else
        DEVICE_PATH=$(echo "$DEVICES" | head -1)
    fi
    echo "$DEVICE_PATH"
}

odin_flash_firmware() {
    echo -e "${BOLD}${GREEN}Flash Samsung Firmware${ENDC}"
    echo -e "${RED}Ensure device is in download mode (Power + Volume Down + Home, then Volume Up).${ENDC}"
    read -p "Path to BL file: " BL
    read -p "Path to AP file: " AP
    read -p "Path to CP file: " CP
    read -p "Path to CSC file: " CSC
    if [[ ! -f "$BL" || ! -f "$AP" || ! -f "$CP" || ! -f "$CSC" ]]; then
        echo -e "${RED}One or more files do not exist.${ENDC}"
        return
    fi
    DEVICE_PATH=$(get_odin_device)
    if [[ -z "$DEVICE_PATH" ]]; then return; fi
    confirm_action "Flash firmware to device $DEVICE_PATH?" || return
    CMD="sudo odin4 -d \"$DEVICE_PATH\" -b \"$BL\" -a \"$AP\" -c \"$CP\" -s \"$CSC\""
    if confirm_action "Enable NAND erase? This will wipe all data."; then
        CMD="$CMD -e"
    fi
    run_command "$CMD" $FASTBOOT_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}Firmware flash completed.${ENDC}" || echo -e "${RED}Firmware flash failed.${ENDC}"
}

odin_flash_twrp() {
    echo -e "${BOLD}${GREEN}Flash TWRP Recovery${ENDC}"
    echo -e "${RED}Ensure device is in download mode (Power + Volume Down + Home, then Volume Up).${ENDC}"
    read -p "Path to TWRP image (e.g., twrp.tar): " TWRP
    if [[ ! -f "$TWRP" ]]; then
        echo -e "${RED}File does not exist.${ENDC}"
        return
    fi
    read -p "Path to vbmeta image (optional, press Enter to skip): " VBMETA
    DEVICE_PATH=$(get_odin_device)
    if [[ -z "$DEVICE_PATH" ]]; then return; fi
    confirm_action "Flash TWRP to device $DEVICE_PATH?" || return
    CMD="sudo odin4 -d \"$DEVICE_PATH\" -a \"$TWRP\""
    if [[ -n "$VBMETA" && -f "$VBMETA" ]]; then
        CMD="$CMD -c \"$VBMETA\""
    fi
    run_command "$CMD" $FASTBOOT_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}TWRP flash completed.${ENDC}" || echo -e "${RED}TWRP flash failed.${ENDC}"
}

odin_reboot() {
    echo -e "${BOLD}${GREEN}Reboot Device${ENDC}"
    echo -e "${RED}Ensure device is in download mode (Power + Volume Down + Home, then Volume Up).${ENDC}"
    echo "1. Reboot to Normal Mode"
    echo "2. Reboot to Download Mode"
    read -p "Select option (1-2): " CHOICE
    DEVICE_PATH=$(get_odin_device)
    if [[ -z "$DEVICE_PATH" ]]; then return; fi
    case $CHOICE in
        1)
            confirm_action "Reboot to normal mode?" || return
            run_command "sudo odin4 -d \"$DEVICE_PATH\" --reboot" $DEFAULT_TIMEOUT
            [[ $? -eq 0 ]] && echo -e "${GREEN}Reboot to normal mode completed.${ENDC}"
            ;;
        2)
            confirm_action "Reboot to download mode?" || return
            run_command "sudo odin4 -d \"$DEVICE_PATH\" --redownload" $DEFAULT_TIMEOUT
            [[ $? -eq 0 ]] && echo -e "${GREEN}Reboot to download mode completed.${ENDC}"
            ;;
        *) echo -e "${RED}Invalid choice.${ENDC}" ;;
    esac
}

odin_menu() {
    setup_odin || return
    while true; do
        clear_screen
        echo -e "${BOLD}${GREEN}üîß SAMSUNG ODIN OPERATIONS${ENDC}"
        echo -e "${RED}Ensure your Samsung device is in download mode (Power + Volume Down + Home, then Volume Up).${ENDC}"
        echo "----------------------------------------"
        echo "1. Flash Firmware"
        echo "2. Flash TWRP Recovery"
        echo "3. Reboot Device"
        echo "4. Check Odin Version"
        echo "5. Back to Main Menu"
        echo "----------------------------------------"
        read -p "Select option: " CHOICE
        clear_screen
        case $CHOICE in
            1) odin_flash_firmware ;;
            2) odin_flash_twrp ;;
            3) odin_reboot ;;
            4) run_command "sudo odin4 -v" $DEFAULT_TIMEOUT ;;
            5) break ;;
            *) echo -e "${RED}Invalid choice.${ENDC}" ;;
        esac
        read -p "Press Enter to return..."
    done
}

get_device_info() {
    echo -e "${BLUE}Scanning devices...${ENDC}"
    DEVICES=$($ADB devices | tail -n +2 | awk '{print $1 "\t" $2}')
    if [[ -z "$DEVICES" ]]; then
        echo -e "${RED}No devices detected. Ensure USB debugging is enabled and device is authorized.${ENDC}"
        DEVICE_INFO=""
        return 1
    fi
    DEVICE_COUNT=$(echo "$DEVICES" | wc -l)
    if [[ $DEVICE_COUNT -gt 1 ]]; then
        echo -e "${GREEN}Multiple devices connected:${ENDC}"
        echo "$DEVICES" | nl -w 2 -s '. '
        while true; do
            read -p "Select device (number): " CHOICE
            if [[ $CHOICE =~ ^[0-9]+$ ]] && [[ $CHOICE -ge 1 ]] && [[ $CHOICE -le $DEVICE_COUNT ]]; then
                SERIAL=$(echo "$DEVICES" | sed -n "${CHOICE}p" | awk '{print $1}')
                STATE=$(echo "$DEVICES" | sed -n "${CHOICE}p" | awk '{print $2}')
                break
            else
                echo -e "${RED}Invalid selection.${ENDC}"
            fi
        done
    else
        SERIAL=$(echo "$DEVICES" | awk '{print $1}')
        STATE=$(echo "$DEVICES" | awk '{print $2}')
    fi
    if [[ "$STATE" == "unauthorized" ]]; then
        echo -e "${RED}${BOLD}Device $SERIAL unauthorized. Authorize on device screen.${ENDC}"
        DEVICE_INFO="serial=$SERIAL model=Unknown android_version=Unknown sdk_version=Unknown bootloader_version=Unknown kernel_version=Unknown manufacturer=Unknown architecture=Unknown state=$STATE"
        return 0
    fi
    MODEL=$($ADB -s $SERIAL shell getprop ro.product.model | tr -d '\r')
    ANDROID_VERSION=$($ADB -s $SERIAL shell getprop ro.build.version.release | tr -d '\r')
    SDK_VERSION=$($ADB -s $SERIAL shell getprop ro.build.version.sdk | tr -d '\r')
    BOOTLOADER_VERSION=$($ADB -s $SERIAL shell getprop ro.bootloader | tr -d '\r')
    KERNEL_VERSION=$($ADB -s $SERIAL shell cat /proc/version | tr -d '\r')
    MANUFACTURER=$($ADB -s $SERIAL shell getprop ro.product.manufacturer | tr -d '\r')
    ARCHITECTURE=$($ADB -s $SERIAL shell getprop ro.product.cpu.abi | tr -d '\r')
    DEVICE_INFO="serial=$SERIAL model=$MODEL android_version=$ANDROID_VERSION sdk_version=$SDK_VERSION bootloader_version=$BOOTLOADER_VERSION kernel_version=$KERNEL_VERSION manufacturer=$MANUFACTURER architecture=$ARCHITECTURE state=$STATE"
    echo -e "${GREEN}Device info gathered.${ENDC}"
}

display_device_info() {
    clear_screen
    if [[ -z "$DEVICE_INFO" ]]; then
        echo -e "${RED}No device info available. Connect a device.${ENDC}"
        read -p "Press Enter to return..."
        return
    fi
    echo -e "\n${BOLD}${GREEN}CONNECTED DEVICE INFORMATION${ENDC}"
    echo "=================================================="
    echo -e "${BOLD}Serial:${ENDC}           $(echo $DEVICE_INFO | grep -oP 'serial=\K[^ ]+')"
    echo -e "${BOLD}Manufacturer:${ENDC}     $(echo $DEVICE_INFO | grep -oP 'manufacturer=\K[^ ]+')"
    echo -e "${BOLD}Model:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+')"
    echo -e "${BOLD}Android Version:${ENDC}  $(echo $DEVICE_INFO | grep -oP 'android_version=\K[^ ]+')"
    echo -e "${BOLD}SDK Version:${ENDC}      $(echo $DEVICE_INFO | grep -oP 'sdk_version=\K[^ ]+')"
    echo -e "${BOLD}Architecture:${ENDC}     $(echo $DEVICE_INFO | grep -oP 'architecture=\K[^ ]+')"
    echo -e "${BOLD}Bootloader:${ENDC}       $(echo $DEVICE_INFO | grep -oP 'bootloader_version=\K[^ ]+')"
    echo -e "${BOLD}Kernel:${ENDC}           $(echo $DEVICE_INFO | grep -oP 'kernel_version=\K.+')"
    echo -e "${BOLD}State:${ENDC}            $(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+')"
    echo "=================================================="
    read -p "Press Enter to return..."
}

confirm_action() {
    read -p "${BOLD}${GREEN}CONFIRMATION: $1 (y/N): ${ENDC}" RESPONSE
    RESPONSE=$(echo "$RESPONSE" | tr '[:upper:]' '[:lower:]')
    if [[ "$RESPONSE" == "y" || "$RESPONSE" == "yes" ]]; then
        return 0
    else
        echo -e "${RED}Operation cancelled.${ENDC}"
        return 1
    fi
}

run_command() {
    echo -e "${BLUE}Executing: $1${ENDC}"
    OUTPUT=$(timeout $2 bash -c "$1" 2>&1)
    STATUS=$?
    if [[ $STATUS -eq 124 ]]; then
        echo -e "${RED}Command timed out after $2 seconds${ENDC}"
        return 124
    elif [[ $STATUS -eq 0 ]]; then
        [[ -n "$OUTPUT" ]] && echo -e "${GREEN}$OUTPUT${ENDC}"
        return 0
    else
        echo -e "${RED}Error: $OUTPUT${ENDC}"
        return $STATUS
    fi
}

push_file() {
    read -p "Local file path: " LOCAL_PATH
    if [[ ! -f "$LOCAL_PATH" ]]; then
        echo -e "${RED}File does not exist.${ENDC}"
        return
    fi
    FILE_SIZE=$(stat -c%s "$LOCAL_PATH" 2>/dev/null || stat -f%z "$LOCAL_PATH" 2>/dev/null)
    echo -e "${BLUE}File size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    read -p "Device destination path (e.g., /sdcard/): " REMOTE_PATH
    if ! $ADB -s $SERIAL shell test -d "$(dirname "$REMOTE_PATH")" 2>/dev/null; then
        echo -e "${RED}Destination directory does not exist on device.${ENDC}"
        return
    fi
    run_command "$ADB -s $SERIAL push \"$LOCAL_PATH\" \"$REMOTE_PATH\"" $FILE_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}File pushed successfully.${ENDC}"
}

pull_file() {
    read -p "Device file path: " REMOTE_PATH
    if ! $ADB -s $SERIAL shell test -f "$REMOTE_PATH" 2>/dev/null; then
        echo -e "${RED}File does not exist on device.${ENDC}"
        return
    fi
    FILE_SIZE=$($ADB -s $SERIAL shell stat -c%s "$REMOTE_PATH" 2>/dev/null)
    [[ -n "$FILE_SIZE" ]] && echo -e "${BLUE}File size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    read -p "Local destination path: " LOCAL_PATH
    run_command "$ADB -s $SERIAL pull \"$REMOTE_PATH\" \"$LOCAL_PATH\"" $FILE_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}File pulled successfully.${ENDC}"
}

batch_push() {
    read -p "Local directory path: " LOCAL_DIR
    if [[ ! -d "$LOCAL_DIR" ]]; then
        echo -e "${RED}Directory does not exist.${ENDC}"
        return
    fi
    read -p "Device destination directory (e.g., /sdcard/): " REMOTE_DIR
    if ! $ADB -s $SERIAL shell test -d "$REMOTE_DIR" 2>/dev/null; then
        echo -e "${RED}Destination directory does not exist on device.${ENDC}"
        return
    fi
    FILE_COUNT=$(find "$LOCAL_DIR" -type f | wc -l)
    echo -e "${BLUE}Found $FILE_COUNT files to push${ENDC}"
    confirm_action "Push $FILE_COUNT files?" || return
    CURRENT=0
    for FILE in "$LOCAL_DIR"/*; do
        if [[ -f "$FILE" ]]; then
            CURRENT=$((CURRENT + 1))
            echo -e "${BLUE}[$CURRENT/$FILE_COUNT] Pushing $(basename "$FILE")...${ENDC}"
            run_command "$ADB -s $SERIAL push \"$FILE\" \"$REMOTE_DIR\"" $FILE_TIMEOUT
        fi
    done
    echo -e "${GREEN}Batch push complete: $CURRENT files processed.${ENDC}"
}

batch_pull() {
    read -p "Device directory path (e.g., /sdcard/Download/): " REMOTE_DIR
    if ! $ADB -s $SERIAL shell test -d "$REMOTE_DIR" 2>/dev/null; then
        echo -e "${RED}Directory does not exist on device.${ENDC}"
        return
    fi
    read -p "Local destination directory: " LOCAL_DIR
    mkdir -p "$LOCAL_DIR"
    FILES=$($ADB -s $SERIAL shell find "$REMOTE_DIR" -type f 2>/dev/null | tr -d '\r')
    FILE_COUNT=$(echo "$FILES" | wc -l)
    echo -e "${BLUE}Found $FILE_COUNT files to pull${ENDC}"
    confirm_action "Pull $FILE_COUNT files?" || return
    CURRENT=0
    while IFS= read -r FILE; do
        if [[ -n "$FILE" ]]; then
            CURRENT=$((CURRENT + 1))
            echo -e "${BLUE}[$CURRENT/$FILE_COUNT] Pulling $(basename "$FILE")...${ENDC}"
            run_command "$ADB -s $SERIAL pull \"$FILE\" \"$LOCAL_DIR\"" $FILE_TIMEOUT
        fi
    done <<< "$FILES"
    echo -e "${GREEN}Batch pull complete: $CURRENT files processed.${ENDC}"
}

install_apk() {
    read -p "APK file path: " APK_PATH
    if [[ ! -f "$APK_PATH" || ! "$APK_PATH" =~ \.apk$ ]]; then
        echo -e "${RED}Invalid APK file.${ENDC}"
        return
    fi
    FILE_SIZE=$(stat -c%s "$APK_PATH" 2>/dev/null || stat -f%z "$APK_PATH" 2>/dev/null)
    echo -e "${BLUE}APK: $(basename "$APK_PATH") Size: $(numfmt --to=iec-i --suffix=B $FILE_SIZE)${ENDC}"
    if command -v aapt &>/dev/null; then
        PKG=$(aapt dump badging "$APK_PATH" 2>/dev/null | grep "package:" | sed "s/.*name='\([^']*\)'.*/\1/")
        [[ -n "$PKG" ]] && echo -e "${BLUE}Package: $PKG${ENDC}"
    fi
    OUTPUT=$(run_command "$ADB -s $SERIAL install -r \"$APK_PATH\"" $FILE_TIMEOUT)
    [[ $? -eq 0 && "$OUTPUT" =~ Success ]] && echo -e "${GREEN}APK installed: $(basename "$APK_PATH")${ENDC}" || echo -e "${RED}Installation failed.${ENDC}"
}

uninstall_package() {
    read -p "Package name (e.g., com.example.app): " PKG
    if [[ -z "$PKG" ]]; then
        echo -e "${RED}Package name required.${ENDC}"
        return
    fi
    if ! $ADB -s $SERIAL shell pm list packages | grep -q "package:$PKG"; then
        echo -e "${RED}Package not found: $PKG${ENDC}"
        return
    fi
    confirm_action "Uninstall $PKG?" || return
    OUTPUT=$(run_command "$ADB -s $SERIAL uninstall $PKG" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 && "$OUTPUT" =~ Success ]] && echo -e "${GREEN}Package uninstalled: $PKG${ENDC}" || echo -e "${RED}Uninstall failed.${ENDC}"
}

list_packages() {
    echo -e "${GREEN}Package List Options${ENDC}"
    echo "1. All packages"
    echo "2. System packages"
    echo "3. User packages"
    echo "4. Enabled packages"
    echo "5. Disabled packages"
    read -p "Select option (1-5): " CHOICE
    case $CHOICE in
        1) FILTER="" ;;
        2) FILTER="-s" ;;
        3) FILTER="-3" ;;
        4) FILTER="-e" ;;
        5) FILTER="-d" ;;
        *) echo -e "${RED}Invalid choice.${ENDC}"; return ;;
    esac
    OUTPUT=$(run_command "$ADB -s $SERIAL shell pm list packages $FILTER" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        PKG_COUNT=$(echo "$OUTPUT" | wc -l)
        echo -e "${GREEN}Found $PKG_COUNT packages:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT" | sed 's/package://' | sort
        echo "------------------------------------------------------------"
    else
        echo -e "${RED}Failed to list packages.${ENDC}"
    fi
}

list_device_directory() {
    read -p "Device directory path (default: /sdcard/): " DIR
    DIR=${DIR:-/sdcard/}
    if ! $ADB -s $SERIAL shell test -d "$DIR" 2>/dev/null; then
        echo -e "${RED}Directory does not exist on device.${ENDC}"
        return
    fi
    OUTPUT=$(run_command "$ADB -s $SERIAL shell ls -la \"$DIR\"" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Contents of $DIR:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT"
        echo "------------------------------------------------------------"
        FILE_COUNT=$(echo "$OUTPUT" | grep -c "^-")
        DIR_COUNT=$(echo "$OUTPUT" | grep -c "^d")
        echo -e "${BLUE}Summary: $DIR_COUNT directories, $FILE_COUNT files${ENDC}"
    else
        echo -e "${RED}Failed to list directory.${ENDC}"
    fi
}

pull_kernel() {
    echo -e "${BLUE}Gathering kernel info...${ENDC}"
    KERNEL_INFO=$(run_command "$ADB -s $SERIAL shell cat /proc/version" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        FILENAME="kernel_info_$TIMESTAMP.txt"
        {
            echo "Kernel Information Report"
            echo "Generated: $(date)"
            echo "Device: $(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+')"
            echo "Serial: $(echo $DEVICE_INFO | grep -oP 'serial=\K[^ ]+')"
            echo -e "\nKernel Version"
            echo "$KERNEL_INFO"
            echo -e "\nCPU Information"
            $ADB -s $SERIAL shell cat /proc/cpuinfo 2>/dev/null
            echo -e "\nMemory Information"
            $ADB -s $SERIAL shell cat /proc/meminfo 2>/dev/null
        } > "$FILENAME"
        FILE_SIZE=$(stat -c%s "$FILENAME" 2>/dev/null || stat -f%z "$FILENAME" 2>/dev/null)
        echo -e "${GREEN}Kernel info saved to $FILENAME ($FILE_SIZE bytes)${ENDC}"
    else
        echo -e "${RED}Failed to pull kernel info.${ENDC}"
    fi
}

fastboot_flash() {
    read -p "Partition name (e.g., boot, recovery): " PARTITION
    if [[ -z "$PARTITION" ]]; then return; fi
    read -p "Image file path: " IMAGE_PATH
    if [[ ! -f "$IMAGE_PATH" ]]; then
        echo -e "${RED}Image file does not exist.${ENDC}"
        return
    fi
    echo -e "${RED}${BOLD}‚ö†Ô∏è CRITICAL WARNING: FLASHING $PARTITION ‚ö†Ô∏è${ENDC}"
    if [[ " boot system recovery bootloader radio vendor userdata cache misc persist vbmeta " =~ " $PARTITION " ]]; then
        echo -e "${RED}$PARTITION is critical. Wrong image may brick device.${ENDC}"
    fi
    confirm_action "Flash $PARTITION with $(basename "$IMAGE_PATH")?" || return
    confirm_action "FINAL CONFIRMATION. Proceed?" || return
    OUTPUT=$(run_command "$FASTBOOT flash $PARTITION \"$IMAGE_PATH\"" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Flash successful.${ENDC}" || echo -e "${RED}Flash failed.${ENDC}"
}

fastboot_erase() {
    read -p "Partition name to ERASE (e.g., userdata, cache): " PARTITION
    if [[ -z "$PARTITION" ]]; then return; fi
    echo -e "${RED}${BOLD}‚ö†Ô∏è CRITICAL WARNING: ERASING $PARTITION ‚ö†Ô∏è${ENDC}"
    if [[ " boot system recovery bootloader radio vendor misc persist vbmeta " =~ " $PARTITION " ]]; then
        echo -e "${RED}Erasing $PARTITION may brick device.${ENDC}"
    fi
    confirm_action "Erase $PARTITION?" || return
    OUTPUT=$(run_command "$FASTBOOT erase $PARTITION" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Erase successful.${ENDC}" || echo -e "${RED}Erase failed.${ENDC}"
}

fastboot_format() {
    read -p "Partition to FORMAT (e.g., userdata): " PARTITION
    read -p "Filesystem type (e.g., ext4, f2fs): " FSTYPE
    if [[ -z "$PARTITION" || -z "$FSTYPE" ]]; then return; fi
    echo -e "${RED}${BOLD}‚ö†Ô∏è CRITICAL WARNING: FORMATTING $PARTITION ‚ö†Ô∏è${ENDC}"
    confirm_action "Format $PARTITION as $FSTYPE?" || return
    OUTPUT=$(run_command "$FASTBOOT format:$FSTYPE $PARTITION" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Format successful.${ENDC}" || echo -e "${RED}Format failed.${ENDC}"
}

fastboot_boot() {
    read -p "Image file path to boot: " IMAGE_PATH
    if [[ ! -f "$IMAGE_PATH" ]]; then
        echo -e "${RED}Image file does not exist.${ENDC}"
        return
    fi
    confirm_action "Boot $(basename "$IMAGE_PATH")?" || return
    OUTPUT=$(run_command "$FASTBOOT boot \"$IMAGE_PATH\"" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Boot command sent.${ENDC}" || echo -e "${RED}Boot failed.${ENDC}"
}

fastboot_unlock() {
    echo -e "${RED}${BOLD}Unlocking bootloader WIPES ALL DATA.${ENDC}"
    confirm_action "Proceed with unlocking?" || return
    OUTPUT=$(run_command "$FASTBOOT flashing unlock" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Unlock command sent. Check device screen.${ENDC}" || echo -e "${RED}Unlock failed. Try 'fastboot oem unlock'.${ENDC}"
}

fastboot_lock() {
    echo -e "${RED}${BOLD}Locking bootloader may brick device with custom software.${ENDC}"
    confirm_action "Proceed with locking?" || return
    OUTPUT=$(run_command "$FASTBOOT flashing lock" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Lock command sent. Check device screen.${ENDC}" || echo -e "${RED}Lock command failed.${ENDC}"
}

fastboot_set_active_slot() {
    read -p "Slot to set active ('a' or 'b'): " SLOT
    if [[ "$SLOT" != "a" && "$SLOT" != "b" ]]; then
        echo -e "${RED}Invalid slot. Use 'a' or 'b'.${ENDC}"
        return
    fi
    confirm_action "Set active slot to $SLOT?" || return
    OUTPUT=$(run_command "$FASTBOOT --set-active=$SLOT" $DEFAULT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Active slot set to $SLOT.${ENDC}" || echo -e "${RED}Failed to set active slot.${ENDC}"
}

fastboot_getvar_all() {
    echo -e "${BLUE}Fetching bootloader variables...${ENDC}"
    OUTPUT=$(run_command "$FASTBOOT getvar all" $DEFAULT_TIMEOUT 2>&1)
    if [[ $? -eq 0 || -n "$OUTPUT" ]]; then
        echo -e "${GREEN}Device Variables:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT"
        echo "------------------------------------------------------------"
    else
        echo -e "${RED}Failed to get variables.${ENDC}"
    fi
}

fastboot_reboot() {
    clear_screen
    echo -e "${BOLD}${GREEN}Fastboot Reboot Options${ENDC}"
    echo "1. Reboot to System"
    echo "2. Reboot to Bootloader"
    echo "3. Reboot to Recovery"
    echo "4. Continue Boot"
    echo "5. Cancel"
    read -p "Select option: " CHOICE
    case $CHOICE in
        1) run_command "$FASTBOOT reboot" $DEFAULT_TIMEOUT && echo -e "${GREEN}Reboot command sent.${ENDC}";;
        2) run_command "$FASTBOOT reboot-bootloader" $DEFAULT_TIMEOUT && echo -e "${GREEN}Reboot command sent.${ENDC}";;
        3) run_command "$FASTBOOT reboot recovery" $DEFAULT_TIMEOUT && echo -e "${GREEN}Reboot command sent.${ENDC}";;
        4) run_command "$FASTBOOT continue" $DEFAULT_TIMEOUT && echo -e "${GREEN}Continue command sent.${ENDC}";;
        5) ;;
        *) echo -e "${RED}Invalid choice.${ENDC}";;
    esac
}

fastboot_devices() {
    OUTPUT=$(run_command "$FASTBOOT devices" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Fastboot devices:${ENDC}"
        echo "------------------------------"
        [[ -n "$OUTPUT" ]] && echo "$OUTPUT" || echo "No devices found."
        echo "------------------------------"
    fi
}

fastboot_flash_all() {
    read -p "Path to image directory: " IMG_DIR
    if [[ ! -d "$IMG_DIR" ]]; then
        echo -e "${RED}Directory does not exist.${ENDC}"
        return
    fi
    echo -e "${RED}${BOLD}‚ö†Ô∏è CRITICAL WARNING: FLASHING ALL PARTITIONS ‚ö†Ô∏è${ENDC}"
    confirm_action "Flash all partitions in $IMG_DIR?" || return
    confirm_action "FINAL CONFIRMATION. Proceed?" || return
    for IMG in "$IMG_DIR"/*.img; do
        if [[ -f "$IMG" ]]; then
            PARTITION=$(basename "$IMG" .img)
            run_command "$FASTBOOT flash $PARTITION \"$IMG\"" $FASTBOOT_TIMEOUT
        fi
    done
    echo -e "${GREEN}Flash all complete.${ENDC}"
}

fastboot_wipe() {
    echo -e "${RED}${BOLD}‚ö†Ô∏è Wiping device will ERASE ALL DATA ‚ö†Ô∏è${ENDC}"
    confirm_action "Wipe device?" || return
    OUTPUT=$(run_command "$FASTBOOT -w" $FASTBOOT_TIMEOUT)
    [[ $? -eq 0 ]] && echo -e "${GREEN}Wipe successful.${ENDC}" || echo -e "${RED}Wipe failed.${ENDC}"
}

fastboot_oem_commands() {
    echo -e "${GREEN}OEM Commands${ENDC}"
    echo "1. OEM Unlock"
    echo "2. OEM Lock"
    echo "3. OEM Device Info"
    echo "4. OEM Custom Command"
    echo "5. Cancel"
    read -p "Select option: " CHOICE
    case $CHOICE in
        1) confirm_action "OEM Unlock (wipes data)?" && run_command "$FASTBOOT oem unlock" $DEFAULT_TIMEOUT && echo -e "${GREEN}OEM Unlock sent.${ENDC}";;
        2) confirm_action "OEM Lock?" && run_command "$FASTBOOT oem lock" $DEFAULT_TIMEOUT && echo -e "${GREEN}OEM Lock sent.${ENDC}";;
        3) run_command "$FASTBOOT oem device-info" $DEFAULT_TIMEOUT;;
        4) read -p "Enter OEM command: " CMD && run_command "$FASTBOOT oem $CMD" $DEFAULT_TIMEOUT;;
        5) ;;
        *) echo -e "${RED}Invalid choice.${ENDC}";;
    esac
}

reboot_device() {
    read -p "Reboot mode (system/recovery/bootloader, default system): " MODE
    MODE=${MODE:-system}
    confirm_action "Reboot to $MODE?" || return
    run_command "$ADB -s $SERIAL reboot $MODE" $DEFAULT_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}Reboot command sent.${ENDC}" || echo -e "${RED}Reboot failed.${ENDC}"
}

take_screenshot() {
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    DEVICE_PATH="/sdcard/screenshot_$TIMESTAMP.png"
    LOCAL_DEST="$(pwd)/screenshot_$TIMESTAMP.png"
    run_command "$ADB -s $SERIAL shell screencap $DEVICE_PATH" $DEFAULT_TIMEOUT
    if [[ $? -eq 0 ]]; then
        echo -e "${BLUE}Pulling screenshot...${ENDC}"
        run_command "$ADB -s $SERIAL pull $DEVICE_PATH \"$LOCAL_DEST\"" $FILE_TIMEOUT
        $ADB -s $SERIAL shell rm "$DEVICE_PATH" 2>/dev/null
        if [[ $? -eq 0 ]]; then
            FILE_SIZE=$(stat -c%s "$LOCAL_DEST" 2>/dev/null || stat -f%z "$LOCAL_DEST" 2>/dev/null)
            echo -e "${GREEN}Screenshot saved: $LOCAL_DEST ($FILE_SIZE bytes)${ENDC}"
        else
            echo -e "${RED}Failed to pull screenshot.${ENDC}"
        fi
    else
        echo -e "${RED}Failed to take screenshot.${ENDC}"
    fi
}

screen_recording() {
    read -p "Recording duration (1-180s, default 30): " DURATION
    DURATION=${DURATION:-30}
    if [[ ! $DURATION =~ ^[0-9]+$ || $DURATION -lt 1 || $DURATION -gt 180 ]]; then
        echo -e "${RED}Invalid duration (1-180).${ENDC}"
        return
    fi
    echo "1. Standard quality"
    echo "2. High quality"
    echo "3. Low quality"
    read -p "Select quality (1-3, default 1): " QUALITY
    case $QUALITY in
        2) QUALITY_ARG="--bit-rate 8000000" ;;
        3) QUALITY_ARG="--bit-rate 2000000" ;;
        *) QUALITY_ARG="" ;;
    esac
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    DEVICE_PATH="/sdcard/screenrecord_$TIMESTAMP.mp4"
    LOCAL_DEST="$(pwd)/screenrecord_$TIMESTAMP.mp4"
    echo -e "${GREEN}Starting ${DURATION}s recording... Ctrl+C to stop.${ENDC}"
    run_command "$ADB -s $SERIAL shell screenrecord --time-limit=$DURATION $QUALITY_ARG $DEVICE_PATH" $((DURATION+15)) &
    PID=$!
    trap 'kill $PID; run_command "$ADB -s $SERIAL shell killall screenrecord" 10; echo -e "${GREEN}Recording stopped.${ENDC}"' INT
    wait $PID
    trap - INT
    echo -e "${BLUE}Pulling video...${ENDC}"
    run_command "$ADB -s $SERIAL pull $DEVICE_PATH \"$LOCAL_DEST\"" $FILE_TIMEOUT
    $ADB -s $SERIAL shell rm "$DEVICE_PATH" 2>/dev/null
    if [[ $? -eq 0 ]]; then
        FILE_SIZE=$(stat -c%s "$LOCAL_DEST" 2>/dev/null || stat -f%z "$LOCAL_DEST" 2>/dev/null)
        echo -e "${GREEN}Video saved: $LOCAL_DEST ($FILE_SIZE bytes)${ENDC}"
    else
        echo -e "${RED}Failed to pull video.${ENDC}"
    fi
}

logcat() {
    echo -e "${GREEN}Logcat Options${ENDC}"
    echo "1. All logs"
    echo "2. Filter by tag"
    echo "3. Filter by priority"
    read -p "Select option (1-3): " CHOICE
    case $CHOICE in
        1) FILTER="" ;;
        2) read -p "Enter tag (e.g., ActivityManager): " TAG; FILTER="$TAG:*" ;;
        3) read -p "Enter priority (V/D/I/W/E/F): " PRIORITY; FILTER="*:$PRIORITY" ;;
        *) echo -e "${RED}Invalid choice.${ENDC}"; return ;;
    esac
    echo -e "${GREEN}Starting logcat... Ctrl+C to stop.${ENDC}"
    $ADB -s $SERIAL logcat $FILTER
    echo -e "${GREEN}Logcat stopped.${ENDC}"
}

shell_access() {
    echo -e "${GREEN}Starting shell... Type 'exit' or Ctrl+D to quit.${ENDC}"
    echo "--------------------------------------------------"
    $ADB -s $SERIAL shell
    echo "--------------------------------------------------"
    echo -e "${GREEN}Shell session ended.${ENDC}"
}

get_battery_info() {
    OUTPUT=$(run_command "$ADB -s $SERIAL shell dumpsys battery" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 ]]; then
        echo -e "${GREEN}Battery Information:${ENDC}"
        echo "------------------------------------------------------------"
        echo "$OUTPUT"
        echo "------------------------------------------------------------"
    else
        echo -e "${RED}Failed to get battery info.${ENDC}"
    fi
}

get_device_ip() {
    OUTPUT=$(run_command "$ADB -s $SERIAL shell ip addr show wlan0" $DEFAULT_TIMEOUT)
    if [[ $? -eq 0 && "$OUTPUT" =~ inet ]]; then
        IP=$(echo "$OUTPUT" | grep -oP 'inet \K[\d.]+' | head -1)
        echo -e "${GREEN}Device Wi-Fi IP: ${BOLD}$IP${ENDC}"
    else
        echo -e "${RED}Could not get IP. Device on Wi-Fi?${ENDC}"
    fi
}

toggle_wifi() {
    echo "1. Enable Wi-Fi"
    echo "2. Disable Wi-Fi"
    read -p "Select option (1/2): " CHOICE
    if [[ "$CHOICE" == "1" ]]; then
        CMD="enable"
        ACTION="Enabling"
        FINAL="enabled"
    elif [[ "$CHOICE" == "2" ]]; then
        CMD="disable"
        ACTION="Disabling"
        FINAL="disabled"
    else
        echo -e "${RED}Invalid choice.${ENDC}"
        return
    fi
    echo -e "${BLUE}$ACTION Wi-Fi...${ENDC}"
    run_command "$ADB -s $SERIAL shell svc wifi $CMD" $DEFAULT_TIMEOUT
    [[ $? -eq 0 ]] && echo -e "${GREEN}Wi-Fi $FINAL.${ENDC}" || echo -e "${RED}Failed to change Wi-Fi state.${ENDC}"
}

adb_advanced() {
    echo -e "${BOLD}${GREEN}ADB Advanced Operations${ENDC}"
    echo "1. Backup Device"
    echo "2. Restore Backup"
    echo "3. Install Multiple APKs"
    echo "4. Clear App Data"
    echo "5. Force Stop App"
    echo "6. Get System Properties"
    echo "7. Start Activity"
    echo "8. Simulate Input"
    echo "9. Generate Bug Report"
    echo "10. Enable Wi-Fi Debugging"
    echo "11. Screen Mirroring (scrcpy)"
    echo "12. Back to System Menu"
    read -p "Select option: " CHOICE
    case $CHOICE in
        1)
            read -p "Backup file path (e.g., backup.ab): " BACKUP_PATH
            run_command "$ADB -s $SERIAL backup -all -f \"$BACKUP_PATH\"" $BACKUP_TIMEOUT
            ;;
        2)
            read -p "Backup file path: " BACKUP_PATH
            if [[ ! -f "$BACKUP_PATH" ]]; then
                echo -e "${RED}Backup file does not exist.${ENDC}"
                return
            fi
            run_command "$ADB -s $SERIAL restore \"$BACKUP_PATH\"" $BACKUP_TIMEOUT
            ;;
        3)
            read -p "Directory with APKs: " APK_DIR
            if [[ ! -d "$APK_DIR" ]]; then
                echo -e "${RED}Directory does not exist.${ENDC}"
                return
            fi
            FILE_COUNT=$(find "$APK_DIR" -type f -name "*.apk" | wc -l)
            echo -e "${BLUE}Found $FILE_COUNT APKs${ENDC}"
            confirm_action "Install $FILE_COUNT APKs?" || return
            CURRENT=0
            for APK in "$APK_DIR"/*.apk; do
                if [[ -f "$APK" ]]; then
                    CURRENT=$((CURRENT + 1))
                    echo -e "${BLUE}[$CURRENT/$FILE_COUNT] Installing $(basename "$APK")...${ENDC}"
                    run_command "$ADB -s $SERIAL install -r \"$APK\"" $FILE_TIMEOUT
                fi
            done
            echo -e "${GREEN}Multiple APK installation complete.${ENDC}"
            ;;
        4)
            read -p "Package name to clear data: " PKG
            run_command "$ADB -s $SERIAL shell pm clear $PKG" $DEFAULT_TIMEOUT
            ;;
        5)
            read -p "Package name to force stop: " PKG
            run_command "$ADB -s $SERIAL shell am force-stop $PKG" $DEFAULT_TIMEOUT
            ;;
        6)
            OUTPUT=$(run_command "$ADB -s $SERIAL shell getprop" $DEFAULT_TIMEOUT)
            if [[ $? -eq 0 ]]; then
                echo -e "${GREEN}System Properties:${ENDC}"
                echo "------------------------------------------------------------"
                echo "$OUTPUT"
                echo "------------------------------------------------------------"
            fi
            ;;
        7)
            read -p "Activity (e.g., com.example/.MainActivity): " ACTIVITY
            run_command "$ADB -s $SERIAL shell am start -n $ACTIVITY" $DEFAULT_TIMEOUT
            ;;
        8)
            read -p "Input command (e.g., 'text hello' or 'keyevent 26'): " INPUT
            run_command "$ADB -s $SERIAL shell input $INPUT" $DEFAULT_TIMEOUT
            ;;
        9)
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            BUGREPORT="bugreport_$TIMESTAMP.zip"
            echo -e "${BLUE}Generating bug report...${ENDC}"
            run_command "$ADB -s $SERIAL bugreport \"$BUGREPORT\"" $BACKUP_TIMEOUT
            [[ $? -eq 0 ]] && echo -e "${GREEN}Bug report saved: $BUGREPORT${ENDC}"
            ;;
        10)
            read -p "Port for Wi-Fi debugging (default 5555): " PORT
            PORT=${PORT:-5555}
            IP=$($ADB -s $SERIAL shell ip addr show wlan0 | grep -oP 'inet \K[\d.]+' | head -1)
            if [[ -z "$IP" ]]; then
                echo -e "${RED}Could not get IP. Ensure Wi-Fi is enabled.${ENDC}"
                return
            fi
            run_command "$ADB -s $SERIAL tcpip $PORT" $DEFAULT_TIMEOUT
            echo -e "${GREEN}Wi-Fi debugging enabled. Connect with: adb connect $IP:$PORT${ENDC}"
            ;;
        11)
            if command -v scrcpy &>/dev/null; then
                echo -e "${BLUE}Starting screen mirroring with scrcpy...${ENDC}"
                scrcpy -s $SERIAL
            else
                echo -e "${RED}scrcpy not found. Install from https://github.com/Genymobile/scrcpy${ENDC}"
            fi
            ;;
        12) return ;;
        *) echo -e "${RED}Invalid choice.${ENDC}";;
    esac
    read -p "Press Enter to return..."
}

file_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${GREEN}üìÅ FILE OPERATIONS${ENDC}"
        echo "----------------------------------------"
        echo "1. Push File to Device"
        echo "2. Pull File from Device"
        echo "3. Batch Push Directory"
        echo "4. Batch Pull Directory"
        echo "5. Install APK"
        echo "6. Uninstall Package"
        echo "7. List Installed Packages"
        echo "8. List Device Directory"
        echo "9. Pull Kernel Info"
        echo "10. Back to Main Menu"
        echo "----------------------------------------"
        read -p "Select option: " CHOICE
        clear_screen
        case $CHOICE in
            1) push_file ;;
            2) pull_file ;;
            3) batch_push ;;
            4) batch_pull ;;
            5) install_apk ;;
            6) uninstall_package ;;
            7) list_packages ;;
            8) list_device_directory ;;
            9) pull_kernel ;;
            10) break ;;
            *) echo -e "${RED}Invalid choice.${ENDC}" ;;
        esac
        read -p "Press Enter to return..."
    done
}

fastboot_menu() {
    clear_screen
    echo -e "${BOLD}${RED}‚ö†Ô∏è FASTBOOT MODE - EXTREME CAUTION ‚ö†Ô∏è${ENDC}"
    echo -e "${RED}Incorrect usage may brick device. Ensure correct files for your device model.${ENDC}"
    confirm_action "Understand risks and continue?" || return
    while true; do
        clear_screen
        echo -e "${BOLD}${GREEN}üî• FASTBOOT OPERATIONS${ENDC}"
        echo "----------------------------------------"
        echo "1. Flash Partition"
        echo "2. Erase Partition"
        echo "3. Format Partition"
        echo "4. Boot Image"
        echo "5. Unlock Bootloader (Erases Data)"
        echo "6. Lock Bootloader"
        echo "7. Set Active Slot (A/B Devices)"
        echo "8. Get All Device Variables"
        echo "9. Reboot from Fastboot"
        echo "10. Check Fastboot Devices"
        echo "11. Flash All Partitions"
        echo "12. Wipe Device"
        echo "13. OEM Commands"
        echo "14. Back to Main Menu"
        echo "----------------------------------------"
        read -p "Select option: " CHOICE
        clear_screen
        case $CHOICE in
            1) fastboot_flash ;;
            2) fastboot_erase ;;
            3) fastboot_format ;;
            4) fastboot_boot ;;
            5) fastboot_unlock ;;
            6) fastboot_lock ;;
            7) fastboot_set_active_slot ;;
            8) fastboot_getvar_all ;;
            9) fastboot_reboot ;;
            10) fastboot_devices ;;
            11) fastboot_flash_all ;;
            12) fastboot_wipe ;;
            13) fastboot_oem_commands ;;
            14) break ;;
            *) echo -e "${RED}Invalid choice.${ENDC}" ;;
        esac
        read -p "Press Enter to return..."
    done
}

system_operations_menu() {
    while true; do
        clear_screen
        echo -e "${BOLD}${GREEN}‚öôÔ∏è SYSTEM OPERATIONS${ENDC}"
        echo "----------------------------------------"
        echo "1. Reboot Device"
        echo "2. Take Screenshot"
        echo "3. Screen Recording"
        echo "4. View Device Logs (Logcat)"
        echo "5. Interactive Shell"
        echo "6. Get Battery Info"
        echo "7. Get Device IP Address"
        echo "8. Toggle Wi-Fi"
        echo "9. Advanced ADB Operations"
        echo "10. Back to Main Menu"
        echo "----------------------------------------"
        read -p "Select option: " CHOICE
        clear_screen
        case $CHOICE in
            1) reboot_device ;;
            2) take_screenshot ;;
            3) screen_recording ;;
            4) logcat ;;
            5) shell_access ;;
            6) get_battery_info ;;
            7) get_device_ip ;;
            8) toggle_wifi ;;
            9) adb_advanced ;;
            10) break ;;
            *) echo -e "${RED}Invalid choice.${ENDC}" ;;
        esac
        read -p "Press Enter to return..."
    done
}

main_menu() {
    check_requirements
    clear_screen
    display_info
    while true; do
        clear_screen
        echo -e "\n${BOLD}${BLUE}PYDROIDB MAIN MENU${ENDC}"
        echo "=================================================="
        if [[ -z "$DEVICE_INFO" ]]; then
            echo -e "${GREEN}Searching for devices...${ENDC}"
            get_device_info
        fi
        if [[ -n "$DEVICE_INFO" ]]; then
            STATE=$(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+')
            COLOR=$([[ "$STATE" == "device" ]] && echo "${GREEN}" || echo "${RED}")
            echo -e "Connected Device: ${BOLD}$(echo $DEVICE_INFO | grep -oP 'model=\K[^ ]+') ${COLOR}($STATE)${ENDC}"
        else
            echo -e "${BOLD}${RED}‚ö†Ô∏è No device connected or authorized.${ENDC}"
            echo -e "${GREEN}Connect an Android device with USB debugging enabled.${ENDC}"
        fi
        echo "=================================================="
        echo "1. Device Information"
        echo "2. File Operations"
        echo "3. System Operations"
        echo "4. Fastboot Operations (DANGEROUS)"
        echo "5. Samsung Odin Operations (Linux only)"
        echo "6. Refresh Device List"
        echo "7. Exit"
        read -p "Select option: " CHOICE
        if [[ -n "$DEVICE_INFO" && $(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+') != "device" && $CHOICE =~ [23] ]]; then
            echo -e "${RED}Action requires device in 'device' mode. Current state: $(echo $DEVICE_INFO | grep -oP 'state=\K[^ ]+').${ENDC}"
            read -p "Press Enter to continue..."
            continue
        fi
        case $CHOICE in
            1) [[ -n "$DEVICE_INFO" ]] && display_device_info ;;
            2) [[ -n "$DEVICE_INFO" ]] && file_operations_menu ;;
            3) [[ -n "$DEVICE_INFO" ]] && system_operations_menu ;;
            4) fastboot_menu ;;
            5) odin_menu ;;
            6) DEVICE_INFO="" ;;
            7) echo -e "${BOLD}${BLUE}Goodbye!${ENDC}"; exit 0 ;;
            *) echo -e "${RED}Invalid choice.${ENDC}"; sleep 1 ;;
        esac
    done
}

trap 'echo -e "\n${GREEN}Interrupted. Goodbye!${ENDC}"; exit 0' INT
main_menu
