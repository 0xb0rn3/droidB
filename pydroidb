#!/usr/bin/env python3
"""
Pydroidb: A comprehensive ADB and Fastboot automation tool.

This script provides a safe and user-friendly command-line interface
for a wide range of Android device management tasks.

Author: 0xbv1 | 0xb0rn3
GitHub: https://github.com/0xb0rn3/pydroidb
"""

import subprocess
import os
import sys
import time
import platform
from pathlib import Path
from typing import List, Optional, Tuple, Dict
from dataclasses import dataclass

# --- UI and Color Definitions ---

def clear_screen():
    """Clears the console screen."""
    os.system('cls' if os.name == 'nt' else 'clear')

class Colors:
    """ANSI color codes for console output."""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def display_banner():
    """Displays the tool's startup banner and information."""
    pydroid_ascii = [
        "██████╗ ██╗   ██╗██████╗  ██████╗ ██╗ ██████╗ ██████╗         ",
        "██╔══██╗╚██╗ ██╔╝██╔══██╗██╔═══██╗██║██╔═══██╗██╔══██╗             ",
        "██████╔╝ ╚████╔╝ ██████╔╝██║   ██║██║██║   ██║██████╔╝",
        "██╔═══╝   ╚██╔╝  ██╔══██╗██║   ██║██║██║   ██║██╔══██╗   ",
        "██║        ██║   ██████╔╝╚██████╔╝██║╚██████╔╝██████╔╝",
        "╚═╝        ╚═╝   ╚═════╝  ╚═════╝ ╚═╝ ╚═════╝ ╚═════╝"
    ]

    android_ascii = [
        "⠀⠀⠀⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠙⢷⣤⣤⣴⣶⣶⣦⣤⣤⡾⠋⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⣼⣿⣿⣉⣹⣿⣿⣿⣿⣏⣉⣿⣿⣧⠀⠀⠀⠀",
        "⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀",
        "⣠⣄⠀⢠⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⡄⠀⣠⣄",
        "⣿⣿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢸⣿⣿",
        "⣿⣿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢸⣿⣿",
        "⣿⣿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢸⣿⣿",
        "⣿⣿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢸⣿⣿",
        "⠻⠟⠁⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠈⠻⠟",
        "⠀⠀⠀⠀⠉⠉⣿⣿⣿⡏⠉⠉⢹⣿⣿⣿⠉⠉⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⣿⣿⣿⡇⠀⠀⢸⣿⣿⣿⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⣿⣿⣿⡇⠀⠀⢸⣿⣿⣿⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠈⠉⠉⠀⠀⠀⠀⠉⠉⠁⠀⠀⠀⠀⠀⠀"
    ]

    # Combine the ASCII arts side by side
    max_len = max(len(pydroid_ascii), len(android_ascii))
    pydroid_ascii += [' ' * len(pydroid_ascii[0])] * (max_len - len(pydroid_ascii))
    android_ascii += [' ' * len(android_ascii[0])] * (max_len - len(android_ascii))

    combined_banner = "\n".join([f"{Colors.BOLD}{Colors.BLUE}{p_line}  {a_line}{Colors.ENDC}" for p_line, a_line in zip(pydroid_ascii, android_ascii)])
    
    banner = f"""
{combined_banner}

{Colors.BOLD}A comprehensive ADB automation tool for Android device management{Colors.ENDC}
{Colors.YELLOW}Made with ❤️ by 0xbv1 | 0xb0rn3 IG: theehiv3 Contact: 0xb0rn3@proton.me {Colors.ENDC}
    """
    warning = f"""
{Colors.BOLD}{Colors.RED}============================[ IMPORTANT SAFETY WARNING ]============================{Colors.ENDC}
{Colors.YELLOW}
- This tool deals with device firmware and can cause permanent damage if used incorrectly.
- Always back up your data and have official recovery images for your device model.
- The author is not responsible for any damage to your device. {Colors.BOLD}USE AT YOUR OWN RISK.{Colors.ENDC}
{Colors.BOLD}{Colors.RED}=================================================================================={Colors.ENDC}
    """
    print(banner)
    print(warning)
    input(f"{Colors.YELLOW}Press Enter to continue...{Colors.ENDC}")


@dataclass
class DeviceInfo:
    """Stores comprehensive device information for safety checks."""
    serial: str
    model: str
    android_version: str
    sdk_version: str
    bootloader_version: str
    state: str  # device, recovery, fastboot, unauthorized, etc.

class ADBAutomationTool:
    """
    Comprehensive ADB automation tool with enhanced safety features.
    
    This class provides a safe, user-friendly interface to ADB and Fastboot
    commands with built-in safety checks and error handling.
    """
    
    def __init__(self):
        self.device_info: Optional[DeviceInfo] = None
        self.adb_path = self._find_executable('adb')
        self.fastboot_path = self._find_executable('fastboot')
        
        self.critical_partitions = {
            'boot', 'system', 'recovery', 'bootloader', 'radio',
            'vendor', 'userdata', 'cache', 'misc', 'persist', 'vbmeta'
        }

    def _find_executable(self, name: str) -> str:
        """
        Locate an executable in system PATH or common SDK locations.
        """
        # 1. Check if it's in the system PATH
        try:
            result = subprocess.run(['which' if platform.system() != 'Windows' else 'where', name], capture_output=True, text=True, check=False)
            if result.returncode == 0:
                return result.stdout.strip().split('\n')[0]
        except FileNotFoundError:
            pass
            
        # 2. Check common manual installation paths
        home = Path.home()
        common_paths = [
            home / 'Android/Sdk/platform-tools',
            home / 'Library/Android/sdk/platform-tools',  # macOS
            Path('/usr/local/bin'),
            Path('/usr/bin'),
            Path('/opt/android-sdk/platform-tools'),  # Arch Linux Path
            home / 'AppData/Local/Android/sdk/platform-tools' # Windows
        ]
        
        for path in common_paths:
            executable_path = path / (name + ('.exe' if platform.system() == 'Windows' else ''))
            if executable_path.is_file():
                return str(executable_path)
        
        raise FileNotFoundError(
            f"{name.upper()} not found. Please install Android SDK Platform-Tools and ensure it's in your system's PATH."
        )

    def run_command(self, command: List[str], timeout: int = 60) -> Tuple[bool, str, str]:
        """
        Execute a command with proper error handling and colored output.
        """
        try:
            print(f"{Colors.BLUE}Executing: {' '.join(command)}{Colors.ENDC}")
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout,
                check=False
            )
            success = result.returncode == 0
            if not success:
                 print(f"{Colors.RED}Error: {result.stderr.strip()}{Colors.ENDC}")
            return success, result.stdout.strip(), result.stderr.strip()
            
        except subprocess.TimeoutExpired:
            return False, "", f"Command timed out after {timeout} seconds."
        except Exception as e:
            return False, "", f"Command failed with an unexpected error: {e}"

    def get_device_info(self) -> Optional[DeviceInfo]:
        """
        Retrieve comprehensive information for a selected device.
        """
        success, stdout, _ = self.run_command([self.adb_path, 'devices'])
        if not success:
            return None

        lines = stdout.strip().split('\n')[1:]
        connected_devices = [tuple(line.split('\t')) for line in lines if '\t' in line]

        if not connected_devices:
            self.device_info = None
            return None

        if len(connected_devices) > 1:
            print(f"\n{Colors.YELLOW}Multiple devices connected:{Colors.ENDC}")
            for i, (serial, state) in enumerate(connected_devices):
                print(f"{i + 1}. {serial} ({state})")
            
            while True:
                try:
                    choice = int(input("Select device (number): ")) - 1
                    if 0 <= choice < len(connected_devices):
                        serial, state = connected_devices[choice]
                        break
                    else:
                        print(f"{Colors.RED}Invalid selection.{Colors.ENDC}")
                except ValueError:
                    print(f"{Colors.RED}Please enter a number.{Colors.ENDC}")
        else:
            serial, state = connected_devices[0]

        if state == 'unauthorized':
            print(f"\n{Colors.BOLD}{Colors.RED}Device {serial} is unauthorized.{Colors.ENDC}")
            print(f"{Colors.YELLOW}Please check your device screen and allow USB debugging.{Colors.ENDC}")
            self.device_info = DeviceInfo(serial, "Unknown", "Unknown", "Unknown", "Unknown", state)
            return self.device_info

        props = {}
        prop_commands = {
            'model': 'ro.product.model',
            'android_version': 'ro.build.version.release',
            'sdk_version': 'ro.build.version.sdk',
            'bootloader_version': 'ro.bootloader'
        }
        
        for key, prop in prop_commands.items():
            _, stdout, _ = self.run_command([self.adb_path, '-s', serial, 'shell', 'getprop', prop])
            props[key] = stdout or "Unknown"

        self.device_info = DeviceInfo(
            serial=serial,
            model=props['model'],
            android_version=props['android_version'],
            sdk_version=props['sdk_version'],
            bootloader_version=props['bootloader_version'],
            state=state
        )
        return self.device_info

    def display_device_info(self):
        """Display current device information in a formatted way."""
        clear_screen()
        if not self.device_info:
            print(f"{Colors.YELLOW}No device information available. Please connect a device.{Colors.ENDC}")
            return
        
        print("\n" + "="*50)
        print(f"{Colors.BOLD}{Colors.GREEN}CONNECTED DEVICE INFORMATION{Colors.ENDC}")
        print("="*50)
        print(f"{Colors.BOLD}Serial:{Colors.ENDC}           {self.device_info.serial}")
        print(f"{Colors.BOLD}Model:{Colors.ENDC}            {self.device_info.model}")
        print(f"{Colors.BOLD}Android Version:{Colors.ENDC}  {self.device_info.android_version}")
        print(f"{Colors.BOLD}SDK Version:{Colors.ENDC}      {self.device_info.sdk_version}")
        print(f"{Colors.BOLD}Bootloader:{Colors.ENDC}       {self.device_info.bootloader_version}")
        print(f"{Colors.BOLD}State:{Colors.ENDC}            {self.device_info.state}")
        print("="*50 + "\n")
        input(f"{Colors.YELLOW}Press Enter to return to the menu...{Colors.ENDC}")

    def confirm_action(self, message: str) -> bool:
        """Get user confirmation for potentially dangerous actions."""
        prompt = f"\n{Colors.BOLD}{Colors.YELLOW}CONFIRMATION:{Colors.ENDC} {message} (y/N): "
        while True:
            response = input(prompt).strip().lower()
            if response in ['y', 'yes']:
                return True
            elif response in ['n', 'no', '']:
                print(f"{Colors.RED}Operation cancelled.{Colors.ENDC}")
                return False
            else:
                print(f"{Colors.RED}Invalid input. Please enter 'y' or 'n'.{Colors.ENDC}")

    # --- File Operations ---
    def file_operations_menu(self):
        """Menu for file transfer and app management operations."""
        menu_options = {
            '1': ('Push File to Device', self.push_file),
            '2': ('Pull File from Device', self.pull_file),
            '3': ('Batch Push Directory to Device', self.batch_push),
            '4': ('Batch Pull Directory from Device', self.batch_pull),
            '5': ('Install APK', self.install_apk),
            '6': ('Uninstall Package', self.uninstall_package),
            '7': ('List Installed Packages', self.list_packages),
            '8': ('List Device Directory', self.list_device_directory),
            '9': ('Back to Main Menu', None)
        }
        self._run_menu("📁 FILE OPERATIONS", menu_options)

    def push_file(self):
        """Push a single file to the device."""
        local_path = input("Enter local file path: ").strip()
        if not Path(local_path).exists():
            print(f"{Colors.RED}Local file does not exist.{Colors.ENDC}")
            return
        remote_path = input("Enter device destination path (e.g., /sdcard/): ").strip()
        self._execute_file_transfer('push', local_path, remote_path)
    
    def pull_file(self):
        """Pull a single file from the device."""
        remote_path = input("Enter device file path: ").strip()
        local_path = input("Enter local destination path: ").strip()
        self._execute_file_transfer('pull', remote_path, local_path)

    def batch_push(self):
        """Push all files from a local directory to the device."""
        local_dir = input("Enter local directory path: ").strip()
        if not Path(local_dir).is_dir():
            print(f"{Colors.RED}Local directory does not exist.{Colors.ENDC}")
            return
        remote_dir = input("Enter device destination directory (e.g., /sdcard/): ").strip()
        
        for item in Path(local_dir).iterdir():
            if item.is_file():
                self._execute_file_transfer('push', str(item), remote_dir)
        print(f"\n{Colors.GREEN}Batch push complete.{Colors.ENDC}")

    def batch_pull(self):
        """Pull all files from a device directory to the local machine."""
        remote_dir = input("Enter device directory to pull from (e.g., /sdcard/Download/): ").strip()
        local_dir = input("Enter local destination directory: ").strip()
        Path(local_dir).mkdir(exist_ok=True)
        
        success, stdout, _ = self.run_command([self.adb_path, '-s', self.device_info.serial, 'shell', 'ls', '-p', remote_dir])
        if success:
            for filename in stdout.split():
                if not filename.endswith('/'): 
                    remote_file_path = f"{remote_dir.rstrip('/')}/{filename}"
                    self._execute_file_transfer('pull', remote_file_path, local_dir)
            print(f"\n{Colors.GREEN}Batch pull complete.{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Failed to list directory contents for batch pull.{Colors.ENDC}")

    def _execute_file_transfer(self, direction: str, source: str, dest: str):
        """Helper for executing push/pull commands."""
        command = [self.adb_path, '-s', self.device_info.serial, direction, source, dest]
        success, stdout, _ = self.run_command(command, timeout=300)
        if success:
            print(f"{Colors.GREEN}Successfully {direction}ed '{Path(source).name}'.{Colors.ENDC}")
            print(stdout)
        else:
            print(f"{Colors.RED}{direction.capitalize()} failed for '{Path(source).name}'.{Colors.ENDC}")

    def install_apk(self):
        """Install an APK file onto the device."""
        apk_path = input("Enter APK file path: ").strip()
        if not Path(apk_path).is_file() or not apk_path.lower().endswith('.apk'):
            print(f"{Colors.RED}Invalid APK file path.{Colors.ENDC}")
            return
            
        command = [self.adb_path, '-s', self.device_info.serial, 'install', '-r', apk_path]
        success, stdout, _ = self.run_command(command, timeout=300)
        if success and ('Success' in stdout or 'success' in stdout):
            print(f"{Colors.GREEN}Successfully installed {Path(apk_path).name}{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Installation failed.{Colors.ENDC}")

    def uninstall_package(self):
        """Uninstall a package from the device."""
        package_name = input("Enter package name (e.g., com.example.app): ").strip()
        if not package_name: return
        
        command = [self.adb_path, '-s', self.device_info.serial, 'uninstall', package_name]
        success, stdout, _ = self.run_command(command)
        if success and 'Success' in stdout:
            print(f"{Colors.GREEN}Successfully uninstalled {package_name}{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Uninstall failed. The package may not exist.{Colors.ENDC}")
    
    def list_packages(self):
        """List all installed packages on the device."""
        command = [self.adb_path, '-s', self.device_info.serial, 'shell', 'pm', 'list', 'packages']
        success, stdout, _ = self.run_command(command)
        if success:
            packages = sorted([p.replace('package:', '') for p in stdout.split()])
            print(f"\n{Colors.GREEN}Found {len(packages)} packages:{Colors.ENDC}")
            print("-" * 60)
            for pkg in packages:
                print(pkg)
            print("-" * 60)
        else:
            print(f"{Colors.RED}Failed to list packages.{Colors.ENDC}")

    def list_device_directory(self):
        """List contents of a directory on the device."""
        directory = input("Enter device directory path (default: /sdcard/): ").strip() or "/sdcard/"
        command = [self.adb_path, '-s', self.device_info.serial, 'shell', 'ls', '-la', directory]
        success, stdout, _ = self.run_command(command)
        if success:
            print(f"\n{Colors.GREEN}Contents of {directory}:{Colors.ENDC}")
            print("-" * 60)
            print(stdout)
            print("-" * 60)
        else:
            print(f"{Colors.RED}Failed to list directory contents.{Colors.ENDC}")


    # --- Fastboot Operations ---
    def fastboot_menu(self):
        """Menu for dangerous Fastboot operations."""
        clear_screen()
        print(f"\n{Colors.BOLD}{Colors.RED}{'='*60}")
        print("         ⚠️  FASTBOOT MODE - EXTREME CAUTION REQUIRED ⚠️")
        print(f"{'='*60}{Colors.ENDC}")
        print(f"{Colors.YELLOW}Fastboot operations modify critical system partitions.")
        print("Incorrect usage can permanently brick your device!")
        print("Ensure you have the correct files for your specific device model.{Colors.ENDC}")
        
        if not self.confirm_action("Do you understand the risks and want to continue?"):
            return
            
        menu_options = {
            '1': ('Flash Partition', self.fastboot_flash),
            '2': ('Erase Partition', self.fastboot_erase),
            '3': ('Unlock Bootloader (Erases Data)', self.fastboot_unlock),
            '4': ('Lock Bootloader', self.fastboot_lock),
            '5': ('Set Active Slot (A/B Devices)', self.fastboot_set_active_slot),
            '6': ('Get All Device Variables (getvar all)', self.fastboot_getvar_all),
            '7': ('Reboot from Fastboot', self.fastboot_reboot),
            '8': ('Check Fastboot Devices', self.fastboot_devices),
            '9': ('Back to Main Menu', None)
        }
        self._run_menu("🔥 FASTBOOT OPERATIONS", menu_options)

    def fastboot_flash(self):
        """Flash a partition with an image file, with extensive safety checks."""
        partition = input("Enter partition name (e.g., boot, recovery): ").strip().lower()
        if not partition: return
        
        image_path = input("Enter image file path: ").strip()
        if not Path(image_path).is_file():
            print(f"{Colors.RED}Image file does not exist.{Colors.ENDC}")
            return
            
        print(f"\n{Colors.BOLD}{Colors.RED}{'⚠️'*20}\nCRITICAL WARNING: PARTITION FLASHING\n{'⚠️'*20}{Colors.ENDC}")
        print(f"You are about to flash the file '{Path(image_path).name}' to the '{partition}' partition.")
        
        if partition in self.critical_partitions:
            print(f"{Colors.YELLOW}'{partition}' is a critical partition. A wrong image WILL brick your device.{Colors.ENDC}")

        if not self.confirm_action(f"Are you ABSOLUTELY SURE you want to flash '{partition}'?"):
            return
            
        if not self.confirm_action("FINAL CONFIRMATION. There is no going back. Proceed?"):
            return

        command = [self.fastboot_path, 'flash', partition, image_path]
        success, stdout, stderr = self.run_command(command, timeout=600)
        output = stdout + stderr
        if success:
            print(f"{Colors.GREEN}Flash successful!\n{output}{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Flash failed!\n{output}{Colors.ENDC}")

    def fastboot_erase(self):
        """Erase a partition, with safety checks."""
        partition = input("Enter partition name to ERASE (e.g., userdata, cache): ").strip().lower()
        if not partition: return

        print(f"\n{Colors.BOLD}{Colors.RED}{'⚠️'*20}\nCRITICAL WARNING: PARTITION ERASE\n{'⚠️'*20}{Colors.ENDC}")
        print(f"You are about to PERMANENTLY ERASE the '{partition}' partition. This is IRREVERSIBLE.")

        if partition in self.critical_partitions and partition not in ['userdata', 'cache']:
            print(f"{Colors.YELLOW}Erasing the critical partition '{partition}' will likely brick your device.{Colors.ENDC}")

        if not self.confirm_action(f"Are you sure you want to erase '{partition}'?"):
            return

        command = [self.fastboot_path, 'erase', partition]
        success, stdout, stderr = self.run_command(command)
        output = stdout + stderr
        if success:
            print(f"{Colors.GREEN}Erase successful!\n{output}{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Erase failed!\n{output}{Colors.ENDC}")

    def fastboot_unlock(self):
        """Unlock the device bootloader."""
        print(f"\n{Colors.BOLD}{Colors.RED}Unlocking the bootloader WILL WIPE ALL DATA on your device.{Colors.ENDC}")
        if not self.confirm_action("Do you want to proceed with unlocking?"):
            return
        
        command = [self.fastboot_path, 'flashing', 'unlock']
        success, stdout, stderr = self.run_command(command)
        output = stdout + stderr
        if success:
            print(f"{Colors.GREEN}Unlock command sent. Please check your device screen to confirm.{Colors.ENDC}\n{output}")
        else:
            print(f"{Colors.RED}Unlock command failed. Your device might use a different command (e.g., 'fastboot oem unlock').{Colors.ENDC}\n{output}")

    def fastboot_lock(self):
        """Lock the device bootloader."""
        print(f"\n{Colors.BOLD}{Colors.YELLOW}Locking the bootloader is for returning to a factory state.")
        print(f"{Colors.RED}If you have custom software installed, this might BRICK your device.{Colors.ENDC}")
        if not self.confirm_action("Do you want to proceed with locking?"):
            return

        command = [self.fastboot_path, 'flashing', 'lock']
        success, stdout, stderr = self.run_command(command)
        output = stdout + stderr
        if success:
            print(f"{Colors.GREEN}Lock command sent. Please check your device screen.{Colors.ENDC}\n{output}")
        else:
            print(f"{Colors.RED}Lock command failed.{Colors.ENDC}\n{output}")

    def fastboot_set_active_slot(self):
        """Set the active boot slot on A/B devices."""
        slot = input("Enter slot to set as active ('a' or 'b'): ").strip().lower()
        if slot not in ['a', 'b']:
            print(f"{Colors.RED}Invalid slot. Please enter 'a' or 'b'.{Colors.ENDC}")
            return
        
        if not self.confirm_action(f"Are you sure you want to set the active slot to '{slot}'?"):
            return

        command = [self.fastboot_path, f'--set-active={slot}']
        success, stdout, stderr = self.run_command(command)
        output = stdout + stderr
        if success:
            print(f"{Colors.GREEN}Successfully set active slot to '{slot}'.\n{output}{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Failed to set active slot.\n{output}{Colors.ENDC}")

    def fastboot_getvar_all(self):
        """Get all bootloader variables from the device."""
        print(f"{Colors.YELLOW}Fetching all bootloader variables...{Colors.ENDC}")
        command = [self.fastboot_path, 'getvar', 'all']
        success, stdout, stderr = self.run_command(command, timeout=120)
        
        # 'getvar all' command weirdly prints its output to stderr.
        output = stderr if not stdout else stdout + "\n" + stderr
        
        if success or output:
            print(f"\n{Colors.GREEN}Device Variables:{Colors.ENDC}")
            print("-" * 60)
            print(output)
            print("-" * 60)
        else:
            print(f"{Colors.RED}Failed to get device variables.{Colors.ENDC}")

    def fastboot_reboot(self):
        """Reboot the device from Fastboot mode."""
        reboot_options = {
            '1': ('Reboot to System', [self.fastboot_path, 'reboot']),
            '2': ('Reboot to Bootloader', [self.fastboot_path, 'reboot-bootloader']),
            '3': ('Reboot to Recovery', [self.fastboot_path, 'reboot', 'recovery']),
            '4': ('Cancel', None)
        }
        
        clear_screen()
        print(f"\n{Colors.BOLD}{Colors.GREEN}Fastboot Reboot Options{Colors.ENDC}")
        for key, (desc, _) in reboot_options.items():
            print(f"{key}. {desc}")
        
        choice = input("\nSelect option: ").strip()
        if choice in reboot_options and reboot_options[choice][1]:
            self.run_command(reboot_options[choice][1])
            print(f"{Colors.GREEN}Reboot command sent.{Colors.ENDC}")

    def fastboot_devices(self):
        """List devices currently in Fastboot mode."""
        success, stdout, _ = self.run_command([self.fastboot_path, 'devices'])
        if success:
            print(f"\n{Colors.GREEN}Fastboot devices:{Colors.ENDC}")
            print("-" * 30)
            if stdout:
                print(stdout)
            else:
                print("No devices in fastboot mode found.")
            print("-" * 30)

    # --- System Operations ---
    def system_operations_menu(self):
        menu_options = {
            '1': ('Reboot Device', self.reboot_device),
            '2': ('Reboot to Recovery', lambda: self.reboot_device('recovery')),
            '3': ('Reboot to Bootloader', lambda: self.reboot_device('bootloader')),
            '4': ('Take Screenshot', self.take_screenshot),
            '5': ('Screen Recording', self.screen_recording),
            '6': ('View Device Logs (Logcat)', self.logcat),
            '7': ('Interactive Shell Access', self.shell_access),
            '8': ('Get Battery Info', self.get_battery_info),
            '9': ('Get Device IP Address', self.get_device_ip),
            '10': ('Toggle Wi-Fi', self.toggle_wifi),
            '11': ('Back to Main Menu', None)
        }
        self._run_menu("⚙️ SYSTEM OPERATIONS", menu_options)

    def reboot_device(self, mode: str = ''):
        """Reboot the device, with optional mode (recovery, bootloader)."""
        action = mode or 'system'
        if not self.confirm_action(f"Are you sure you want to reboot to '{action}'?"):
            return
        command = [self.adb_path, '-s', self.device_info.serial, 'reboot', mode]
        success, _, _ = self.run_command(command)
        if success:
            print(f"{Colors.GREEN}Reboot command sent successfully.{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Reboot command failed.{Colors.ENDC}")

    def take_screenshot(self):
        """Take a screenshot and pull it to the local machine."""
        timestamp = int(time.time())
        filename = f"screenshot_{timestamp}.png"
        device_path = f"/sdcard/{filename}"
        local_dest = Path.cwd()
        
        success, _, _ = self.run_command([self.adb_path, '-s', self.device_info.serial, 'shell', 'screencap', device_path])
        if success:
            print(f"{Colors.YELLOW}Screenshot taken. Pulling to {local_dest}...{Colors.ENDC}")
            self._execute_file_transfer('pull', device_path, str(local_dest))
            self.run_command([self.adb_path, '-s', self.device_info.serial, 'shell', 'rm', device_path])
        else:
            print(f"{Colors.RED}Failed to take screenshot on device.{Colors.ENDC}")
    
    def screen_recording(self):
        """Record the device screen."""
        try:
            duration_str = input("Enter recording duration in seconds (1-180, default 30): ").strip()
            duration = int(duration_str) if duration_str else 30
            if not 1 <= duration <= 180: raise ValueError
        except ValueError:
            print(f"{Colors.RED}Invalid duration. Please enter a number between 1 and 180.{Colors.ENDC}")
            return
            
        timestamp = int(time.time())
        filename = f"screenrecord_{timestamp}.mp4"
        device_path = f"/sdcard/{filename}"
        local_dest = Path.cwd()
        
        print(f"{Colors.YELLOW}Starting {duration}s screen recording... Press Ctrl+C to stop early.{Colors.ENDC}")
        
        record_command = [
            self.adb_path, '-s', self.device_info.serial, 'shell',
            'screenrecord', f'--time-limit={duration}', device_path
        ]

        try:
            # This is a blocking call, it will wait for the recording to finish or timeout.
            self.run_command(record_command, timeout=duration + 15)
        except KeyboardInterrupt:
            print(f"\n{Colors.YELLOW}Recording stopped by user.{Colors.ENDC}")
            # The recording process on the device needs to be killed manually on Ctrl+C.
            self.run_command([self.adb_path, '-s', self.device_info.serial, 'shell', 'killall', 'screenrecord'])
        finally:
            print(f"{Colors.YELLOW}Pulling video file to {local_dest}...{Colors.ENDC}")
            self._execute_file_transfer('pull', device_path, str(local_dest))
            self.run_command([self.adb_path, '-s', self.device_info.serial, 'shell', 'rm', device_path])

    def logcat(self):
        """View device logs in real-time."""
        print(f"\n{Colors.YELLOW}Starting real-time log monitoring... Press Ctrl+C to stop.{Colors.ENDC}")
        logcat_process = None
        try:
            command = [self.adb_path, '-s', self.device_info.serial, 'logcat']
            logcat_process = subprocess.Popen(command)
            logcat_process.wait()
        except KeyboardInterrupt:
            print(f"\n{Colors.GREEN}Logcat stopped.{Colors.ENDC}")
        finally:
            if logcat_process and logcat_process.poll() is None:
                logcat_process.terminate()

    def shell_access(self):
        """Provide an interactive shell to the device."""
        print(f"\n{Colors.YELLOW}Starting interactive shell... Type 'exit' or press Ctrl+D to quit.{Colors.ENDC}")
        print("-" * 50)
        subprocess.run([self.adb_path, '-s', self.device_info.serial, 'shell'])
        print("-" * 50)
        print(f"{Colors.GREEN}Shell session ended.{Colors.ENDC}")

    def get_battery_info(self):
        """Displays detailed battery information."""
        success, stdout, _ = self.run_command([self.adb_path, '-s', self.device_info.serial, 'shell', 'dumpsys', 'battery'])
        if success:
            print(f"\n{Colors.GREEN}Battery Information:{Colors.ENDC}")
            print("-" * 60)
            print(stdout)
            print("-" * 60)
        else:
            print(f"{Colors.RED}Failed to get battery information.{Colors.ENDC}")

    def get_device_ip(self):
        """Gets and displays the device's Wi-Fi IP address."""
        success, stdout, _ = self.run_command([self.adb_path, '-s', self.device_info.serial, 'shell', 'ip', 'addr', 'show', 'wlan0'])
        if success and 'inet' in stdout:
            ip_line = [line for line in stdout.split('\n') if 'inet ' in line][0]
            ip_address = ip_line.strip().split()[1].split('/')[0]
            print(f"\n{Colors.GREEN}Device Wi-Fi IP Address: {Colors.BOLD}{ip_address}{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Could not determine Wi-Fi IP address. Is the device connected to Wi-Fi?{Colors.ENDC}")

    def toggle_wifi(self):
        """Enables or disables Wi-Fi on the device."""
        choice = input("Do you want to [1] Enable or [2] Disable Wi-Fi? Enter 1 or 2: ").strip()
        if choice == '1':
            command = [self.adb_path, '-s', self.device_info.serial, 'shell', 'svc', 'wifi', 'enable']
            action = "Enabling"
            final_state = "enabled"
        elif choice == '2':
            command = [self.adb_path, '-s', self.device_info.serial, 'shell', 'svc', 'wifi', 'disable']
            action = "Disabling"
            final_state = "disabled"
        else:
            print(f"{Colors.RED}Invalid choice.{Colors.ENDC}")
            return
        
        print(f"{Colors.YELLOW}{action} Wi-Fi...{Colors.ENDC}")
        success, _, _ = self.run_command(command)
        if success:
            print(f"{Colors.GREEN}Wi-Fi has been {final_state}.{Colors.ENDC}")
        else:
            print(f"{Colors.RED}Failed to change Wi-Fi state.{Colors.ENDC}")

    # --- Main Menu Logic ---
    
    def _run_menu(self, title: str, options: Dict[str, Tuple[str, callable]]):
        """Generic function to display and handle a menu."""
        while True:
            clear_screen()
            print(f"\n{Colors.BOLD}{Colors.GREEN}{title}{Colors.ENDC}")
            print("-" * 40)
            for key, (desc, _) in options.items():
                print(f"{Colors.YELLOW}{key}{Colors.ENDC}. {desc}")
            print("-" * 40)
            
            choice = input("Select option: ").strip()
            
            if choice in options:
                desc, func = options[choice]
                if func is None: # Exit option
                    break
                clear_screen()
                print(f"{Colors.HEADER}--- {desc} ---{Colors.ENDC}")
                func()
                input(f"\n\n{Colors.YELLOW}Press Enter to return to the menu...{Colors.ENDC}")
            else:
                print(f"{Colors.RED}Invalid choice. Please try again.{Colors.ENDC}")
                time.sleep(1)

    def main_menu(self):
        """The main application menu."""
        while True:
            clear_screen()
            print("\n" + "="*60)
            print(f"{Colors.BOLD}{Colors.BLUE}PYDROIDB MAIN MENU{Colors.ENDC}")
            print("="*60)

            if not self.device_info:
                print(f"\n{Colors.YELLOW}Searching for devices...{Colors.ENDC}")
                self.get_device_info()

            if self.device_info:
                state_color = Colors.GREEN if self.device_info.state == 'device' else Colors.RED
                print(f"Connected Device: {Colors.BOLD}{self.device_info.model}{Colors.ENDC} ({state_color}{self.device_info.state}{Colors.ENDC})")
            else:
                print(f"\n{Colors.BOLD}{Colors.RED}⚠️ No device connected or authorized.{Colors.ENDC}")
                print(f"{Colors.YELLOW}Please connect an Android device with USB debugging enabled.{Colors.ENDC}")
            
            print("="*60)

            menu_options = {
                '1': 'Device Information',
                '2': 'File Operations',
                '3': 'System Operations',
                '4': 'Fastboot Operations (DANGEROUS)',
                '5': 'Refresh Device List',
                '6': 'Exit'
            }

            for key, desc in menu_options.items():
                 print(f"{Colors.YELLOW}{key}{Colors.ENDC}. {desc}")

            choice = input("\nSelect option: ").strip()

            if choice == '1':
                if self.device_info: self.display_device_info()
            elif choice == '2':
                if self.device_info and self.device_info.state == 'device': self.file_operations_menu()
            elif choice == '3':
                if self.device_info and self.device_info.state == 'device': self.system_operations_menu()
            elif choice == '4':
                self.fastboot_menu()
            elif choice == '5':
                self.device_info = None # Force a refresh on the next loop
            elif choice == '6':
                print(f"{Colors.BOLD}{Colors.BLUE}Goodbye!{Colors.ENDC}")
                break
            else:
                print(f"{Colors.RED}Invalid choice. Please try again.{Colors.ENDC}")
                time.sleep(1)


def main():
    """Main application entry point."""
    try:
        clear_screen()
        display_banner()
        tool = ADBAutomationTool()
        tool.main_menu()
    
    except FileNotFoundError as e:
        print(f"\n{Colors.BOLD}{Colors.RED}FATAL ERROR: {e}{Colors.ENDC}")
        print("\nPlease install Android SDK Platform Tools from:")
        print("https://developer.android.com/studio/releases/platform-tools")
        print("Then, add the extracted directory to your system's PATH variable.")
    
    except KeyboardInterrupt:
        print(f"\n\n{Colors.YELLOW}Tool interrupted by user. Goodbye!{Colors.ENDC}")
    
    except Exception as e:
        print(f"\n{Colors.BOLD}{Colors.RED}An unexpected error occurred: {e}{Colors.ENDC}")
        print("Please report this issue on GitHub with the error details.")

if __name__ == "__main__":
    main()
